// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: pairing.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// 配对状态枚举
enum Nearclip_Pairing_PairingStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  typealias RawValue = Int
  case pairingUnknown // = 0
  case pairingInitiated // = 1
  case pairingPending // = 2
  case pairingConfirmed // = 3
  case pairingFailed // = 4
  case pairingCompleted // = 5
  case UNRECOGNIZED(Int)

  init() {
    self = .pairingUnknown
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .pairingUnknown
    case 1: self = .pairingInitiated
    case 2: self = .pairingPending
    case 3: self = .pairingConfirmed
    case 4: self = .pairingFailed
    case 5: self = .pairingCompleted
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .pairingUnknown: return 0
    case .pairingInitiated: return 1
    case .pairingPending: return 2
    case .pairingConfirmed: return 3
    case .pairingFailed: return 4
    case .pairingCompleted: return 5
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static let allCases: [Nearclip_Pairing_PairingStatus] = [
    .pairingUnknown,
    .pairingInitiated,
    .pairingPending,
    .pairingConfirmed,
    .pairingFailed,
    .pairingCompleted,
  ]

}

/// 配对请求
struct Nearclip_Pairing_PairingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var initiatorID: String = String()

  var targetID: String = String()

  var publicKey: Data = Data()

  var deviceName: String = String()

  /// 随机数，防止重放攻击
  var nonce: Data = Data()

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 配对响应
struct Nearclip_Pairing_PairingResponse: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var responderID: String = String()

  var initiatorID: String = String()

  var publicKey: Data = Data()

  /// 签名的随机数
  var signedNonce: Data = Data()

  /// ECDH 共享密钥
  var sharedSecret: Data = Data()

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 配对确认
struct Nearclip_Pairing_PairingConfirmation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  /// 确认哈希
  var confirmationHash: Data = Data()

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 配对状态更新
struct Nearclip_Pairing_PairingStatusUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var sessionID: String = String()

  var status: Nearclip_Pairing_PairingStatus = .pairingUnknown

  var errorMessage: String = String()

  var timestamp: UInt64 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

/// 解除配对请求
struct Nearclip_Pairing_UnpairingRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var reason: String = String()

  var signature: Data = Data()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "nearclip.pairing"

extension Nearclip_Pairing_PairingStatus: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0PAIRING_UNKNOWN\0\u{1}PAIRING_INITIATED\0\u{1}PAIRING_PENDING\0\u{1}PAIRING_CONFIRMED\0\u{1}PAIRING_FAILED\0\u{1}PAIRING_COMPLETED\0")
}

extension Nearclip_Pairing_PairingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}initiator_id\0\u{3}target_id\0\u{3}public_key\0\u{3}device_name\0\u{1}nonce\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.initiatorID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.targetID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.deviceName) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.nonce) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.initiatorID.isEmpty {
      try visitor.visitSingularStringField(value: self.initiatorID, fieldNumber: 1)
    }
    if !self.targetID.isEmpty {
      try visitor.visitSingularStringField(value: self.targetID, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.deviceName.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceName, fieldNumber: 4)
    }
    if !self.nonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.nonce, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nearclip_Pairing_PairingRequest, rhs: Nearclip_Pairing_PairingRequest) -> Bool {
    if lhs.initiatorID != rhs.initiatorID {return false}
    if lhs.targetID != rhs.targetID {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.deviceName != rhs.deviceName {return false}
    if lhs.nonce != rhs.nonce {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nearclip_Pairing_PairingResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairingResponse"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}responder_id\0\u{3}initiator_id\0\u{3}public_key\0\u{3}signed_nonce\0\u{3}shared_secret\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.responderID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.initiatorID) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.publicKey) }()
      case 4: try { try decoder.decodeSingularBytesField(value: &self.signedNonce) }()
      case 5: try { try decoder.decodeSingularBytesField(value: &self.sharedSecret) }()
      case 6: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.responderID.isEmpty {
      try visitor.visitSingularStringField(value: self.responderID, fieldNumber: 1)
    }
    if !self.initiatorID.isEmpty {
      try visitor.visitSingularStringField(value: self.initiatorID, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularBytesField(value: self.publicKey, fieldNumber: 3)
    }
    if !self.signedNonce.isEmpty {
      try visitor.visitSingularBytesField(value: self.signedNonce, fieldNumber: 4)
    }
    if !self.sharedSecret.isEmpty {
      try visitor.visitSingularBytesField(value: self.sharedSecret, fieldNumber: 5)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nearclip_Pairing_PairingResponse, rhs: Nearclip_Pairing_PairingResponse) -> Bool {
    if lhs.responderID != rhs.responderID {return false}
    if lhs.initiatorID != rhs.initiatorID {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.signedNonce != rhs.signedNonce {return false}
    if lhs.sharedSecret != rhs.sharedSecret {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nearclip_Pairing_PairingConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairingConfirmation"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0\u{3}confirmation_hash\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.confirmationHash) }()
      case 3: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if !self.confirmationHash.isEmpty {
      try visitor.visitSingularBytesField(value: self.confirmationHash, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nearclip_Pairing_PairingConfirmation, rhs: Nearclip_Pairing_PairingConfirmation) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.confirmationHash != rhs.confirmationHash {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nearclip_Pairing_PairingStatusUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PairingStatusUpdate"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}session_id\0\u{1}status\0\u{3}error_message\0\u{1}timestamp\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.sessionID) }()
      case 2: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.errorMessage) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.timestamp) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.sessionID.isEmpty {
      try visitor.visitSingularStringField(value: self.sessionID, fieldNumber: 1)
    }
    if self.status != .pairingUnknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 2)
    }
    if !self.errorMessage.isEmpty {
      try visitor.visitSingularStringField(value: self.errorMessage, fieldNumber: 3)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularUInt64Field(value: self.timestamp, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nearclip_Pairing_PairingStatusUpdate, rhs: Nearclip_Pairing_PairingStatusUpdate) -> Bool {
    if lhs.sessionID != rhs.sessionID {return false}
    if lhs.status != rhs.status {return false}
    if lhs.errorMessage != rhs.errorMessage {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Nearclip_Pairing_UnpairingRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnpairingRequest"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}device_id\0\u{1}reason\0\u{1}signature\0")

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.reason) }()
      case 3: try { try decoder.decodeSingularBytesField(value: &self.signature) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.reason.isEmpty {
      try visitor.visitSingularStringField(value: self.reason, fieldNumber: 2)
    }
    if !self.signature.isEmpty {
      try visitor.visitSingularBytesField(value: self.signature, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Nearclip_Pairing_UnpairingRequest, rhs: Nearclip_Pairing_UnpairingRequest) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.reason != rhs.reason {return false}
    if lhs.signature != rhs.signature {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
