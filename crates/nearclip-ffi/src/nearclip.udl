// NearClip FFI Interface Definition
// uniffi 0.28 UDL format
// See: https://mozilla.github.io/uniffi-rs/udl_file_spec.html

namespace nearclip {
    // Logging functions
    void init_logging(LogLevel level);
    void flush_logs();
};

// Error type - all variants must include error string
[Error]
enum NearClipError {
    "Network",
    "Bluetooth",
    "Crypto",
    "DeviceNotFound",
    "Sync",
    "Config",
    "Io",
    "NotInitialized",
};

// Log level enum
enum LogLevel {
    "Error",
    "Warn",
    "Info",
    "Debug",
    "Trace",
};

// Device platform enum
enum DevicePlatform {
    "MacOS",
    "Android",
    "Unknown",
};

// Device connection status
enum DeviceStatus {
    "Connected",
    "Disconnected",
    "Connecting",
    "Failed",
};

// Device information record
dictionary FfiDeviceInfo {
    string id;
    string name;
    DevicePlatform platform;
    DeviceStatus status;
};

// Configuration record
dictionary FfiNearClipConfig {
    string device_name;
    string device_id;
    boolean wifi_enabled;
    boolean ble_enabled;
    boolean auto_connect;
    u64 connection_timeout_secs;
    u64 heartbeat_interval_secs;
    u32 max_retries;
};

// Sync history entry
dictionary FfiSyncHistoryEntry {
    i64 id;
    string device_id;
    string device_name;
    string content_preview;
    u64 content_size;
    string direction;
    i64 timestamp_ms;
    boolean success;
    string? error_message;
};

// Discovered device info for BLE scanning
dictionary FfiDiscoveredDevice {
    string peripheral_uuid;
    string? device_name;
    i16 rssi;
    string? public_key_hash;
};

// Callback interface for receiving events
callback interface FfiNearClipCallback {
    void on_device_connected(FfiDeviceInfo device);
    void on_device_disconnected(string device_id);
    void on_device_unpaired(string device_id);
    void on_pairing_rejected(string device_id, string reason);
    void on_clipboard_received(bytes content, string from_device);
    void on_sync_error(string error_message);

    // BLE discovery callbacks (for BleController integration)
    void on_device_discovered(FfiDiscoveredDevice device);
    void on_device_lost(string peripheral_uuid);
};

// Device storage callback interface - platform implements this to provide persistent storage
// Rust layer decides WHEN to save/load/delete, platform layer implements HOW (Keychain/SharedPreferences)
callback interface FfiDeviceStorage {
    // Save a paired device to persistent storage
    // Called by Rust when a device is successfully paired and connected
    void save_device(FfiDeviceInfo device);

    // Remove a paired device from persistent storage
    // Called by Rust when a device is unpaired
    void remove_device(string device_id);

    // Load all paired devices from persistent storage
    // Called by Rust during initialization
    sequence<FfiDeviceInfo> load_all_devices();
};

// BLE hardware callback interface - platform implements this to provide low-level BLE hardware access
//
// ## v2 Design Philosophy
//
// Platform code should ONLY provide direct BLE hardware access:
// - Scanning (start/stop)
// - Connection (connect/disconnect)
// - GATT operations (read/write/subscribe characteristics)
// - Advertising (start/stop with service data)
//
// All higher-level logic is handled by Rust BleController:
// - Device discovery and mapping
// - Connection state management
// - Data chunking/reassembly
// - Auto-reconnection
// - Health checks
//
// ## Error Handling
//
// Methods that can fail use a return string:
// - Empty string "" = success
// - Non-empty string = error message
callback interface FfiBleHardware {
    // ========== Scanning ==========

    void start_scan();
    void stop_scan();

    // ========== Connection ==========

    void connect(string peripheral_uuid);
    void disconnect(string peripheral_uuid);

    // ========== GATT Operations ==========

    // Read a GATT characteristic value
    // Returns data on success, or error message on failure
    // Since UDL doesn't support Result in callbacks, we use a workaround:
    // - Empty byte array = error (check error_string for details)
    // - Non-empty byte array = success
    bytes read_characteristic(string peripheral_uuid, string char_uuid);

    // Returns empty string on success, error message on failure
    string write_characteristic(string peripheral_uuid, string char_uuid, bytes data);

    // Returns empty string on success, error message on failure
    string subscribe_characteristic(string peripheral_uuid, string char_uuid);

    // ========== Advertising ==========

    // Start advertising with service data
    void start_advertising(bytes service_data);
    void stop_advertising();

    // ========== Status Query ==========

    boolean is_connected(string peripheral_uuid);
    u32 get_mtu(string peripheral_uuid);
};

// Main manager interface
interface FfiNearClipManager {
    [Throws=NearClipError]
    constructor(FfiNearClipConfig config, FfiNearClipCallback callback);

    // Lifecycle
    [Throws=NearClipError]
    void start();

    void stop();

    boolean is_running();

    // Clipboard sync
    [Throws=NearClipError]
    void sync_clipboard(bytes content);

    // Device management
    sequence<FfiDeviceInfo> get_paired_devices();
    sequence<FfiDeviceInfo> get_connected_devices();

    [Throws=NearClipError]
    void connect_device(string device_id);

    [Throws=NearClipError]
    void disconnect_device(string device_id);

    void add_paired_device(FfiDeviceInfo device);
    void remove_paired_device(string device_id);

    [Throws=NearClipError]
    void unpair_device(string device_id);

    // Status
    DeviceStatus? get_device_status(string device_id);

    // Device info
    string get_device_id();

    // Auto-connect
    u32 try_connect_paired_devices();

    // BLE data handling - called by platform when BLE data is received
    void on_ble_data_received(string device_id, bytes data);

    // BLE connection state - called by platform when BLE connection state changes
    void on_ble_connection_changed(string device_id, boolean connected);

    // BLE device discovery - called by platform when a BLE device is discovered
    // This updates the device_id -> peripheral_uuid mapping for connect_with_scan
    void on_ble_device_discovered(string peripheral_uuid, string device_id, string public_key_hash, i32 rssi);

    // Set BLE hardware interface
    // Platform clients call this to provide full BLE hardware access
    void set_ble_hardware(FfiBleHardware hardware);

    // Set device storage interface
    // Platform clients call this to provide persistent storage (Keychain/SharedPreferences)
    // Must be called before start() to load existing paired devices
    void set_device_storage(FfiDeviceStorage storage);

    // Pair a new device - adds to memory, attempts connection, saves to storage on success
    // This is the main entry point for pairing flow
    // Returns true if pairing succeeded (connected and saved), false otherwise
    [Throws=NearClipError]
    boolean pair_device(FfiDeviceInfo device);

    // BLE discovery control (requires set_ble_hardware)
    void start_discovery();
    void stop_discovery();

    // History management
    [Throws=NearClipError]
    void init_history(string db_path);

    [Throws=NearClipError]
    i64 add_history_entry(FfiSyncHistoryEntry entry);

    [Throws=NearClipError]
    sequence<FfiSyncHistoryEntry> get_recent_history(u64 limit);

    [Throws=NearClipError]
    sequence<FfiSyncHistoryEntry> get_device_history(string device_id, u64 limit);

    [Throws=NearClipError]
    void clear_all_history();

    [Throws=NearClipError]
    u64 clear_old_history(u32 days);

    [Throws=NearClipError]
    u64 get_history_count();
};
