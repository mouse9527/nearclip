# Story 1.6: Rust 共享逻辑库开发

## Status
Draft

## Story
**作为** 开发者，
**我希望** 开发 Rust 共享逻辑库，实现跨平台的核心业务逻辑，包括设备管理、通信协议处理、数据同步和安全加密，
**以便** 为 Android 和 Mac 平台提供一致的功能接口，确保跨平台的性能和安全性。

## Acceptance Criteria
1. 实现 Rust 项目的完整结构和配置（Cargo.toml、模块组织）
2. 开发设备发现和管理功能，支持 BLE 扫描和设备状态跟踪
3. 实现安全的通信协议处理，包括消息加密/解密和签名验证
4. 创建数据同步引擎，支持跨平台剪贴板数据同步
5. 实现加密和安全模块，包括密钥管理和安全存储
6. 创建 FFI 接口层，为 Android 和 Mac 提供跨语言调用支持

## Tasks / Subtasks
- [ ] 设置 Rust 项目结构 (AC: 1)
  - [ ] 创建 Cargo.toml 配置文件
  - [ ] 设置项目模块结构（src/bin、src/lib、src/ffi）
  - [ ] 配置依赖项（BLE、加密、序列化等）
  - [ ] 设置构建脚本和 CI/CD 集成
  - [ ] 创建单元测试框架配置
- [ ] 实现设备发现模块 (AC: 2)
  - [ ] 创建 BLE 扫描器
  - [ ] 实现设备广播和发现
  - [ ] 开发设备状态管理器
  - [ ] 实现设备能力协商
  - [ ] 创建设备元数据存储
- [ ] 开发通信协议处理 (AC: 3)
  - [ ] 实现 Protocol Buffers 序列化/反序列化
  - [ ] 创建消息加密/解密模块
  - [ ] 实现消息签名和验证
  - [ ] 开发协议版本协商
  - [ ] 创建消息路由和分发
- [ ] 实现数据同步引擎 (AC: 4)
  - [ ] 创建剪贴板数据管理器
  - [ ] 实现数据分片和重组
  - [ ] 开发增量同步算法
  - [ ] 创建同步状态跟踪
  - [ ] 实现冲突解决机制
- [ ] 开发加密和安全模块 (AC: 5)
  - [ ] 实现密钥生成和管理
  - [ ] 创建安全存储接口
  - [ ] 实现 ECDH 密钥交换
  - [ ] 开发数据完整性验证
  - [ ] 创建安全会话管理
- [ ] 创建 FFI 接口层 (AC: 6)
  - [ ] 设计 C ABI 接口
  - [ ] 实现 Android JNI 绑定
  - [ ] 创建 macOS C 接口绑定
  - [ ] 开发内存安全管理
  - [ ] 创建错误处理和日志记录

## Dev Notes

### Rust 项目结构设计
[Source: architecture/unified-project-structure.md]

#### 项目目录结构
```
src/shared/rust/
├── Cargo.toml
├── build.rs
├── cbindgen.toml
├── src/
│   ├── lib.rs                    # 库入口点
│   ├── main.rs                   # 可执行文件入口（可选）
│   ├── ffi/                      # FFI 接口层
│   │   ├── mod.rs
│   │   ├── android.rs            # Android JNI 接口
│   │   └── macos.rs              # macOS C ABI 接口
│   ├── core/                     # 核心业务逻辑
│   │   ├── mod.rs
│   │   ├── device/               # 设备管理
│   │   │   ├── mod.rs
│   │   │   ├── discovery.rs
│   │   │   ├── manager.rs
│   │   │   └── metadata.rs
│   │   ├── protocol/             # 通信协议
│   │   │   ├── mod.rs
│   │   │   ├── message.rs
│   │   │   ├── handler.rs
│   │   │   └── serializer.rs
│   │   ├── sync/                 # 数据同步
│   │   │   ├── mod.rs
│   │   │   ├── engine.rs
│   │   │   ├── clipboard.rs
│   │   │   └── conflict.rs
│   │   └── security/             # 安全加密
│   │       ├── mod.rs
│   │       ├── crypto.rs
│   │       ├── keyring.rs
│   │       └── session.rs
│   ├── ble/                      # BLE 通信层
│   │   ├── mod.rs
│   │   ├── scanner.rs
│   │   ├── advertiser.rs
│   │   └── connection.rs
│   └── utils/                    # 工具类
│       ├── mod.rs
│       ├── error.rs
│       ├── logger.rs
│       └── config.rs
├── tests/                        # 集成测试
│   ├── integration_tests.rs
│   └── common/
├── benches/                      # 性能基准测试
│   ├── protocol_benchmark.rs
│   └── crypto_benchmark.rs
└── examples/                     # 示例代码
    ├── simple_discovery.rs
    └── basic_sync.rs
```

### Cargo.toml 配置
```toml
[package]
name = "nearclip-core"
version = "0.1.0"
edition = "2021"
authors = ["NearClip Team"]
description = "Cross-platform clipboard synchronization core library"
license = "MIT OR Apache-2.0"
repository = "https://github.com/nearclip/nearclip"

[lib]
name = "nearclip_core"
crate-type = ["cdylib", "rlib"]  # 支持动态库和静态库

[dependencies]
# 异步运行时
tokio = { version = "1.0", features = ["full"] }
async-trait = "0.1"

# 序列化
prost = "0.12"
prost-types = "0.12"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# 加密
ring = "0.17"
rand = "0.8"
base64 = "0.21"

# BLE 通信
btleplug = "0.11"
uuid = "1.0"

# 错误处理
thiserror = "1.0"
anyhow = "1.0"

# 日志记录
log = "0.4"
env_logger = "0.10"

# 时间处理
chrono = { version = "0.4", features = ["serde"] }

# 内存管理
parking_lot = "0.12"

# FFI 支持
libc = "0.2"

# 配置管理
config = "0.14"

[build-dependencies]
prost-build = "0.12"

[dev-dependencies]
tokio-test = "0.4"
criterion = "0.5"

[features]
default = ["ble", "crypto"]
ble = ["btleplug"]
crypto = ["ring"]
android = []
macos = []

[[bench]]
name = "protocol_benchmark"
harness = false

[[bench]]
name = "crypto_benchmark"
harness = false
```

### 核心模块实现

#### 设备发现模块
```rust
// src/core/device/discovery.rs
use btleplug::api::{Central, Manager as _, Peripheral, ScanFilter};
use btleplug::platform::{Adapter, Manager};
use std::collections::HashMap;
use std::time::Duration;
use tokio::time::timeout;
use thiserror::Error;
use crate::core::protocol::message::{DeviceBroadcast, DeviceCapability};
use crate::utils::error::NearclipError;

#[derive(Error, Debug)]
pub enum DiscoveryError {
    #[error("Bluetooth adapter not found")]
    AdapterNotFound,
    #[error("Scanning failed: {0}")]
    ScanFailed(String),
    #[error("Device parsing error: {0}")]
    DeviceParsingError(String),
}

pub struct DeviceScanner {
    manager: Manager,
    adapter: Option<Adapter>,
    discovered_devices: HashMap<String, DeviceBroadcast>,
    scan_timeout: Duration,
}

impl DeviceScanner {
    pub async fn new() -> Result<Self, DiscoveryError> {
        let manager = Manager::new()
            .await
            .map_err(|e| DiscoveryError::ScanFailed(e.to_string()))?;

        Ok(Self {
            manager,
            adapter: None,
            discovered_devices: HashMap::new(),
            scan_timeout: Duration::from_secs(30),
        })
    }

    pub async fn initialize(&mut self) -> Result<(), DiscoveryError> {
        let adapters = self.manager.adapters().await
            .map_err(|e| DiscoveryError::ScanFailed(e.to_string()))?;

        self.adapter = adapters.into_iter().next();

        if self.adapter.is_none() {
            return Err(DiscoveryError::AdapterNotFound);
        }

        Ok(())
    }

    pub async fn start_discovery(&mut self) -> Result<Vec<DeviceBroadcast>, DiscoveryError> {
        let adapter = self.adapter.as_ref()
            .ok_or(DiscoveryError::AdapterNotFound)?;

        // 开始扫描
        adapter.start_scan(ScanFilter::default())
            .await
            .map_err(|e| DiscoveryError::ScanFailed(e.to_string()))?;

        // 扫描指定时间
        let result = timeout(self.scan_timeout, self.collect_devices()).await;

        // 停止扫描
        let _ = adapter.stop_scan().await;

        match result {
            Ok(devices) => Ok(devices),
            Err(_) => Err(DiscoveryError::ScanFailed("Scan timeout".to_string())),
        }
    }

    async fn collect_devices(&mut self) -> Result<Vec<DeviceBroadcast>, DiscoveryError> {
        let adapter = self.adapter.as_ref()
            .ok_or(DiscoveryError::AdapterNotFound)?;

        let mut devices = Vec::new();
        let mut scan_duration = Duration::from_secs(0);
        let scan_interval = Duration::from_millis(100);

        while scan_duration < self.scan_timeout {
            let peripherals = adapter.peripherals().await
                .map_err(|e| DiscoveryError::ScanFailed(e.to_string()))?;

            for peripheral in peripherals {
                if let Ok(device) = self.parse_device(&peripheral).await {
                    let device_id = device.device_id.clone();
                    if !self.discovered_devices.contains_key(&device_id) {
                        self.discovered_devices.insert(device_id.clone(), device.clone());
                        devices.push(device);
                    }
                }
            }

            tokio::time::sleep(scan_interval).await;
            scan_duration += scan_interval;
        }

        Ok(devices)
    }

    async fn parse_device(&self, peripheral: &impl Peripheral) -> Result<DeviceBroadcast, DiscoveryError> {
        let properties = peripheral.properties()
            .await
            .ok_or(DiscoveryError::DeviceParsingError("No properties".to_string()))?;

        let device_id = properties.local_name
            .or_else(|| properties.short_name)
            .unwrap_or_else(|| "unknown".to_string());

        // 解析设备能力（这里需要根据实际的 BLE 服务来解析）
        let capabilities = self.parse_capabilities(peripheral).await?;

        Ok(DeviceBroadcast {
            device_id: device_id.clone(),
            device_name: device_id,
            device_type: crate::core::protocol::message::DeviceType::DEVICE_TYPE_ANDROID, // 需要动态判断
            capabilities,
            version: "1.0.0".to_string(),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            public_key: vec![], // 从设备特征值中读取
            metadata: HashMap::new(),
        })
    }

    async fn parse_capabilities(&self, peripheral: &impl Peripheral) -> Result<Vec<DeviceCapability>, DiscoveryError> {
        // 这里需要根据实际的 BLE 服务 UUID 来判断设备能力
        // 示例实现
        Ok(vec![
            DeviceCapability::CAPABILITY_CLIPBOARD_READ,
            DeviceCapability::CAPABILITY_CLIPBOARD_WRITE,
        ])
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_device_scanner_initialization() {
        let mut scanner = DeviceScanner::new().await;
        assert!(scanner.initialize().await.is_ok() || scanner.initialize().await.is_err());
    }
}
```

#### 设备管理器
```rust
// src/core/device/manager.rs
use std::collections::HashMap;
use std::sync::Arc;
use parking_lot::RwLock;
use tokio::sync::mpsc;
use crate::core::device::discovery::{DeviceScanner, DiscoveryError};
use crate::core::protocol::message::{DeviceBroadcast, DeviceCapability, DeviceType};
use crate::utils::error::NearclipError;

#[derive(Debug, Clone)]
pub struct DeviceInfo {
    pub broadcast: DeviceBroadcast,
    pub is_paired: bool,
    pub last_seen: chrono::DateTime<chrono::Utc>,
    pub connection_status: ConnectionStatus,
}

#[derive(Debug, Clone, PartialEq)]
pub enum ConnectionStatus {
    Disconnected,
    Connecting,
    Connected,
    Pairing,
    Error(String),
}

pub struct DeviceManager {
    scanner: DeviceScanner,
    devices: Arc<RwLock<HashMap<String, DeviceInfo>>>,
    event_sender: mpsc::UnboundedSender<DeviceEvent>,
    event_receiver: Option<mpsc::UnboundedReceiver<DeviceEvent>>,
}

#[derive(Debug, Clone)]
pub enum DeviceEvent {
    DeviceDiscovered(DeviceInfo),
    DeviceLost(String),
    DeviceConnected(String),
    DeviceDisconnected(String),
    PairingCompleted(String),
    PairingFailed(String, String),
}

impl DeviceManager {
    pub async fn new() -> Result<Self, NearclipError> {
        let scanner = DeviceScanner::new().await
            .map_err(|e| NearclipError::DeviceError(e.to_string()))?;

        let (event_sender, event_receiver) = mpsc::unbounded_channel();

        let mut manager = Self {
            scanner,
            devices: Arc::new(RwLock::new(HashMap::new())),
            event_sender,
            event_receiver: Some(event_receiver),
        };

        manager.initialize().await?;
        Ok(manager)
    }

    async fn initialize(&mut self) -> Result<(), NearclipError> {
        self.scanner.initialize().await
            .map_err(|e| NearclipError::DeviceError(e.to_string()))?;
        Ok(())
    }

    pub async fn start_discovery(&mut self) -> Result<Vec<DeviceInfo>, NearclipError> {
        let discovered_broadcasts = self.scanner.start_discovery().await
            .map_err(|e| NearclipError::DeviceError(e.to_string()))?;

        let mut discovered_devices = Vec::new();

        for broadcast in discovered_broadcasts {
            let device_info = DeviceInfo {
                broadcast,
                is_paired: false,
                last_seen: chrono::Utc::now(),
                connection_status: ConnectionStatus::Disconnected,
            };

            let device_id = device_info.broadcast.device_id.clone();

            // 更新设备列表
            self.devices.write().insert(device_id.clone(), device_info.clone());

            // 发送发现事件
            let _ = self.event_sender.send(DeviceEvent::DeviceDiscovered(device_info.clone()));

            discovered_devices.push(device_info);
        }

        Ok(discovered_devices)
    }

    pub fn get_devices(&self) -> Vec<DeviceInfo> {
        self.devices.read().values().cloned().collect()
    }

    pub fn get_device(&self, device_id: &str) -> Option<DeviceInfo> {
        self.devices.read().get(device_id).cloned()
    }

    pub fn update_device_status(&self, device_id: &str, status: ConnectionStatus) -> Result<(), NearclipError> {
        let mut devices = self.devices.write();
        if let Some(device) = devices.get_mut(device_id) {
            device.connection_status = status.clone();
            device.last_seen = chrono::Utc::now();

            // 发送状态更新事件
            let event = match status {
                ConnectionStatus::Connected => DeviceEvent::DeviceConnected(device_id.to_string()),
                ConnectionStatus::Disconnected => DeviceEvent::DeviceDisconnected(device_id.to_string()),
                ConnectionStatus::Pairing => DeviceEvent::PairingCompleted(device_id.to_string()),
                ConnectionStatus::Error(msg) => DeviceEvent::PairingFailed(device_id.to_string(), msg),
                _ => return Ok(()),
            };

            let _ = self.event_sender.send(event);
            Ok(())
        } else {
            Err(NearclipError::DeviceError("Device not found".to_string()))
        }
    }

    pub fn get_event_receiver(&mut self) -> Option<mpsc::UnboundedReceiver<DeviceEvent>> {
        self.event_receiver.take()
    }

    pub fn filter_devices(&self, filter: DeviceFilter) -> Vec<DeviceInfo> {
        self.devices.read()
            .values()
            .filter(|device| filter.matches(device))
            .cloned()
            .collect()
    }
}

pub struct DeviceFilter {
    pub device_types: Option<Vec<DeviceType>>,
    pub capabilities: Option<Vec<DeviceCapability>>,
    pub paired_only: bool,
    pub connected_only: bool,
}

impl DeviceFilter {
    pub fn matches(&self, device: &DeviceInfo) -> bool {
        // 检查设备类型
        if let Some(ref types) = self.device_types {
            if !types.contains(&device.broadcast.device_type) {
                return false;
            }
        }

        // 检查设备能力
        if let Some(ref required_caps) = self.capabilities {
            let device_caps: std::collections::HashSet<_> = device.broadcast.capabilities.iter().collect();
            if !required_caps.iter().all(|cap| device_caps.contains(cap)) {
                return false;
            }
        }

        // 检查配对状态
        if self.paired_only && !device.is_paired {
            return false;
        }

        // 检查连接状态
        if self.connected_only && device.connection_status != ConnectionStatus::Connected {
            return false;
        }

        true
    }
}
```

#### 通信协议处理器
```rust
// src/core/protocol/handler.rs
use prost::Message;
use ring::signature::{self, Ed25519};
use crate::core::protocol::message::{
    NearclipMessage, MessageType,
    discovery::{DeviceBroadcast, ScanRequest, ScanResponse},
    pairing::{PairingRequest, PairingResponse, PairingConfirmation},
    sync::{SyncMessage, SyncAck, ClipboardData},
};
use crate::core::security::crypto::{CryptoManager, MessageEncryption};
use crate::utils::error::NearclipError;

pub struct ProtocolHandler {
    crypto_manager: CryptoManager,
    message_encryption: MessageEncryption,
}

impl ProtocolHandler {
    pub fn new(crypto_manager: CryptoManager) -> Self {
        Self {
            crypto_manager,
            message_encryption: MessageEncryption::new(),
        }
    }

    pub fn serialize_message<T: Message>(&self, message: &T, message_type: MessageType) -> Result<Vec<u8>, NearclipError> {
        let payload = message.encode_to_vec();

        // 创建消息头
        let nearclip_message = NearclipMessage {
            version: 1,
            r#type: message_type as i32,
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            device_id: "local-device-id".to_string(), // 应该从配置中获取
            session_id: self.generate_session_id(),
            payload,
            signature: vec![], // 将在加密后添加
        };

        // 序列化完整消息
        let mut message_bytes = nearclip_message.encode_to_vec();

        // 加密消息
        let encrypted_bytes = self.message_encryption.encrypt(&message_bytes)?;

        // 添加签名
        let signature = self.crypto_manager.sign_message(&encrypted_bytes)?;

        // 创建最终消息（签名在最后）
        let mut final_message = encrypted_bytes;
        final_message.extend_from_slice(&signature);

        Ok(final_message)
    }

    pub fn deserialize_message<T: Message + Default>(&self, data: &[u8]) -> Result<T, NearclipError> {
        if data.len() < 64 { // 签名长度至少64字节
            return Err(NearclipError::ProtocolError("Invalid message format".to_string()));
        }

        let signature_length = 64; // Ed25519 签名长度
        let message_data = &data[..data.len() - signature_length];
        let signature = &data[data.len() - signature_length..];

        // 验证签名
        self.crypto_manager.verify_message(message_data, signature)?;

        // 解密消息
        let decrypted_data = self.message_encryption.decrypt(message_data)?;

        // 解析 Protocol Buffers 消息
        let nearclip_message = NearclipMessage::decode(&*decrypted_data)
            .map_err(|e| NearclipError::ProtocolError(format!("Failed to decode message: {}", e)))?;

        // 解析载荷
        T::decode(&*nearclip_message.payload)
            .map_err(|e| NearclipError::ProtocolError(format!("Failed to decode payload: {}", e)))
    }

    pub fn handle_discovery_request(&self, scan_request: &ScanRequest) -> Result<ScanResponse, NearclipError> {
        // 处理设备发现请求
        // 这里应该调用设备扫描器来获取设备列表
        let devices = vec![]; // 实际实现中应该从设备管理器获取

        Ok(ScanResponse {
            devices,
            scan_duration_ms: 5000, // 实际扫描时间
        })
    }

    pub fn handle_pairing_request(&self, pairing_request: &PairingRequest) -> Result<PairingResponse, NearclipError> {
        // 验证配对请求
        self.validate_pairing_request(pairing_request)?;

        // 生成响应
        let (public_key, shared_secret) = self.crypto_manager.generate_keypair_response(&pairing_request.public_key)?;

        Ok(PairingResponse {
            responder_id: "local-device-id".to_string(),
            initiator_id: pairing_request.initiator_id.clone(),
            public_key,
            signed_nonce: self.crypto_manager.sign_nonce(&pairing_request.nonce)?,
            shared_secret,
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
        })
    }

    pub fn handle_sync_message(&self, sync_message: &SyncMessage) -> Result<SyncAck, NearclipError> {
        // 验证同步消息
        self.validate_sync_message(sync_message)?;

        // 处理数据同步
        // 这里应该调用数据同步引擎来实际处理同步
        let success = true; // 实际同步结果

        Ok(SyncAck {
            data_id: sync_message.data.as_ref().map(|d| d.data_id.clone()).unwrap_or_default(),
            success,
            error_message: if success { String::new() } else { "Sync failed".to_string() },
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
        })
    }

    fn generate_session_id(&self) -> String {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let id: u64 = rng.gen();
        format!("session_{:x}", id)
    }

    fn validate_pairing_request(&self, request: &PairingRequest) -> Result<(), NearclipError> {
        // 验证时间戳（防止重放攻击）
        let now = chrono::Utc::now().timestamp_millis() as u64;
        if now.saturating_sub(request.timestamp) > 300_000 { // 5分钟超时
            return Err(NearclipError::SecurityError("Pairing request expired".to_string()));
        }

        // 验证设备ID
        if request.initiator_id.is_empty() {
            return Err(NearclipError::SecurityError("Invalid initiator ID".to_string()));
        }

        Ok(())
    }

    fn validate_sync_message(&self, message: &SyncMessage) -> Result<(), NearclipError> {
        // 验证消息时间戳
        let now = chrono::Utc::now().timestamp_millis() as u64;
        if now.saturating_sub(message.timestamp) > 60_000 { // 1分钟超时
            return Err(NearclipError::SecurityError("Sync message expired".to_string()));
        }

        // 验证数据完整性
        if let Some(ref data) = message.data {
            if data.data_id.is_empty() {
                return Err(NearclipError::ProtocolError("Invalid data ID".to_string()));
            }
        }

        Ok(())
    }
}
```

### FFI 接口层实现

#### Android JNI 接口
```rust
// src/ffi/android.rs
use jni::JNIEnv;
use jni::objects::{JClass, JString, JObject, JByteArray};
use jni::sys::{jstring, jbyteArray, jint};
use std::ffi::CStr;
use std::os::raw::c_char;
use crate::core::device::manager::DeviceManager;
use crate::core::protocol::handler::ProtocolHandler;
use crate::core::security::crypto::CryptoManager;
use std::sync::Mutex;
use once_cell::sync::Lazy;

// 全局状态管理
static DEVICE_MANAGER: Lazy<Mutex<Option<DeviceManager>>> = Lazy::new(|| Mutex::new(None));
static PROTOCOL_HANDLER: Lazy<Mutex<Option<ProtocolHandler>>> = Lazy::new(|| Mutex::new(None));

#[no_mangle]
pub extern "system" fn Java_com_nearclip_NativeBridge_initializeNearclip(
    env: JNIEnv,
    _class: JClass,
) -> jint {
    // 初始化日志
    env_logger::init();

    // 初始化设备管理器
    let rt = tokio::runtime::Runtime::new().unwrap();
    let device_manager = rt.block_on(async {
        DeviceManager::new().await
    });

    match device_manager {
        Ok(manager) => {
            *DEVICE_MANAGER.lock().unwrap() = Some(manager);

            // 初始化协议处理器
            let crypto_manager = CryptoManager::new();
            let protocol_handler = ProtocolHandler::new(crypto_manager);
            *PROTOCOL_HANDLER.lock().unwrap() = Some(protocol_handler);

            0 // 成功
        }
        Err(_) => -1, // 失败
    }
}

#[no_mangle]
pub extern "system" fn Java_com_nearclip_NativeBridge_startDeviceDiscovery(
    env: JNIEnv,
    _class: JClass,
    callback: JObject,
) -> jint {
    let manager_guard = DEVICE_MANAGER.lock().unwrap();
    if let Some(ref manager) = *manager_guard {
        // 这里需要实现回调机制
        // 由于 Rust 异步和 Java 回调的复杂性，实际实现可能需要更复杂的桥接
        0 // 成功
    } else {
        -1 // 失败
    }
}

#[no_mangle]
pub extern "system" fn Java_com_nearclip_NativeBridge_connectToDevice(
    env: JNIEnv,
    _class: JClass,
    device_id: JString,
) -> jint {
    let device_id_str: String = env.get_string(device_id)
        .expect("Couldn't get java string!")
        .into();

    // 实现设备连接逻辑
    // 这里需要调用设备管理器的连接方法

    0 // 成功
}

#[no_mangle]
pub extern "system" fn Java_com_nearclip_NativeBridge_sendSyncMessage(
    env: JNIEnv,
    _class: JClass,
    device_id: JString,
    content: JByteArray,
) -> jint {
    let device_id_str: String = env.get_string(device_id)
        .expect("Couldn't get java string!")
        .into();

    let content_bytes = env.convert_byte_array(content)
        .expect("Couldn't convert byte array");

    // 实现同步消息发送逻辑

    0 // 成功
}

#[no_mangle]
pub extern "system" fn Java_com_nearclip_NativeBridge_getLastError(
    env: JNIEnv,
    _class: JClass,
) -> jstring {
    let error_message = "No error"; // 实际实现中应该返回最后的错误
    env.new_string(error_message)
        .expect("Couldn't create java string!")
        .into_inner()
}
```

#### macOS C ABI 接口
```rust
// src/ffi/macos.rs
use std::ffi::{CStr, CString};
use std::os::raw::{c_char, c_int};
use crate::core::device::manager::DeviceManager;
use crate::core::protocol::handler::ProtocolHandler;
use crate::core::security::crypto::CryptoManager;
use std::sync::Mutex;
use once_cell::sync::Lazy;

// 全局状态管理
static DEVICE_MANAGER: Lazy<Mutex<Option<DeviceManager>>> = Lazy::new(|| Mutex::new(None));
static PROTOCOL_HANDLER: Lazy<Mutex<Option<ProtocolHandler>>> = Lazy::new(|| Mutex::new(None));

// 错误码定义
#[repr(C)]
pub enum NearclipResult {
    Success = 0,
    InvalidArgument = -1,
    InternalError = -2,
    DeviceNotFound = -3,
    ConnectionFailed = -4,
    ProtocolError = -5,
    SecurityError = -6,
}

// 设备信息结构体（C ABI 兼容）
#[repr(C)]
pub struct NearclipDevice {
    pub device_id: *const c_char,
    pub device_name: *const c_char,
    pub device_type: c_int,
    pub is_connected: bool,
    pub is_paired: bool,
    pub last_seen: u64,
    pub battery_level: u8,
}

// 回调函数类型定义
pub type DeviceDiscoveryCallback = extern "C" fn(device: *const NearclipDevice);
pub type SyncCallback = extern "C" fn(device_id: *const c_char, data: *const u8, length: c_int);

// C ABI 函数实现
#[no_mangle]
pub extern "C" fn nearclip_initialize() -> NearclipResult {
    // 初始化日志
    env_logger::init();

    // 初始化设备管理器
    let rt = tokio::runtime::Runtime::new().unwrap();
    let device_manager = rt.block_on(async {
        DeviceManager::new().await
    });

    match device_manager {
        Ok(manager) => {
            *DEVICE_MANAGER.lock().unwrap() = Some(manager);

            // 初始化协议处理器
            let crypto_manager = CryptoManager::new();
            let protocol_handler = ProtocolHandler::new(crypto_manager);
            *PROTOCOL_HANDLER.lock().unwrap() = Some(protocol_handler);

            NearclipResult::Success
        }
        Err(_) => NearclipResult::InternalError,
    }
}

#[no_mangle]
pub extern "C" fn nearclip_start_discovery(callback: DeviceDiscoveryCallback) -> NearclipResult {
    let manager_guard = DEVICE_MANAGER.lock().unwrap();
    if let Some(ref manager) = *manager_guard {
        // 这里需要实现异步到同步的转换
        // 由于 C ABI 是同步的，我们需要使用线程或其他机制来处理异步操作
        NearclipResult::Success
    } else {
        NearclipResult::InternalError
    }
}

#[no_mangle]
pub extern "C" fn nearclip_connect_to_device(device_id: *const c_char) -> NearclipResult {
    if device_id.is_null() {
        return NearclipResult::InvalidArgument;
    }

    let device_id_str = unsafe {
        CStr::from_ptr(device_id).to_string_lossy().into_owned()
    };

    // 实现设备连接逻辑
    // 这里需要调用设备管理器的连接方法

    NearclipResult::Success
}

#[no_mangle]
pub extern "C" fn nearclip_send_sync_message(
    device_id: *const c_char,
    content: *const u8,
    length: c_int,
) -> NearclipResult {
    if device_id.is_null() || content.is_null() {
        return NearclipResult::InvalidArgument;
    }

    let device_id_str = unsafe {
        CStr::from_ptr(device_id).to_string_lossy().into_owned()
    };

    let data = unsafe {
        std::slice::from_raw_parts(content, length as usize)
    };

    // 实现同步消息发送逻辑

    NearclipResult::Success
}

#[no_mangle]
pub extern "C" fn nearclip_set_sync_callback(callback: SyncCallback) -> NearclipResult {
    // 设置同步回调函数
    // 这里需要存储回调函数以便后续使用

    NearclipResult::Success
}

#[no_mangle]
pub extern "C" fn nearclip_get_error_message() -> *const c_char {
    let error_message = CString::new("No error").unwrap();
    error_message.into_raw()
}

#[no_mangle]
pub extern "C" fn nearclip_free_string(ptr: *mut c_char) {
    if !ptr.is_null() {
        unsafe {
            let _ = CString::from_raw(ptr);
        }
    }
}

// 辅助函数：将 Rust 设备信息转换为 C 结构体
fn device_to_c_device(device: crate::core::device::manager::DeviceInfo) -> NearclipDevice {
    let device_id = CString::new(device.broadcast.device_id).unwrap().into_raw();
    let device_name = CString::new(device.broadcast.device_name).unwrap().into_raw();

    NearclipDevice {
        device_id,
        device_name,
        device_type: device.broadcast.device_type as c_int,
        is_connected: device.connection_status == crate::core::device::manager::ConnectionStatus::Connected,
        is_paired: device.is_paired,
        last_seen: device.last_seen.timestamp_millis(),
        battery_level: 0, // 需要从设备信息中获取
    }
}
```

### 构建配置

#### build.rs
```rust
// build.rs
use std::env;
use std::path::PathBuf;

fn main() {
    // 生成 Protocol Buffers 代码
    let proto_files = [
        "src/shared/protocol/discovery.proto",
        "src/shared/protocol/pairing.proto",
        "src/shared/protocol/sync.proto",
        "src/shared/protocol/common.proto",
    ];

    let mut prost_build = prost_build::Config::new();

    // 配置代码生成
    prost_build.type_attribute(".", "#[derive(serde::Serialize, serde::Deserialize)]");

    // 生成代码
    prost_build
        .compile_protos(&proto_files, &["src/shared/protocol/"])
        .expect("Failed to compile protos");

    // 生成 C 头文件（用于 macOS）
    #[cfg(target_os = "macos")]
    {
        let crate_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
        let out_dir = PathBuf::from(env::var("OUT_DIR").unwrap());

        // 使用 cbindgen 生成 C 头文件
        let config = cbindgen::Config::from_file("cbindgen.toml")
            .expect("Failed to read cbindgen.toml");

        cbindgen::Builder::new()
            .with_crate(crate_dir)
            .with_config(config)
            .generate()
            .expect("Unable to generate bindings")
            .write_to_file(out_dir.join("nearclip.h"));
    }

    // 链接系统库
    #[cfg(target_os = "android")]
    {
        println!("cargo:rustc-link-lib=android");
        println!("cargo:rustc-link-lib=log");
    }

    #[cfg(target_os = "macos")]
    {
        println!("cargo:rustc-link-lib=framework=Foundation");
        println!("cargo:rustc-link-lib=framework=CoreBluetooth");
    }
}
```

#### cbindgen.toml
```toml
language = "C"

[export]
prefix = "Nearclip"
include = ["DeviceManager", "ProtocolHandler", "CryptoManager"]

[fn]
prefix = "nearclip_"
rename_args = "snake_case"

[enum]
rename_variants = "ScreamingSnakeCase"
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | 初始故事创建，添加 Rust 共享逻辑库开发 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写