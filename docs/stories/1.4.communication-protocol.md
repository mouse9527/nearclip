# Story 1.4: 通信协议设计与定义

## Status
Draft

## Story
**作为** 开发者，
**我希望** 设计和定义 NearClip 设备间的通信协议，包括设备发现、配对认证、数据同步和错误处理，
**以便** 确保 Android 和 Mac 平台之间能够安全、可靠地进行数据交换。

## Acceptance Criteria
1. 设计完整的设备发现协议，包含广播、扫描和响应机制
2. 定义设备配对和安全认证协议，包含密钥交换和验证机制
3. 创建剪贴板数据同步协议，支持文本、图片和文件传输
4. 设计错误处理和重试机制，确保通信可靠性
5. 定义协议版本兼容性规则，支持向后兼容
6. 创建 Protocol Buffers 定义文件，包含所有消息结构

## Tasks / Subtasks
- [ ] 设计设备发现协议 (AC: 1)
  - [ ] 定义设备广播消息格式
  - [ ] 设计设备扫描和响应机制
  - [ ] 实现设备能力协商
  - [ ] 设置发现超时和重试策略
  - [ ] 创建设备元数据交换格式
- [ ] 定义配对和安全协议 (AC: 2)
  - [ ] 设计配对请求和响应流程
  - [ ] 实现基于 ECDH 的密钥交换
  - [ ] 创建设备身份验证机制
  - [ ] 定义配对状态管理
  - [ ] 实现配对失败处理
- [ ] 创建数据同步协议 (AC: 3)
  - [ ] 定义剪贴板数据类型支持
  - [ ] 设计数据分片和重组机制
  - [ ] 实现增量同步策略
  - [ ] 创建数据完整性验证
  - [ ] 设置同步优先级和队列管理
- [ ] 设计错误处理机制 (AC: 4)
  - [ ] 定义标准错误码和消息
  - [ ] 实现自动重试策略
  - [ ] 创建网络故障恢复机制
  - [ ] 设计超时处理逻辑
  - [ ] 实现连接状态监控
- [ ] 定义版本兼容性规则 (AC: 5)
  - [ ] 设计协议版本协商机制
  - [ ] 定义向后兼容策略
  - [ ] 实现功能降级支持
  - [ ] 创建弃用功能通知
  - [ ] 设置版本升级路径
- [ ] 创建 Protocol Buffers 定义 (AC: 6)
  - [ ] 编写 discovery.proto 文件
  - [ ] 编写 pairing.proto 文件
  - [ ] 编写 sync.proto 文件
  - [ ] 编写 common.proto 文件
  - [ ] 生成各语言绑定代码

## Dev Notes

### 通信协议架构
[Source: architecture/api-specification.md]

#### 协议分层结构
```
┌─────────────────────────────────────┐
│         Application Layer           │
├─────────────────────────────────────┤
│         Protocol Layer              │
│  ┌─────────────┬─────────────────┐  │
│  │ Discovery   │   Pairing       │  │
│  │ Protocol    │   Protocol      │  │
│  └─────────────┴─────────────────┘  │
│  ┌─────────────┬─────────────────┐  │
│  │ Sync        │   Error         │  │
│  │ Protocol    │   Handling      │  │
│  └─────────────┴─────────────────┘  │
├─────────────────────────────────────┤
│         Transport Layer             │
│         (BLE Implementation)        │
└─────────────────────────────────────┘
```

#### 消息格式设计
所有消息都使用 Protocol Buffers 序列化，包含通用头部：

```protobuf
message NearclipMessage {
  uint32 version = 1;           // 协议版本
  MessageType type = 2;         // 消息类型
  uint64 timestamp = 3;         // 时间戳
  string device_id = 4;         // 发送设备ID
  string session_id = 5;        // 会话ID
  bytes payload = 6;            // 消息载荷
  bytes signature = 7;          // 消息签名
}
```

### 设备发现协议设计

#### discovery.proto
```protobuf
syntax = "proto3";

package nearclip.discovery;

// 设备能力枚举
enum DeviceCapability {
  CAPABILITY_UNKNOWN = 0;
  CAPABILITY_CLIPBOARD_READ = 1;
  CAPABILITY_CLIPBOARD_WRITE = 2;
  CAPABILITY_FILE_TRANSFER = 3;
  CAPABILITY_ENCRYPTION = 4;
}

// 设备类型枚举
enum DeviceType {
  DEVICE_TYPE_UNKNOWN = 0;
  DEVICE_TYPE_ANDROID = 1;
  DEVICE_TYPE_MAC = 2;
  DEVICE_TYPE_WINDOWS = 3;
  DEVICE_TYPE_IOS = 4;
}

// 设备广播消息
message DeviceBroadcast {
  string device_id = 1;
  string device_name = 2;
  DeviceType device_type = 3;
  repeated DeviceCapability capabilities = 4;
  string version = 5;           // 协议版本
  uint64 timestamp = 6;
  bytes public_key = 7;         // 用于配对的公钥
  map<string, string> metadata = 8; // 扩展元数据
}

// 设备扫描请求
message ScanRequest {
  uint32 timeout_seconds = 1;
  repeated DeviceType filter_types = 2;
  repeated DeviceCapability required_capabilities = 3;
}

// 设备扫描响应
message ScanResponse {
  repeated DeviceBroadcast devices = 1;
  uint64 scan_duration_ms = 2;
}

// 设备查询消息
message DeviceQuery {
  string device_id = 1;
  repeated DeviceCapability capabilities = 2;
}

// 设备查询响应
message DeviceQueryResponse {
  DeviceBroadcast device = 1;
  bool is_online = 2;
  uint64 last_seen = 3;
}
```

### 配对和安全协议设计

#### pairing.proto
```protobuf
syntax = "proto3";

package nearclip.pairing;

// 配对请求
message PairingRequest {
  string initiator_id = 1;
  string target_id = 2;
  bytes public_key = 3;
  string device_name = 4;
  bytes nonce = 5;             // 随机数，防止重放攻击
  uint64 timestamp = 6;
}

// 配对响应
message PairingResponse {
  string responder_id = 1;
  string initiator_id = 2;
  bytes public_key = 3;
  bytes signed_nonce = 4;      // 签名的随机数
  bytes shared_secret = 5;     // ECDH 共享密钥
  uint64 timestamp = 6;
}

// 配对确认
message PairingConfirmation {
  string session_id = 1;
  bytes confirmation_hash = 2; // 确认哈希
  uint64 timestamp = 3;
}

// 配对状态枚举
enum PairingStatus {
  PAIRING_UNKNOWN = 0;
  PAIRING_INITIATED = 1;
  PAIRING_PENDING = 2;
  PAIRING_CONFIRMED = 3;
  PAIRING_FAILED = 4;
  PAIRING_COMPLETED = 5;
}

// 配对状态更新
message PairingStatusUpdate {
  string session_id = 1;
  PairingStatus status = 2;
  string error_message = 3;
  uint64 timestamp = 4;
}

// 解除配对请求
message UnpairingRequest {
  string device_id = 1;
  string reason = 2;
  bytes signature = 3;
}
```

### 数据同步协议设计

#### sync.proto
```protobuf
syntax = "proto3";

package nearclip.sync;

// 数据类型枚举
enum DataType {
  DATA_TYPE_UNKNOWN = 0;
  DATA_TYPE_TEXT = 1;
  DATA_TYPE_IMAGE = 2;
  DATA_TYPE_FILE = 3;
  DATA_TYPE_URL = 4;
  DATA_TYPE_RICH_TEXT = 5;
}

// 同步操作枚举
enum SyncOperation {
  SYNC_UNKNOWN = 0;
  SYNC_CREATE = 1;
  SYNC_UPDATE = 2;
  SYNC_DELETE = 3;
  SYNC_REPLACE = 4;
}

// 剪贴板数据项
message ClipboardData {
  string data_id = 1;
  DataType type = 2;
  bytes content = 3;
  map<string, string> metadata = 4;
  uint64 created_at = 5;
  uint64 expires_at = 6;
  string source_app = 7;
}

// 数据分片信息
message DataChunk {
  string data_id = 1;
  uint32 chunk_index = 2;
  uint32 total_chunks = 3;
  bytes chunk_data = 4;
  bytes checksum = 5;
}

// 同步消息
message SyncMessage {
  string device_id = 1;
  SyncOperation operation = 2;
  ClipboardData data = 3;
  repeated DataChunk chunks = 4;
  uint64 timestamp = 5;
  bytes signature = 6;
}

// 同步确认
message SyncAck {
  string data_id = 1;
  bool success = 2;
  string error_message = 3;
  uint64 timestamp = 4;
}

// 同步状态查询
message SyncStatusQuery {
  string device_id = 1;
  uint64 since_timestamp = 2;
}

// 同步状态响应
message SyncStatusResponse {
  repeated string pending_data_ids = 1;
  repeated string completed_data_ids = 2;
  uint64 last_sync_timestamp = 3;
}
```

### 通用定义

#### common.proto
```protobuf
syntax = "proto3";

package nearclip.common;

// 错误码枚举
enum ErrorCode {
  ERROR_NONE = 0;
  ERROR_INVALID_MESSAGE = 1;
  ERROR_INVALID_SIGNATURE = 2;
  ERROR_EXPIRED_MESSAGE = 3;
  ERROR_UNSUPPORTED_VERSION = 4;
  ERROR_DEVICE_NOT_FOUND = 5;
  ERROR_PAIRING_FAILED = 6;
  ERROR_ENCRYPTION_FAILED = 7;
  ERROR_NETWORK_ERROR = 8;
  ERROR_TIMEOUT = 9;
  ERROR_QUOTA_EXCEEDED = 10;
  ERROR_INTERNAL_ERROR = 11;
}

// 标准错误消息
message ErrorMessage {
  ErrorCode code = 1;
  string message = 2;
  string details = 3;
  uint64 timestamp = 4;
}

// 心跳消息
message Heartbeat {
  string device_id = 1;
  uint64 timestamp = 2;
  uint32 sequence_number = 3;
}

// 心跳响应
message HeartbeatAck {
  string device_id = 1;
  uint64 received_timestamp = 2;
  uint32 sequence_number = 3;
}

// 协议版本信息
message ProtocolVersion {
  uint32 major = 1;
  uint32 minor = 2;
  uint32 patch = 3;
  string build_info = 4;
}

// 能力协商请求
message CapabilityNegotiation {
  ProtocolVersion min_version = 1;
  ProtocolVersion max_version = 2;
  repeated string supported_features = 3;
  repeated string required_features = 4;
}

// 能力协商响应
message CapabilityNegotiationResponse {
  ProtocolVersion selected_version = 1;
  repeated string supported_features = 2;
  repeated string unsupported_features = 3;
  bool compatibility = 4;
}
```

### Rust 实现示例

#### 协议处理器
```rust
// src/shared/rust/src/protocol/mod.rs
pub mod discovery;
pub mod pairing;
pub mod sync;
pub mod common;

use prost::Message;
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ProtocolError {
    #[error("Invalid message format: {0}")]
    InvalidFormat(String),
    #[error("Unsupported protocol version: {0}")]
    UnsupportedVersion(String),
    #[error("Message signature verification failed")]
    SignatureVerificationFailed,
    #[error("Encryption/decryption error: {0}")]
    CryptographicError(String),
    #[error("Network error: {0}")]
    NetworkError(String),
}

pub trait ProtocolHandler {
    fn handle_message(&self, message: &[u8]) -> Result<Vec<u8>, ProtocolError>;
    fn validate_message(&self, message: &[u8]) -> Result<(), ProtocolError>;
}

// 设备发现处理器
pub struct DiscoveryHandler {
    // 实现细节
}

impl DiscoveryHandler {
    pub fn new() -> Self {
        Self {}
    }

    pub fn handle_broadcast(&self, broadcast: &DeviceBroadcast) -> Result<(), ProtocolError> {
        // 处理设备广播
        Ok(())
    }

    pub fn create_scan_request(&self, timeout: u32) -> Result<ScanRequest, ProtocolError> {
        Ok(ScanRequest {
            timeout_seconds: timeout,
            filter_types: vec![],
            required_capabilities: vec![],
        })
    }
}

// 配对处理器
pub struct PairingHandler {
    // 加密相关状态
}

impl PairingHandler {
    pub fn new() -> Self {
        Self {}
    }

    pub fn initiate_pairing(&self, target_id: &str) -> Result<PairingRequest, ProtocolError> {
        // 发起配对
        Ok(PairingRequest {
            initiator_id: "local-device-id".to_string(),
            target_id: target_id.to_string(),
            public_key: vec![], // 实际的公钥
            device_name: "My Device".to_string(),
            nonce: vec![],      // 随机数
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
        })
    }

    pub fn handle_pairing_response(&self, response: PairingResponse) -> Result<(), ProtocolError> {
        // 处理配对响应
        Ok(())
    }
}

// 同步处理器
pub struct SyncHandler {
    // 同步状态管理
}

impl SyncHandler {
    pub fn new() -> Self {
        Self {}
    }

    pub fn create_sync_message(&self, data: ClipboardData) -> Result<SyncMessage, ProtocolError> {
        Ok(SyncMessage {
            device_id: "local-device-id".to_string(),
            operation: SyncOperation::SyncCreate,
            data: Some(data),
            chunks: vec![],
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            signature: vec![],
        })
    }

    pub fn handle_sync_message(&self, message: SyncMessage) -> Result<SyncAck, ProtocolError> {
        // 处理同步消息
        Ok(SyncAck {
            data_id: message.data.as_ref().map(|d| d.data_id.clone()).unwrap_or_default(),
            success: true,
            error_message: String::new(),
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
        })
    }
}
```

### 消息验证和安全

#### 消息签名验证
```rust
use ring::signature::{self, Ed25519, UnparsedPublicKey};

pub struct MessageValidator {
    public_key: Ed25519::PublicKey,
}

impl MessageValidator {
    pub fn new(public_key: &[u8]) -> Result<Self, ProtocolError> {
        let public_key = UnparsedPublicKey::new(&signature::ED25519, public_key)
            .verify_format()
            .map_err(|e| ProtocolError::CryptographicError(e.to_string()))?;

        Ok(Self { public_key })
    }

    pub fn verify_message<T: Message>(&self, message: &T, signature: &[u8]) -> Result<(), ProtocolError> {
        let message_bytes = message.encode_to_vec();

        self.public_key
            .verify(&message_bytes, signature)
            .map_err(|_| ProtocolError::SignatureVerificationFailed)
    }

    pub fn sign_message<T: Message>(&self, message: &T, private_key: &Ed25519::KeyPair) -> Vec<u8> {
        let message_bytes = message.encode_to_vec();
        private_key.sign(&message_bytes).as_ref().to_vec()
    }
}
```

### 错误处理和重试机制

#### 错误处理策略
```rust
use std::time::Duration;
use tokio::time::sleep;

pub struct RetryHandler {
    max_retries: u32,
    base_delay: Duration,
    max_delay: Duration,
    backoff_multiplier: f64,
}

impl RetryHandler {
    pub fn new() -> Self {
        Self {
            max_retries: 3,
            base_delay: Duration::from_millis(100),
            max_delay: Duration::from_secs(10),
            backoff_multiplier: 2.0,
        }
    }

    pub async fn execute_with_retry<F, T, E>(&self, operation: F) -> Result<T, E>
    where
        F: Fn() -> Result<T, E>,
        E: std::fmt::Debug,
    {
        let mut delay = self.base_delay;

        for attempt in 0..=self.max_retries {
            match operation() {
                Ok(result) => return Ok(result),
                Err(e) => {
                    if attempt == self.max_retries {
                        log::error!("Operation failed after {} attempts: {:?}", attempt + 1, e);
                        return Err(e);
                    }

                    log::warn!("Operation failed (attempt {}): {:?}, retrying after {:?}",
                              attempt + 1, e, delay);
                    sleep(delay).await;
                    delay = std::cmp::min(
                        Duration::from_millis((delay.as_millis() as f64 * self.backoff_multiplier) as u64),
                        self.max_delay
                    );
                }
            }
        }

        unreachable!()
    }
}
```

### 版本兼容性管理

#### 协议版本协商
```rust
pub struct VersionManager {
    current_version: ProtocolVersion,
    supported_versions: Vec<ProtocolVersion>,
}

impl VersionManager {
    pub fn new() -> Self {
        Self {
            current_version: ProtocolVersion {
                major: 1,
                minor: 0,
                patch: 0,
                build_info: "release".to_string(),
            },
            supported_versions: vec![
                ProtocolVersion { major: 1, minor: 0, patch: 0, build_info: "release".to_string() },
                ProtocolVersion { major: 1, minor: 0, patch: 1, build_info: "beta".to_string() },
            ],
        }
    }

    pub fn negotiate_version(&self, negotiation: &CapabilityNegotiation) -> Result<ProtocolVersion, ProtocolError> {
        // 找到兼容的最高版本
        for supported_version in &self.supported_versions {
            if self.is_version_compatible(supported_version, &negotiation.max_version) {
                return Ok(supported_version.clone());
            }
        }

        Err(ProtocolError::UnsupportedVersion("No compatible version found".to_string()))
    }

    fn is_version_compatible(&self, version: &ProtocolVersion, max_version: &ProtocolVersion) -> bool {
        // 主版本必须相同
        if version.major != max_version.major {
            return false;
        }

        // 次版本不能超过最大支持版本
        if version.minor > max_version.minor {
            return false;
        }

        true
    }
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | 初始故事创建，添加通信协议设计 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写