# 故事 4.5: 无障碍访问与包容性设计

## 基本信息
- **故事编号**: 4.5
- **Epic**: Epic 4 - 用户体验与界面优化
- **故事名称**: 无障碍访问与包容性设计
- **优先级**: 高
- **预计工期**: 4 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 应用具有良好的无障碍访问支持和包容性设计，
**以便** 无论我是否有视觉、听觉、运动或认知障碍，都能够顺利使用应用的所有功能。

## 验收标准

### AC 1: 视觉无障碍支持
- **屏幕阅读器**: 完整支持TalkBack和VoiceOver屏幕阅读器
- **内容标注**: 所有UI元素都有准确的语义标注和描述
- **焦点管理**: 逻辑清晰的焦点导航顺序和可见的焦点指示
- **对比度**: 确保文本和背景颜色对比度符合WCAG 2.1 AA标准
- **字体缩放**: 支持系统字体大小设置，保持布局完整性

### AC 2: 听觉无障碍支持
- **视觉替代**: 为音频提示提供视觉替代方案
- **振动反馈**: 为关键操作提供触觉反馈
- **字幕支持**: 为视频内容提供字幕选项
- **音量控制**: 独立的音量控制和静音选项
- **频率警告**: 避免可能引发癫痫的闪烁频率

### AC 3: 运动无障碍支持
- **大触摸目标**: 所有可交互元素满足最小触摸目标要求
- **键盘导航**: 完整的键盘导航支持
- **语音控制**: 支持语音控制命令
- **手势替代**: 为复杂手势提供简单的替代方案
- **时间控制**: 为有时间限制的操作提供足够的时间或延长选项

### AC 4: 认知无障碍支持
- **清晰语言**: 使用简洁明了的语言和表达
- **错误处理**: 友好的错误提示和恢复指导
- **操作确认**: 为重要操作提供确认机制
- **进度指示**: 清晰的进度状态和完成指示
- **帮助系统**: 集成的帮助内容和操作指导

### AC 5: 包容性设计原则
- **文化包容**: 支持多种语言和文化习惯
- **年龄包容**: 适合不同年龄段用户使用
- **技能包容**: 适合不同技术熟练度用户
- **环境适应**: 适应不同使用环境和光线条件
- **个性化设置**: 丰富的个性化选项和偏好设置

## 技术实现要点

### 1. 无障碍配置和令牌系统
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/accessibility/AccessibilityTokens.kt
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.unit.dp

// 无障碍设计规范
data class AccessibilityTokens(
    // 触摸目标最小尺寸
    val minTouchTargetSize: Dp = 48.dp,
    val minTouchTargetSizeLarge: Dp = 56.dp,

    // 焦点指示器
    val focusIndicatorWidth: Dp = 2.dp,
    val focusIndicatorColor: androidx.compose.ui.graphics.Color = androidx.compose.ui.graphics.Color(0xFF4285F4),

    // 间距规范
    val spacingLarge: Dp = 24.dp,
    val spacingExtraLarge: Dp = 32.dp,

    // 字体缩放支持
    val minFontScale: Float = 0.8f,
    val maxFontScale: Float = 2.0f,

    // 对比度要求
    val minContrastRatio: Float = 4.5f, // WCAG AA标准
    val minContrastRatioLarge: Float = 3.0f, // 大文本的WCAG AA标准

    // 动画设置
    val reducedMotion: Boolean = false,
    val animationDurationScale: Float = 1.0f,

    // 音频反馈
    val enableSoundFeedback: Boolean = true,
    val enableHapticFeedback: Boolean = true
)

// Composition Local for accessibility tokens
val LocalAccessibilityTokens = staticCompositionLocalOf {
    AccessibilityTokens()
}

// 无障碍配置管理器
class AccessibilityConfigManager(
    private val context: Context
) {
    fun isScreenReaderEnabled(): Boolean {
        return Settings.Secure.getInt(
            context.contentResolver,
            Settings.Secure.ACCESSIBILITY_ENABLED,
            0
        ) == 1
    }

    fun isTalkBackEnabled(): Boolean {
        val enabledServices = Settings.Secure.getString(
            context.contentResolver,
            Settings.Secure.ENABLED_ACCESSIBILITY_SERVICES
        )
        return enabledServices?.contains("talkback") == true
    }

    fun isHighContrastEnabled(): Boolean {
        return Settings.System.getInt(
            context.contentResolver,
            Settings.System.HIGH_CONTRAST_ON,
            0
        ) == 1
    }

    fun getFontScale(): Float {
        return Configuration(context.resources.configuration).fontScale
    }

    fun isReducedMotionEnabled(): Boolean {
        return Settings.Global.getFloat(
            context.contentResolver,
            Settings.Global.ANIMATOR_DURATION_SCALE,
            1.0f
        ) == 0.0f
    }

    fun isColorBlindModeEnabled(): Boolean {
        // 检测是否启用了色盲友好模式
        return false // 需要根据实际需求实现
    }
}
```

### 2. 无障碍组件库
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/accessibility/AccessibleComponents.kt
import androidx.compose.foundation.*
import androidx.compose.foundation.interaction.*
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.alpha
import androidx.compose.ui.draw.drawBehind
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalAccessibilityManager
import androidx.compose.ui.semantics.*
import androidx.compose.ui.unit.dp

// 无障碍按钮
@Composable
fun AccessibleButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    variant: NearClipButtonVariant = NearClipButtonVariant.Primary,
    accessibilityDescription: String? = null,
    accessibilityRole: AccessibilityRole? = null
) {
    val accessibilityManager = LocalAccessibilityManager.current
    val isScreenReaderEnabled = accessibilityManager?.isEnabled == true

    NearClipButton(
        text = text,
        onClick = onClick,
        modifier = modifier
            .defaultMinSize(
                minWidth = LocalAccessibilityTokens.current.minTouchTargetSize,
                minHeight = LocalAccessibilityTokens.current.minTouchTargetSize
            )
            .semantics {
                this.contentDescription = accessibilityDescription ?: text
                this.role = accessibilityRole ?: Role.Button
                this.stateDescription = if (enabled) "可用" else "不可用"
                if (!enabled) {
                    this.disabled()
                }
            },
        enabled = enabled,
        variant = variant
    )
}

// 无障碍输入框
@Composable
fun AccessibleTextField(
    value: String,
    onValueChange: (String) -> Unit,
    modifier: Modifier = Modifier,
    label: String,
    placeholder: String = "",
    isError: Boolean = false,
    supportingText: String? = null,
    accessibilityDescription: String? = null,
    onImeActionPerformed: (ImeAction) -> Unit = {}
) {
    val focusRequester = remember { FocusRequester() }
    val accessibilityTokens = LocalAccessibilityTokens.current

    OutlinedTextField(
        value = value,
        onValueChange = onValueChange,
        modifier = modifier
            .defaultMinSize(
                minHeight = accessibilityTokens.minTouchTargetSize
            )
            .focusRequester(focusRequester)
            .semantics {
                this.contentDescription = accessibilityDescription ?: "输入$label"
                this.role = Role.TextField
                this.editingText = AnnotatedString(value)
                if (isError) {
                    this.error()
                }
            },
        label = { Text(label) },
        placeholder = { Text(placeholder) },
        isError = isError,
        supportingText = supportingText?.let { { Text(it) } },
        onImeAction = onImeActionPerformed
    )
}

// 无障碍卡片
@Composable
fun AccessibleCard(
    title: String,
    description: String,
    modifier: Modifier = Modifier,
    onClick: (() -> Unit)? = null,
    accessibilityDescription: String? = null,
    leadingIcon: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null
) {
    val accessibilityTokens = LocalAccessibilityTokens.current

    NearClipCard(
        modifier = modifier
            .defaultMinSize(
                minHeight = accessibilityTokens.minTouchTargetSize
            )
            .semantics {
                this.contentDescription = accessibilityDescription ?: "$title, $description"
                this.role = Role.Button
                onClick?.let {
                    this.onClick(it)
                }
            },
        onClick = onClick
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            leadingIcon?.invoke()
            if (leadingIcon != null) {
                Spacer(modifier = Modifier.width(16.dp))
            }

            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                Spacer(modifier = Modifier.height(4.dp))
                Text(
                    text = description,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            trailingIcon?.invoke()
            if (trailingIcon != null) {
                Spacer(modifier = Modifier.width(16.dp))
            }
        }
    }
}

// 无障碍开关
@Composable
fun AccessibleSwitch(
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    label: String,
    accessibilityDescription: String? = null
) {
    val accessibilityTokens = LocalAccessibilityTokens.current

    Row(
        modifier = modifier
            .defaultMinSize(
                minHeight = accessibilityTokens.minTouchTargetSize
            )
            .semantics {
                this.contentDescription = accessibilityDescription ?: "$label, ${if (checked) "已开启" else "已关闭"}"
                this.role = Role.Switch
                this.stateDescription = if (checked) "开启" else "关闭"
                if (!enabled) {
                    this.disabled()
                }
                this.toggleableState = ToggleableState(checked)
            }
            .toggleable(
                value = checked,
                onValueChange = onCheckedChange,
                enabled = enabled
            ),
        verticalAlignment = Alignment.CenterVertically
    ) {
        Column(
            modifier = Modifier.weight(1f)
        ) {
            Text(
                text = label,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface
            )
        }

        Spacer(modifier = Modifier.width(16.dp))

        AnimatedSwitch(
            checked = checked,
            onCheckedChange = onCheckedChange,
            enabled = enabled
        )
    }
}

// 无障碍列表项
@Composable
fun <T> AccessibleListItem(
    item: T,
    modifier: Modifier = Modifier,
    onClick: (T) -> Unit,
    title: (T) -> String,
    description: (T) -> String? = { null },
    leadingIcon: (@Composable (T) -> Unit)? = null,
    trailingIcon: (@Composable (T) -> Unit)? = null,
    accessibilityDescription: (T) -> String? = { null }
) {
    val accessibilityTokens = LocalAccessibilityTokens.current

    NearClipCard(
        modifier = modifier
            .defaultMinSize(
                minHeight = accessibilityTokens.minTouchTargetSize
            )
            .semantics {
                val itemTitle = title(item)
                val itemDescription = description(item)
                val itemAccessibilityDescription = accessibilityDescription(item)

                this.contentDescription = itemAccessibilityDescription ?:
                    buildString {
                        append(itemTitle)
                        itemDescription?.let { append(", $it") }
                    }
                this.role = Role.Button
                this.onClick { onClick(item) }
            },
        onClick = { onClick(item) }
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            leadingIcon?.let { icon ->
                icon(item)
                Spacer(modifier = Modifier.width(16.dp))
            }

            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = title(item),
                    style = MaterialTheme.typography.titleMedium,
                    color = MaterialTheme.colorScheme.onSurface
                )
                description(item)?.let { desc ->
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = desc,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            trailingIcon?.let { icon ->
                Spacer(modifier = Modifier.width(16.dp))
                icon(item)
            }
        }
    }
}
```

### 3. 高对比度主题
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/accessibility/HighContrastTheme.kt
import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material3.ColorScheme
import androidx.compose.material3.darkColorScheme
import androidx.compose.material3.lightColorScheme
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color

// 高对比度配色方案
object HighContrastColors {

    // 浅色高对比度主题
    val LightHighContrastColorScheme = lightColorScheme(
        primary = Color(0xFF000000),           // 纯黑
        onPrimary = Color(0xFFFFFFFF),         // 纯白
        primaryContainer = Color(0xFF000000),  // 纯黑
        onPrimaryContainer = Color(0xFFFFFFFF),// 纯白

        secondary = Color(0xFF666666),         // 深灰
        onSecondary = Color(0xFFFFFFFF),        // 纯白
        secondaryContainer = Color(0xFFCCCCCC), // 浅灰
        onSecondaryContainer = Color(0xFF000000), // 纯黑

        tertiary = Color(0xFF0000FF),          // 纯蓝
        onTertiary = Color(0xFFFFFFFF),        // 纯白
        tertiaryContainer = Color(0xFF0000FF), // 纯蓝
        onTertiaryContainer = Color(0xFFFFFFFF),// 纯白

        background = Color(0xFFFFFFFF),        // 纯白背景
        onBackground = Color(0xFF000000),      // 纯黑文字

        surface = Color(0xFFFFFFFF),           // 纯白表面
        onSurface = Color(0xFF000000),         // 纯黑文字
        surfaceVariant = Color(0xFFEEEEEE),    // 浅灰表面变体
        onSurfaceVariant = Color(0xFF000000),  // 纯黑文字

        outline = Color(0xFF000000),           // 纯黑边框
        outlineVariant = Color(0xFF000000),    // 纯黑边框变体

        error = Color(0xFFFF0000),             // 纯红
        onError = Color(0xFFFFFFFF),           // 纯白
        errorContainer = Color(0xFFFF0000),    // 纯红容器
        onErrorContainer = Color(0xFFFFFFFF),  // 纯白文字

        scrim = Color(0xFF000000),             // 纯黑遮罩
    )

    // 深色高对比度主题
    val DarkHighContrastColorScheme = darkColorScheme(
        primary = Color(0xFFFFFFFF),           // 纯白
        onPrimary = Color(0xFF000000),         // 纯黑
        primaryContainer = Color(0xFFFFFFFF),  // 纯白
        onPrimaryContainer = Color(0xFF000000),// 纯黑

        secondary = Color(0xFFCCCCCC),         // 浅灰
        onSecondary = Color(0xFF000000),        // 纯黑
        secondaryContainer = Color(0xFF333333), // 深灰
        onSecondaryContainer = Color(0xFFFFFFFF),// 纯白

        tertiary = Color(0xFFFFFF00),          // 纯黄
        onTertiary = Color(0xFF000000),        // 纯黑
        tertiaryContainer = Color(0xFFFFFF00), // 纯黄
        onTertiaryContainer = Color(0xFF000000),// 纯黑

        background = Color(0xFF000000),        // 纯黑背景
        onBackground = Color(0xFFFFFFFF),      // 纯白文字

        surface = Color(0xFF000000),           // 纯黑表面
        onSurface = Color(0xFFFFFFFF),         // 纯白文字
        surfaceVariant = Color(0xFF333333),    // 深灰表面变体
        onSurfaceVariant = Color(0xFFFFFFFF),  // 纯白文字

        outline = Color(0xFFFFFFFF),           // 纯白边框
        outlineVariant = Color(0xFFFFFFFF),    // 纯白边框变体

        error = Color(0xFFFF0000),             // 纯红
        onError = Color(0xFF000000),           // 纯黑
        errorContainer = Color(0xFFFF0000),    // 纯红容器
        onErrorContainer = Color(0xFF000000),  // 纯黑文字

        scrim = Color(0xFF000000),             // 纯黑遮罩
    )
}

// 高对比度主题提供者
@Composable
fun HighContrastTheme(
    isDarkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colorScheme = if (isDarkTheme) {
        HighContrastColors.DarkHighContrastColorScheme
    } else {
        HighContrastColors.LightHighContrastColorScheme
    }

    MaterialTheme(
        colorScheme = colorScheme,
        typography = MaterialTheme.typography,
        content = content
    )
}

// 色盲友好配色方案
object ColorBlindFriendlyColors {

    // 红绿色盲友好配色
    val RedGreenColorBlindColorScheme = lightColorScheme(
        primary = Color(0xFF1565C0),           // 蓝色替代红色
        onPrimary = Color(0xFFFFFFFF),
        primaryContainer = Color(0xFF1976D2),
        onPrimaryContainer = Color(0xFFFFFFFF),

        secondary = Color(0xFFFF6F00),         // 橙色替代绿色
        onSecondary = Color(0xFFFFFFFF),
        secondaryContainer = Color(0xFFFF8F00),
        onSecondaryContainer = Color(0xFF000000),

        tertiary = Color(0xFF7B1FA2),          // 紫色
        onTertiary = Color(0xFFFFFFFF),
        tertiaryContainer = Color(0xFF9C27B0),
        onTertiaryContainer = Color(0xFFFFFFFF),

        background = Color(0xFFFFFFFF),
        onBackground = Color(0xFF212121),

        surface = Color(0xFFFAFAFA),
        onSurface = Color(0xFF212121),
        surfaceVariant = Color(0xFFF5F5F5),
        onSurfaceVariant = Color(0xFF757575),

        outline = Color(0xFFBDBDBD),
        outlineVariant = Color(0xFFE0E0E0),

        error = Color(0xFFD32F2F),
        onError = Color(0xFFFFFFFF),
        errorContainer = Color(0xFFFFEBEE),
        onErrorContainer = Color(0xFFB71C1C),

        scrim = Color(0xFF000000),
    )
}
```

### 4. 键盘导航支持
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/accessibility/KeyboardNavigation.kt
import androidx.compose.foundation.focusable
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.itemsIndexed
import androidx.compose.foundation.lazy.rememberLazyListState
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.ExperimentalComposeUiApi
import androidx.compose.ui.Modifier
import androidx.compose.ui.focus.FocusRequester
import androidx.compose.ui.focus.focusRequester
import androidx.compose.ui.input.key.*
import androidx.compose.ui.platform.LocalSoftwareKeyboardController
import androidx.compose.ui.semantics.*
import androidx.compose.ui.unit.dp

// 键盘导航管理器
class KeyboardNavigationManager {
    private val focusRequesters = mutableMapOf<String, FocusRequester>()
    private val navigationOrder = mutableListOf<String>()
    private var currentIndex = -1

    fun registerElement(id: String): FocusRequester {
        val focusRequester = FocusRequester()
        focusRequesters[id] = focusRequester
        if (!navigationOrder.contains(id)) {
            navigationOrder.add(id)
        }
        return focusRequester
    }

    fun requestFocus(id: String): Boolean {
        val focusRequester = focusRequesters[id] ?: return false
        currentIndex = navigationOrder.indexOf(id)
        return focusRequester.requestFocus()
    }

    fun moveFocus(direction: NavigationDirection): Boolean {
        val newIndex = when (direction) {
            NavigationDirection.UP -> currentIndex - 1
            NavigationDirection.DOWN -> currentIndex + 1
            NavigationDirection.LEFT -> currentIndex - 1
            NavigationDirection.RIGHT -> currentIndex + 1
        }

        if (newIndex >= 0 && newIndex < navigationOrder.size) {
            currentIndex = newIndex
            val nextId = navigationOrder[currentIndex]
            return requestFocus(nextId)
        }
        return false
    }

    fun getCurrentFocusedId(): String? {
        return if (currentIndex >= 0 && currentIndex < navigationOrder.size) {
            navigationOrder[currentIndex]
        } else {
            null
        }
    }
}

enum class NavigationDirection {
    UP, DOWN, LEFT, RIGHT
}

// 键盘导航支持的可组合函数
@OptIn(ExperimentalComposeUiApi::class)
@Composable
fun KeyboardNavigableLazyColumn(
    items: List<String>,
    modifier: Modifier = Modifier,
    navigationManager: KeyboardNavigationManager = remember { KeyboardNavigationManager() },
    onItemClick: (String) -> Unit,
    itemContent: @Composable (String, Boolean) -> Unit
) {
    val listState = rememberLazyListState()
    val keyboardController = LocalSoftwareKeyboardController.current

    LazyColumn(
        state = listState,
        modifier = modifier
            .onKeyEvent { keyEvent ->
                when (keyEvent.key) {
                    Key.DirectionUp -> {
                        navigationManager.moveFocus(NavigationDirection.UP)
                        true
                    }
                    Key.DirectionDown -> {
                        navigationManager.moveFocus(NavigationDirection.DOWN)
                        true
                    }
                    Key.Enter, Key.Center -> {
                        navigationManager.getCurrentFocusedId()?.let { currentId ->
                            onItemClick(currentId)
                        }
                        true
                    }
                    Key.Back -> {
                        keyboardController?.hide()
                        true
                    }
                    else -> false
                }
            }
            .semantics {
                this.verticalScrollingState = listState
                this.contentDescription = "可导航列表，包含${items.size}个项目"
            }
    ) {
        itemsIndexed(items) { index, item ->
            val focusRequester = remember { navigationManager.registerElement(item) }
            val isFocused by remember { derivedStateOf {
                navigationManager.getCurrentFocusedId() == item
            } }

            key(item) {
                itemContent(item, isFocused)
                    .focusRequester(focusRequester)
                    .focusable()
                    .semantics {
                        this.focused = isFocused
                        this.indexInList = index
                        this.listItem = true
                    }
                    .onKeyEvent { keyEvent ->
                        when (keyEvent.key) {
                            Key.DirectionUp -> {
                                navigationManager.moveFocus(NavigationDirection.UP)
                                true
                            }
                            Key.DirectionDown -> {
                                navigationManager.moveFocus(NavigationDirection.DOWN)
                                true
                            }
                            else -> false
                        }
                    }
            }
        }
    }
}

// 键盘导航支持的应用栏
@Composable
fun KeyboardNavigableTopAppBar(
    title: String,
    navigationIcon: @Composable () -> Unit = {},
    actions: @Composable RowScope.() -> Unit = {},
    navigationManager: KeyboardNavigationManager = remember { KeyboardNavigationManager() }
) {
    TopAppBar(
        title = {
            Text(
                text = title,
                modifier = Modifier.semantics {
                    this.heading()
                }
            )
        },
        navigationIcon = navigationIcon,
        actions = {
            Row(
                modifier = Modifier
                    .onKeyEvent { keyEvent ->
                        when (keyEvent.key) {
                            Key.DirectionRight -> {
                                // 移动到第一个操作按钮
                                true
                            }
                            else -> false
                        }
                    }
            ) {
                actions()
            }
        }
    )
}
```

### 5. SwiftUI macOS 无障碍实现
```swift
// src/platform/mac/NearClip/Accessibility/AccessibilityComponents.swift
import SwiftUI
import Accessibility

// 无障碍按钮视图
struct AccessibleButton: View {
    let title: String
    let action: () -> Void
    var accessibilityHint: String? = nil
    var accessibilityLabel: String? = nil

    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.nearclipLabelLarge)
                .fontWeight(.medium)
                .foregroundColor(.white)
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.nearclipPrimary)
                        .accessibilityElement(children: .ignore)
                )
        }
        .buttonStyle(PlainButtonStyle())
        .accessibilityLabel(accessibilityLabel ?? title)
        .accessibilityHint(accessibilityHint ?? "双击执行操作")
        .accessibilityAddTraits(.isButton)
        .frame(minWidth: 44, minHeight: 44) // 最小触摸目标
    }
}

// 无障碍输入框视图
struct AccessibleTextField: View {
    let title: String
    @Binding var text: String
    var placeholder: String = ""
    var accessibilityLabel: String? = nil
    var accessibilityHint: String? = nil

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text(title)
                .font(.nearclipLabelMedium)
                .foregroundColor(.primary)

            TextField(placeholder, text: $text)
                .textFieldStyle(RoundedBorderTextFieldStyle())
                .frame(minHeight: 44)
                .accessibilityLabel(accessibilityLabel ?? title)
                .accessibilityHint(accessibilityHint ?? "请输入\(title)")
                .accessibilityAddTraits(.isSearchField)
        }
    }
}

// 无障碍开关视图
struct AccessibleToggle: View {
    let title: String
    @Binding var isOn: Bool
    var accessibilityLabel: String? = nil
    var accessibilityHint: String? = nil

    var body: some View {
        HStack {
            Text(title)
                .font(.nearclipBodyLarge)
                .foregroundColor(.primary)

            Spacer()

            Toggle("", isOn: $isOn)
                .accessibilityLabel(accessibilityLabel ?? title)
                .accessibilityHint(accessibilityHint ?? "双击切换\(title)状态")
                .accessibilityValue(isOn ? "已开启" : "已关闭")
                .frame(width: 44, height: 24) // 确保足够的触摸区域
        }
        .padding(.vertical, 8)
        .frame(minHeight: 44)
    }
}

// 无障碍列表项视图
struct AccessibleListItem<Data: Identifiable>: View {
    let item: Data
    let title: (Data) -> String
    let subtitle: (Data) -> String?
    let action: (Data) -> Void
    var accessibilityLabel: ((Data) -> String)? = nil

    var body: some View {
        Button(action: { action(item) }) {
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text(title(item))
                        .font(.nearclipBodyLarge)
                        .foregroundColor(.primary)

                    subtitle(item)?let { subtitleText in
                        Text(subtitleText)
                            .font(.nearclipBodyMedium)
                            .foregroundColor(.secondary)
                    }
                }

                Spacer()

                Image(systemName: "chevron.right")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.secondary)
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
        }
        .buttonStyle(PlainButtonStyle())
        .accessibilityLabel(accessibilityLabel?(item) ?? title(item))
        .accessibilityHint("双击查看详情")
        .accessibilityAddTraits(.isButton)
        .frame(minHeight: 44)
    }
}

// 高对比度支持
struct HighContrastContainer<Content: View>: View {
    let content: Content

    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    @Environment(\.colorSchemeContrast) var colorSchemeContrast

    var body: some View {
        content
            .background(
                colorSchemeContrast == .increased ?
                Color.black : Color.white
            )
            .foregroundColor(
                colorSchemeContrast == .increased ?
                Color.white : Color.black
            )
            .accessibilityElement(children: .contain)
    }
}

// 动态字体大小支持
struct DynamicFontContainer<Content: View>: View {
    let content: Content

    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    @Environment(\.sizeCategory) var sizeCategory

    var body: some View {
        content
            .dynamicTypeSize(
                sizeCategory < .accessibilityExtraExtraExtraLarge ?
                .medium : .large
            )
    }
}

// 语音控制支持
struct VoiceControlSupported: ViewModifier {
    func body(content: Content) -> some View {
        content
            .accessibilityAddTraits(.isButton)
            .accessibilityHint("点击执行")
    }
}

extension View {
    func voiceControlSupported() -> some View {
        modifier(VoiceControlSupported())
    }
}
```

### 6. 辅助功能服务集成
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/accessibility/AccessibilityService.kt
import android.accessibilityservice.AccessibilityService
import android.content.Intent
import android.view.accessibility.AccessibilityEvent
import kotlinx.coroutines.*

class NearClipAccessibilityService : AccessibilityService() {

    private val serviceScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    override fun onAccessibilityEvent(event: AccessibilityEvent?) {
        event?.let {
            when (it.eventType) {
                AccessibilityEvent.TYPE_WINDOW_STATE_CHANGED -> {
                    handleWindowStateChanged(it)
                }
                AccessibilityEvent.TYPE_VIEW_FOCUSED -> {
                    handleViewFocused(it)
                }
                AccessibilityEvent.TYPE_VIEW_CLICKED -> {
                    handleViewClicked(it)
                }
            }
        }
    }

    override fun onInterrupt() {
        // 处理服务中断
    }

    override fun onServiceConnected() {
        super.onServiceConnected()
        // 配置辅助功能服务
        configureService()
    }

    private fun configureService() {
        val info = AccessibilityServiceInfo().apply {
            // 设置反馈类型
            feedbackType = AccessibilityServiceInfo.FEEDBACK_SPOKEN
            flags = AccessibilityServiceInfo.FLAG_REQUEST_TOUCH_EXPLORATION_MODE

            // 设置事件类型
            eventTypes = AccessibilityEvent.TYPES_ALL_MASK

            // 设置包名（可选）
            packageNames = arrayOf("com.nearclip")
        }

        serviceInfo = info
    }

    private fun handleWindowStateChanged(event: AccessibilityEvent) {
        // 处理窗口状态变化
        val packageName = event.packageName?.toString()
        val className = event.className?.toString()

        // 为屏幕阅读器提供适当的反馈
        provideFeedbackForScreenReader("窗口已切换到$className")
    }

    private fun handleViewFocused(event: AccessibilityEvent) {
        // 处理视图获得焦点
        val contentDescription = event.contentDescription?.toString()

        contentDescription?.let {
            provideFeedbackForScreenReader("焦点在: $it")
        }
    }

    private fun handleViewClicked(event: AccessibilityEvent) {
        // 处理视图点击
        val contentDescription = event.contentDescription?.toString()

        contentDescription?.let {
            provideFeedbackForScreenReader("已点击: $it")
        }
    }

    private fun provideFeedbackForScreenReader(message: String) {
        // 提供语音反馈
        serviceScope.launch {
            // 实现TTS反馈
        }
    }

    // 提供振动反馈
    private fun provideHapticFeedback() {
        // 实现振动反馈
    }

    // 提供音频提示
    private fun provideAudioFeedback() {
        // 实现音频反馈
    }
}
```

## 测试用例

### 无障碍测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/accessibility/AccessibilityTest.kt
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import org.junit.Rule
import org.junit.Test

class AccessibilityTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun accessibleButton_hasCorrectSemantics() {
        composeTestRule.setContent {
            AccessibleButton(
                text = "Test Button",
                onClick = {},
                accessibilityDescription = "测试按钮"
            )
        }

        composeTestRule
            .onNodeWithContentDescription("测试按钮")
            .assertIsDisplayed()
            .assertHasClickAction()
    }

    @Test
    fun textField_supportsAccessibility() {
        composeTestRule.setContent {
            AccessibleTextField(
                value = "",
                onValueChange = {},
                label = "用户名",
                accessibilityDescription = "请输入用户名"
            )
        }

        composeTestRule
            .onNodeWithContentDescription("请输入用户名")
            .assertIsDisplayed()
            .assertIsEnabled()
    }
}
```

### SwiftUI无障碍测试
```swift
// src/platform/mac/NearClip/Accessibility/Tests/AccessibilityTests.swift
import XCTest
import SwiftUI
import ViewInspector

final class AccessibilityTests: XCTestCase {

    func testAccessibleButtonSemantics() throws {
        var button = AccessibleButton(
            title: "Test Button",
            action: {}
        )

        let buttonLabel = try button.inspect().button().labelView().text().string()
        XCTAssertEqual(buttonLabel, "Test Button")

        let accessibilityLabel = try button.inspect().accessibilityValue()
        XCTAssertTrue(accessibilityLabel.contains("Test Button"))
    }

    func testHighContrastSupport() throws {
        var container = HighContrastContainer {
            Text("Test Content")
        }

        // 验证高对比度模式下的显示
        let text = try container.inspect().text().string()
        XCTAssertEqual(text, "Test Content")
    }
}
```

## 部署要求

### 开发配置
- Android: 启用无障碍测试和无障碍扫描工具
- macOS: 启用VoiceOver和其他辅助功能
- 测试设备: 包含各种辅助功能的测试设备

### 依赖项
```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.compose.ui:ui-tooling-preview:$compose_version"
    debugImplementation "androidx.compose.ui:ui-tooling:$compose_version"
    implementation "androidx.compose.material3:material3:$material3_version"
}
```

## 验收测试计划

### 无障碍功能测试
1. **屏幕阅读器测试**: 使用TalkBack和VoiceOver进行全面测试
2. **键盘导航测试**: 验证完整的键盘导航功能
3. **高对比度测试**: 测试高对比度模式的显示效果
4. **字体缩放测试**: 测试大字体模式的布局适配

### 兼容性测试
1. **辅助功能兼容**: 测试与各种辅助功能的兼容性
2. **设备兼容**: 在不同设备上验证无障碍功能
3. **系统版本兼容**: 测试不同系统版本的辅助功能支持

### 用户体验测试
1. **真实用户测试**: 邀请有障碍用户进行实际使用测试
2. **易用性评估**: 评估无障碍功能的实际使用效果
3. **满意度调查**: 收集用户对无障碍功能的满意度反馈

## 风险与缓解

### 技术风险
- **平台差异**: 不同平台的辅助功能API差异
  - 缓解: 统一抽象层，平台特定实现
- **性能影响**: 无障碍功能可能影响应用性能
  - 缓解: 性能监控，优化实现，条件加载

### 兼容性风险
- **辅助工具兼容**: 与第三方辅助工具的兼容性问题
  - 缓解: 标准实现，广泛测试，社区反馈
- **系统版本兼容**: 不同系统版本的辅助功能支持差异
  - 缓解: 版本检查，降级方案，兼容性测试

### 用户体验风险
- **功能复杂**: 无障碍功能可能增加应用复杂性
  - 缓解: 智能默认设置，用户控制，渐进式启用
- **学习成本**: 用户可能需要时间学习新的无障碍功能
  - 缓解: 详细文档，用户指南，内置教程

## 完成标准
- [ ] 所有UI元素支持屏幕阅读器
- [ ] 键盘导航功能完整可用
- [ ] 高对比度主题正常显示
- [ ] 字体缩放功能正确适配
- [ ] 触摸目标尺寸符合标准
- [ ] 语音控制和手势支持完善
- [ ] 无障碍测试覆盖率达标
- [ ] 真实用户测试通过
- [ ] 辅助功能认证获得
- [ ] 无障碍文档和指南完整