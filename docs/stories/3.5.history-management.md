# 故事 3.5: 历史记录管理

## 基本信息
- **故事编号**: 3.5
- **Epic**: Epic 3 - 跨设备粘贴板同步
- **故事名称**: 历史记录管理
- **优先级**: 中
- **预计工期**: 4 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 能够查看和管理我的粘贴板历史记录，
**以便** 我能够快速找到之前复制的内容，重新使用重要信息，并清理不需要的历史数据。

## 验收标准

### AC 1: 历史记录存储
- **自动存储**: 自动存储所有发送和接收的粘贴板内容
- **元数据记录**: 记录内容的来源设备、时间戳、内容类型和大小
- **本地缓存**: 在本地设备维护高效的历史记录缓存
- **云端同步**: 可选的云端历史记录同步功能
- **存储限制**: 支持用户配置的存储大小和时间限制

### AC 2: 历史记录查看
- **时间线视图**: 按时间顺序显示历史记录，支持分组和筛选
- **搜索功能**: 支持关键词搜索和正则表达式搜索
- **内容预览**: 提供文本、图片和文件的快速预览功能
- **分类筛选**: 按内容类型、来源设备、时间范围进行筛选
- **收藏标记**: 支持标记重要内容为收藏，便于快速访问

### AC 3: 历史记录管理
- **删除操作**: 支持单个删除、批量删除和全部清除
- **编辑功能**: 允许编辑文本类型的历史记录内容
- **重新传输**: 支持将历史记录重新发送到配对设备
- **导出功能**: 支持将历史记录导出为文件或云端备份
- **自动清理**: 根据用户设置的规则自动清理过期记录

### AC 4: 隐私与安全
- **敏感内容保护**: 自动检测和保护敏感信息
- **访问控制**: 支持密码或生物识别保护历史记录访问
- **加密存储**: 历史记录在本地加密存储
- **选择性同步**: 用户可选择同步哪些类型的内容
- **审计日志**: 记录所有历史记录访问和修改操作

### AC 5: 性能优化
- **快速加载**: 优化查询性能，支持历史记录快速加载
- **增量同步**: 支持历史记录的增量同步和更新
- **索引优化**: 为搜索和筛选功能建立高效索引
- **内存管理**: 智能管理内存使用，避免大量历史记录影响性能
- **后台处理**: 历史记录操作在后台处理，不阻塞UI

## 技术实现要点

### 1. Rust历史记录引擎
```rust
// src/shared/rust/src/history/mod.rs
pub mod storage;
pub mod manager;
pub mod search;
pub mod sync;
pub mod security;

pub use storage::HistoryStorage;
pub use manager::HistoryManager;
pub use search::HistorySearch;
pub use sync::HistorySync;
pub use security::HistorySecurity;
```

### 2. 历史记录存储
```rust
// src/shared/rust/src/history/storage.rs
pub struct HistoryStorage {
    database: SqlitePool,
    encryption_engine: EncryptionEngine,
    config: StorageConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryRecord {
    pub id: Uuid,
    pub content: EncryptedContent,
    pub metadata: HistoryMetadata,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HistoryMetadata {
    pub content_type: ContentType,
    pub source_device: DeviceId,
    pub target_device: Option<DeviceId>,
    pub direction: TransferDirection, // Sent or Received
    pub size: usize,
    pub checksum: String,
    pub is_favorite: bool,
    pub tags: Vec<String>,
    pub category: Option<String>,
}

impl HistoryStorage {
    pub async fn new(config: StorageConfig) -> Result<Self, StorageError> {
        let database = create_database_pool(&config.database_path).await?;
        let encryption_engine = EncryptionEngine::new()?;

        // 创建表结构
        migrate_database(&database).await?;

        Ok(Self {
            database,
            encryption_engine,
            config,
        })
    }

    pub async fn add_record(&self, content: ClipboardContent, metadata: HistoryMetadata) -> Result<Uuid, StorageError> {
        let record_id = Uuid::new_v4();
        let encrypted_content = self.encryption_engine.encrypt_content(&content.data)?;

        let record = HistoryRecord {
            id: record_id,
            content: encrypted_content,
            metadata,
            created_at: Utc::now(),
            updated_at: Utc::now(),
        };

        sqlx::query!(
            r#"
            INSERT INTO history_records (
                id, content_data, content_nonce, content_hmac,
                content_type, source_device, target_device, direction,
                size, checksum, is_favorite, tags, category,
                created_at, updated_at
            ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            "#,
            record.id,
            record.content.data,
            record.content.nonce,
            record.content.hmac,
            record.metadata.content_type as i32,
            record.metadata.source_device.to_string(),
            record.metadata.target_device.map(|d| d.to_string()),
            record.metadata.direction as i32,
            record.metadata.size as i64,
            record.metadata.checksum,
            record.metadata.is_favorite,
            serde_json::to_string(&record.metadata.tags)?,
            record.metadata.category,
            record.created_at,
            record.updated_at
        )
        .execute(&self.database)
        .await?;

        Ok(record_id)
    }

    pub async fn get_records(&self, query: HistoryQuery) -> Result<Vec<HistoryRecord>, StorageError> {
        let mut sql = "SELECT * FROM history_records WHERE 1=1".to_string();
        let mut bind_values: Vec<Box<dyn sqlx::Encode<'_, Sqlite> + Send>> = Vec::new();

        // 添加查询条件
        if let Some(content_type) = query.content_type {
            sql.push_str(" AND content_type = ?");
            bind_values.push(Box::new(content_type as i32));
        }

        if let Some(source_device) = query.source_device {
            sql.push_str(" AND source_device = ?");
            bind_values.push(Box::new(source_device.to_string()));
        }

        if let Some(start_date) = query.start_date {
            sql.push_str(" AND created_at >= ?");
            bind_values.push(Box::new(start_date));
        }

        if let Some(end_date) = query.end_date {
            sql.push_str(" AND created_at <= ?");
            bind_values.push(Box::new(end_date));
        }

        if let Some(is_favorite) = query.is_favorite {
            sql.push_str(" AND is_favorite = ?");
            bind_values.push(Box::new(is_favorite));
        }

        // 排序和分页
        sql.push_str(" ORDER BY created_at DESC");
        if let Some(limit) = query.limit {
            sql.push_str(&format!(" LIMIT {}", limit));
        }
        if let Some(offset) = query.offset {
            sql.push_str(&format!(" OFFSET {}", offset));
        }

        let mut query_builder = sqlx::query_as::<_, HistoryRecordRow>(&sql);
        for value in bind_values {
            // 这里需要处理不同类型的绑定值
        }

        let rows = query_builder.fetch_all(&self.database).await?;

        let mut records = Vec::new();
        for row in rows {
            let encrypted_content = EncryptedContent {
                data: row.content_data,
                nonce: row.content_nonce,
                hmac: row.content_hmac,
                timestamp: row.created_at,
            };

            let metadata = HistoryMetadata {
                content_type: ContentType::try_from(row.content_type)?,
                source_device: DeviceId::from_str(&row.source_device)?,
                target_device: row.target_device.map(|d| DeviceId::from_str(&d)).transpose()?,
                direction: TransferDirection::try_from(row.direction)?,
                size: row.size as usize,
                checksum: row.checksum,
                is_favorite: row.is_favorite,
                tags: serde_json::from_str(&row.tags)?,
                category: row.category,
            };

            records.push(HistoryRecord {
                id: row.id,
                content: encrypted_content,
                metadata,
                created_at: row.created_at,
                updated_at: row.updated_at,
            });
        }

        Ok(records)
    }

    pub async fn delete_record(&self, record_id: Uuid) -> Result<bool, StorageError> {
        let result = sqlx::query!("DELETE FROM history_records WHERE id = ?", record_id)
            .execute(&self.database)
            .await?;

        Ok(result.rows_affected() > 0)
    }

    pub async fn update_record(&self, record_id: Uuid, updates: HistoryUpdate) -> Result<bool, StorageError> {
        let mut set_clauses = Vec::new();
        let mut bind_values = Vec::new();

        if let Some(is_favorite) = updates.is_favorite {
            set_clauses.push("is_favorite = ?");
            bind_values.push(Box::new(is_favorite) as Box<dyn sqlx::Encode<'_, Sqlite> + Send>);
        }

        if let Some(tags) = updates.tags {
            set_clauses.push("tags = ?");
            bind_values.push(Box::new(serde_json::to_string(&tags)?) as Box<dyn sqlx::Encode<'_, Sqlite> + Send>);
        }

        if let Some(category) = updates.category {
            set_clauses.push("category = ?");
            bind_values.push(Box::new(category) as Box<dyn sqlx::Encode<'_, Sqlite> + Send>);
        }

        if set_clauses.is_empty() {
            return Ok(false);
        }

        set_clauses.push("updated_at = ?");
        bind_values.push(Box::new(Utc::now()) as Box<dyn sqlx::Encode<'_, Sqlite> + Send>);

        let sql = format!(
            "UPDATE history_records SET {} WHERE id = ?",
            set_clauses.join(", ")
        );

        let mut query_builder = sqlx::query(&sql);
        for value in bind_values {
            // 处理绑定值
        }
        query_builder = query_builder.bind(record_id);

        let result = query_builder.execute(&self.database).await?;
        Ok(result.rows_affected() > 0)
    }
}
```

### 3. 历史记录管理器
```rust
// src/shared/rust/src/history/manager.rs
pub struct HistoryManager {
    storage: HistoryStorage,
    search: HistorySearch,
    sync: HistorySync,
    security: HistorySecurity,
    config: HistoryConfig,
}

impl HistoryManager {
    pub async fn new(config: HistoryConfig) -> Result<Self, ManagerError> {
        let storage = HistoryStorage::new(config.storage.clone()).await?;
        let search = HistorySearch::new(storage.clone());
        let sync = HistorySync::new(config.sync.clone());
        let security = HistorySecurity::new(config.security.clone());

        Ok(Self {
            storage,
            search,
            sync,
            security,
            config,
        })
    }

    pub async fn add_clipboard_content(&self, content: ClipboardContent, metadata: HistoryMetadata) -> Result<Uuid, ManagerError> {
        // 1. 安全检查
        self.security.validate_content(&content).await?;

        // 2. 自动分类
        let mut metadata = metadata;
        metadata.category = self.auto_classify_content(&content);

        // 3. 提取标签
        metadata.tags = self.extract_tags(&content);

        // 4. 检查重复
        if self.is_duplicate_content(&content, &metadata).await? {
            return Err(ManagerError::DuplicateContent);
        }

        // 5. 添加到存储
        let record_id = self.storage.add_record(content, metadata).await?;

        // 6. 清理过期记录
        self.cleanup_expired_records().await?;

        // 7. 同步到云端（如果启用）
        if self.config.sync.enabled {
            self.sync.sync_record(record_id).await?;
        }

        Ok(record_id)
    }

    pub async fn search_history(&self, query: SearchQuery) -> Result<Vec<HistoryRecord>, ManagerError> {
        // 1. 权限检查
        self.security.check_search_permission(&query).await?;

        // 2. 执行搜索
        let results = self.search.search(query).await?;

        // 3. 过滤敏感内容
        let filtered_results = self.security.filter_sensitive_content(results).await?;

        Ok(filtered_results)
    }

    pub async fn get_timeline(&self, filters: TimelineFilters) -> Result<TimelineView, ManagerError> {
        let query = HistoryQuery {
            start_date: filters.start_date,
            end_date: filters.end_date,
            content_type: filters.content_type,
            source_device: filters.source_device,
            is_favorite: filters.favorite_only,
            limit: Some(filters.limit),
            offset: Some(filters.offset),
        };

        let records = self.storage.get_records(query).await?;

        // 按日期分组
        let mut grouped_records: HashMap<Date<Utc>, Vec<HistoryRecord>> = HashMap::new();
        for record in records {
            let date = record.created_at.date();
            grouped_records.entry(date).or_default().push(record);
        }

        // 转换为时间线视图
        let mut timeline_entries = Vec::new();
        for (date, day_records) in grouped_records {
            timeline_entries.push(TimelineEntry {
                date,
                records: day_records,
                total_count: day_records.len(),
                favorites_count: day_records.iter().filter(|r| r.metadata.is_favorite).count(),
            });
        }

        // 按日期排序
        timeline_entries.sort_by(|a, b| b.date.cmp(&a.date));

        Ok(TimelineView {
            entries: timeline_entries,
            total_count: timeline_entries.iter().map(|e| e.total_count).sum(),
            has_more: timeline_entries.len() >= filters.limit,
        })
    }

    async fn auto_classify_content(&self, content: &ClipboardContent) -> Option<String> {
        match content.content_type {
            ContentType::Text => {
                let text = String::from_utf8_lossy(&content.data);

                // 检测URL
                if text.starts_with("http://") || text.starts_with("https://") {
                    return Some("URL".to_string());
                }

                // 检测邮箱
                if text.contains('@') && text.contains('.') {
                    return Some("Email".to_string());
                }

                // 检测电话号码
                if text.chars().filter(|c| c.is_numeric()).count() > 7 {
                    return Some("Phone".to_string());
                }

                // 检测代码
                if self.looks_like_code(&text) {
                    return Some("Code".to_string());
                }

                Some("Text".to_string())
            },
            ContentType::Image => Some("Image".to_string()),
            ContentType::Files => Some("Files".to_string()),
            _ => Some("Other".to_string()),
        }
    }

    async fn cleanup_expired_records(&self) -> Result<(), ManagerError> {
        let expiry_duration = self.config.storage.retention_days;
        let cutoff_date = Utc::now() - Duration::days(expiry_duration as i64);

        let expired_records = self.storage.get_records(HistoryQuery {
            end_date: Some(cutoff_date),
            ..Default::default()
        }).await?;

        for record in expired_records {
            // 不删除收藏内容
            if !record.metadata.is_favorite {
                self.storage.delete_record(record.id).await?;
            }
        }

        Ok(())
    }
}
```

### 4. 搜索引擎
```rust
// src/shared/rust/src/history/search.rs
pub struct HistorySearch {
    storage: HistoryStorage,
    search_index: SearchIndex,
}

impl HistorySearch {
    pub async fn search(&self, query: SearchQuery) -> Result<Vec<HistoryRecord>, SearchError> {
        match query.search_type {
            SearchType::Keyword => self.keyword_search(query).await,
            SearchType::Regex => self.regex_search(query).await,
            SearchType::Semantic => self.semantic_search(query).await,
            SearchType::Fuzzy => self.fuzzy_search(query).await,
        }
    }

    async fn keyword_search(&self, query: SearchQuery) -> Result<Vec<HistoryRecord>, SearchError> {
        let keywords = self.extract_keywords(&query.query);
        let mut results = Vec::new();

        // 1. 使用搜索索引快速查找
        let indexed_results = self.search_index.search(&keywords).await?;

        // 2. 获取完整记录
        for record_id in indexed_results {
            if let Some(record) = self.storage.get_record_by_id(record_id).await? {
                if self.matches_query(&record, &query) {
                    results.push(record);
                }
            }
        }

        // 3. 按相关性排序
        results.sort_by(|a, b| {
            let score_a = self.calculate_relevance_score(a, &query);
            let score_b = self.calculate_relevance_score(b, &query);
            score_b.partial_cmp(&score_a).unwrap_or(std::cmp::Ordering::Equal)
        });

        Ok(results)
    }

    async fn regex_search(&self, query: SearchQuery) -> Result<Vec<HistoryRecord>, SearchError> {
        let regex = Regex::new(&query.query)?;
        let mut results = Vec::new();

        // 在数据库中执行正则表达式搜索
        let records = self.storage.get_records(HistoryQuery {
            content_type: query.content_type,
            source_device: query.source_device,
            start_date: query.start_date,
            end_date: query.end_date,
            limit: query.limit,
            offset: query.offset,
        }).await?;

        for record in records {
            let content = self.decrypt_content(&record.content)?;
            if regex.is_match(&content) {
                results.push(record);
            }
        }

        Ok(results)
    }

    async fn semantic_search(&self, query: SearchQuery) -> Result<Vec<HistoryRecord>, SearchError> {
        // 使用机器学习模型进行语义搜索
        let query_embedding = self.generate_embedding(&query.query).await?;

        let candidates = self.storage.get_records(HistoryQuery {
            content_type: Some(ContentType::Text),
            ..Default::default()
        }).await?;

        let mut results_with_scores = Vec::new();

        for record in candidates {
            let content = self.decrypt_content(&record.content)?;
            let content_embedding = self.generate_embedding(&content).await?;

            let similarity = self.calculate_cosine_similarity(&query_embedding, &content_embedding);

            if similarity > 0.7 { // 相似度阈值
                results_with_scores.push((record, similarity));
            }
        }

        // 按相似度排序
        results_with_scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        let results = results_with_scores.into_iter().map(|(record, _)| record).collect();
        Ok(results)
    }
}
```

### 5. Android平台实现
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/history/HistoryManager.kt
class HistoryManagerImpl(
    private val context: Context,
    private val rustBridge: RustNativeBridge
) : HistoryManager {

    private val database: RoomDatabase by lazy {
        Room.databaseBuilder(
            context,
            HistoryDatabase::class.java,
            "nearclip_history"
        ).build()
    }

    private val historyDao = database.historyDao()

    override suspend fun addHistoryRecord(content: ClipboardContent, metadata: HistoryMetadata): String {
        // 1. 添加到本地数据库
        val localRecord = HistoryEntity(
            id = UUID.randomUUID().toString(),
            contentData = content.data,
            contentType = content.type.value,
            sourceDevice = metadata.sourceDevice,
            targetDevice = metadata.targetDevice,
            direction = metadata.direction.value,
            size = content.data.size.toLong(),
            checksum = metadata.checksum,
            isFavorite = metadata.isFavorite,
            tags = metadata.tags.joinToString(","),
            category = metadata.category,
            createdAt = System.currentTimeMillis(),
            updatedAt = System.currentTimeMillis()
        )

        historyDao.insert(localRecord)

        // 2. 调用Rust进行处理和同步
        val recordId = rustBridge.addHistoryRecord(
            contentData = content.data,
            contentType = content.type.value,
            sourceDevice = metadata.sourceDevice,
            targetDevice = metadata.targetDevice,
            direction = metadata.direction.value,
            size = content.data.size.toLong(),
            checksum = metadata.checksum,
            isFavorite = metadata.isFavorite,
            tags = metadata.tags.toTypedArray(),
            category = metadata.category
        )

        return recordId
    }

    override suspend fun searchHistory(query: SearchQuery): List<HistoryRecord> {
        // 调用Rust搜索引擎
        val results = rustBridge.searchHistory(
            queryString = query.query,
            searchType = query.searchType.value,
            contentType = query.contentType?.value,
            sourceDevice = query.sourceDevice,
            startDate = query.startDate?.time,
            endDate = query.endDate?.time,
            limit = query.limit,
            offset = query.offset
        )

        // 转换结果
        return results.map { result ->
            HistoryRecord(
                id = result.id,
                content = ClipboardContent(
                    data = result.contentData,
                    type = ContentType.fromValue(result.contentType)
                ),
                metadata = HistoryMetadata(
                    sourceDevice = result.sourceDevice,
                    targetDevice = result.targetDevice,
                    direction = TransferDirection.fromValue(result.direction),
                    size = result.size.toInt(),
                    checksum = result.checksum,
                    isFavorite = result.isFavorite,
                    tags = result.tags.split(",").filter { it.isNotEmpty() },
                    category = result.category
                ),
                createdAt = Date(result.createdAt),
                updatedAt = Date(result.updatedAt)
            )
        }
    }

    override suspend fun getTimeline(filters: TimelineFilters): TimelineView {
        // 先从本地数据库获取基本数据
        val localRecords = when {
            filters.favoriteOnly -> {
                historyDao.getFavoriteRecords(filters.limit, filters.offset)
            }
            filters.contentType != null -> {
                historyDao.getRecordsByContentType(filters.contentType.value, filters.limit, filters.offset)
            }
            else -> {
                historyDao.getAllRecords(filters.limit, filters.offset)
            }
        }

        // 调用Rust进行复杂处理
        val timelineResult = rustBridge.getTimeline(
            startDate = filters.startDate?.time,
            endDate = filters.endDate?.time,
            contentType = filters.contentType?.value,
            sourceDevice = filters.sourceDevice,
            favoriteOnly = filters.favoriteOnly,
            limit = filters.limit,
            offset = filters.offset
        )

        // 合并结果
        return TimelineView(
            entries = timelineResult.entries.map { entry ->
                TimelineEntry(
                    date = Date(entry.date),
                    records = entry.records.map { record ->
                        // 转换记录格式
                        convertRustRecordToKotlin(record)
                    },
                    totalCount = entry.totalCount,
                    favoritesCount = entry.favoritesCount
                )
            },
            totalCount = timelineResult.totalCount,
            hasMore = timelineResult.hasMore
        )
    }

    override suspend fun deleteRecord(recordId: String): Boolean {
        // 从本地数据库删除
        historyDao.deleteById(recordId)

        // 调用Rust删除
        return rustBridge.deleteHistoryRecord(recordId)
    }

    override suspend fun updateRecord(recordId: String, updates: HistoryUpdate): Boolean {
        // 更新本地数据库
        historyDao.updateRecord(
            id = recordId,
            isFavorite = updates.isFavorite,
            tags = updates.tags?.joinToString(","),
            category = updates.category,
            updatedAt = System.currentTimeMillis()
        )

        // 调用Rust更新
        return rustBridge.updateHistoryRecord(
            recordId = recordId,
            isFavorite = updates.isFavorite,
            tags = updates.tags?.toTypedArray(),
            category = updates.category
        )
    }
}
```

### 6. macOS平台实现
```swift
// src/platform/mac/NearClip/History/HistoryManager.swift
class HistoryManagerImpl: HistoryManager {
    private let rustBridge: RustNativeBridge
    private let coreDataManager: CoreDataManager

    init(rustBridge: RustNativeBridge) {
        self.rustBridge = rustBridge
        self.coreDataManager = CoreDataManager()
    }

    func addHistoryRecord(
        content: ClipboardContent,
        metadata: HistoryMetadata
    ) async throws -> String {
        // 1. 添加到Core Data
        let localRecord = HistoryRecordEntity(context: coreDataManager.viewContext)
        localRecord.id = UUID().uuidString
        localRecord.contentData = content.data
        localRecord.contentType = Int16(content.type.rawValue)
        localRecord.sourceDevice = metadata.sourceDevice
        localRecord.targetDevice = metadata.targetDevice
        localRecord.direction = Int16(metadata.direction.rawValue)
        localRecord.size = Int64(content.data.count)
        localRecord.checksum = metadata.checksum
        localRecord.isFavorite = metadata.isFavorite
        localRecord.tags = metadata.tags.joined(separator: ",")
        localRecord.category = metadata.category
        localRecord.createdAt = Date()
        localRecord.updatedAt = Date()

        try coreDataManager.viewContext.save()

        // 2. 调用Rust进行处理
        let recordId = try await rustBridge.addHistoryRecord(
            contentData: content.data,
            contentType: Int32(content.type.rawValue),
            sourceDevice: metadata.sourceDevice,
            targetDevice: metadata.targetDevice,
            direction: Int32(metadata.direction.rawValue),
            size: Int64(content.data.count),
            checksum: metadata.checksum,
            isFavorite: metadata.isFavorite,
            tags: metadata.tags,
            category: metadata.category
        )

        return recordId
    }

    func searchHistory(query: SearchQuery) async throws -> [HistoryRecord] {
        // 调用Rust搜索引擎
        let results = try await rustBridge.searchHistory(
            queryString: query.query,
            searchType: Int32(query.searchType.rawValue),
            contentType: query.contentType.map { Int32($0.rawValue) },
            sourceDevice: query.sourceDevice,
            startDate: query.startDate?.timeIntervalSince1970,
            endDate: query.endDate?.timeIntervalSince1970,
            limit: Int32(query.limit ?? 100),
            offset: Int32(query.offset ?? 0)
        )

        // 转换结果
        return results.map { result in
            HistoryRecord(
                id: result.id,
                content: ClipboardContent(
                    data: result.contentData,
                    type: ContentType(rawValue: Int(result.contentType)) ?? .text
                ),
                metadata: HistoryMetadata(
                    sourceDevice: result.sourceDevice,
                    targetDevice: result.targetDevice,
                    direction: TransferDirection(rawValue: Int(result.direction)) ?? .sent,
                    size: Int(result.size),
                    checksum: result.checksum,
                    isFavorite: result.isFavorite,
                    tags: result.tags.split(separator: ",").filter { !$0.isEmpty },
                    category: result.category
                ),
                createdAt: Date(timeIntervalSince1970: result.createdAt),
                updatedAt: Date(timeIntervalSince1970: result.updatedAt)
            )
        }
    }

    func getTimeline(filters: TimelineFilters) async throws -> TimelineView {
        let timelineResult = try await rustBridge.getTimeline(
            startDate: filters.startDate?.timeIntervalSince1970,
            endDate: filters.endDate?.timeIntervalSince1970,
            contentType: filters.contentType.map { Int32($0.rawValue) },
            sourceDevice: filters.sourceDevice,
            favoriteOnly: filters.favoriteOnly,
            limit: Int32(filters.limit),
            offset: Int32(filters.offset)
        )

        return TimelineView(
            entries: timelineResult.entries.map { entry in
                TimelineEntry(
                    date: Date(timeIntervalSince1970: entry.date),
                    records: entry.records.map { record in
                        convertRustRecordToSwift(record)
                    },
                    totalCount: entry.totalCount,
                    favoritesCount: entry.favoritesCount
                )
            },
            totalCount: timelineResult.totalCount,
            hasMore: timelineResult.hasMore
        )
    }

    func deleteRecord(recordId: String) async throws -> Bool {
        // 从Core Data删除
        try await coreDataManager.deleteRecord(id: recordId)

        // 调用Rust删除
        return try await rustBridge.deleteHistoryRecord(recordId: recordId)
    }

    func updateRecord(recordId: String, updates: HistoryUpdate) async throws -> Bool {
        // 更新Core Data
        try await coreDataManager.updateRecord(
            id: recordId,
            isFavorite: updates.isFavorite,
            tags: updates.tags?.joined(separator: ","),
            category: updates.category,
            updatedAt: Date()
        )

        // 调用Rust更新
        return try await rustBridge.updateHistoryRecord(
            recordId: recordId,
            isFavorite: updates.isFavorite,
            tags: updates.tags,
            category: updates.category
        )
    }
}
```

## 测试用例

### 单元测试
```rust
// src/shared/rust/src/history/tests.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_add_history_record() {
        let manager = HistoryManager::new(create_test_config()).await.unwrap();
        let content = create_test_clipboard_content();
        let metadata = create_test_metadata();

        let record_id = manager.add_clipboard_content(content, metadata).await.unwrap();

        assert!(!record_id.to_string().is_empty());
    }

    #[tokio::test]
    async fn test_search_functionality() {
        let manager = HistoryManager::new(create_test_config()).await.unwrap();

        // 添加测试数据
        let test_content = create_text_content("Hello World Test");
        manager.add_clipboard_content(test_content, create_test_metadata()).await.unwrap();

        // 搜索测试
        let query = SearchQuery {
            query: "Hello".to_string(),
            search_type: SearchType::Keyword,
            ..Default::default()
        };

        let results = manager.search_history(query).await.unwrap();
        assert!(!results.is_empty());
        assert!(results[0].metadata.checksum.contains("Hello"));
    }

    #[tokio::test]
    async fn test_timeline_generation() {
        let manager = HistoryManager::new(create_test_config()).await.unwrap();

        // 添加不同时间的测试数据
        let now = Utc::now();
        let yesterday = now - Duration::days(1);

        add_test_record_with_timestamp(&manager, "Content 1", now).await;
        add_test_record_with_timestamp(&manager, "Content 2", yesterday).await;

        let filters = TimelineFilters {
            start_date: Some(yesterday - Duration::hours(1)),
            end_date: Some(now + Duration::hours(1)),
            limit: 10,
            offset: 0,
            ..Default::default()
        };

        let timeline = manager.get_timeline(filters).await.unwrap();
        assert_eq!(timeline.entries.len(), 2);
        assert_eq!(timeline.total_count, 2);
    }
}
```

### 集成测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/history/HistoryIntegrationTest.kt
@RunWith(AndroidJUnit4::class)
class HistoryIntegrationTest {

    @Test
    fun testEndToEndHistoryFlow() {
        val content = createTestClipboardContent()
        val metadata = createTestHistoryMetadata()

        // 添加历史记录
        runBlocking {
            val recordId = historyManager.addHistoryRecord(content, metadata)
            assertThat(recordId).isNotEmpty()

            // 搜索历史记录
            val searchQuery = SearchQuery(
                query = "test",
                searchType = SearchType.KEYWORD,
                limit = 10,
                offset = 0
            )
            val results = historyManager.searchHistory(searchQuery)
            assertThat(results).isNotEmpty()

            // 获取时间线
            val timeline = historyManager.getTimeline(
                TimelineFilters(limit = 10, offset = 0)
            )
            assertThat(timeline.entries).isNotEmpty()
        }
    }
}
```

### 性能测试
```rust
// src/shared/rust/src/history/tests/performance.rs
#[tokio::test]
async fn test_search_performance() {
    let manager = HistoryManager::new(create_test_config()).await.unwrap();

    // 添加大量测试数据
    for i in 0..1000 {
        let content = create_text_content(&format!("Test content {}", i));
        let metadata = create_test_metadata();
        manager.add_clipboard_content(content, metadata).await.unwrap();
    }

    // 测试搜索性能
    let start_time = Instant::now();
    let query = SearchQuery {
        query: "Test".to_string(),
        search_type: SearchType::Keyword,
        limit: 100,
        offset: 0,
        ..Default::default()
    };

    let results = manager.search_history(query).await.unwrap();
    let elapsed = start_time.elapsed();

    assert!(results.len() <= 100);
    assert!(elapsed < Duration::from_millis(500)); // 搜索时间不超过500ms
    println!("Search time: {:?}", elapsed);
}
```

## 部署要求

### 环境配置
- Android: API 24+ (Android 7.0+)
- macOS: 10.15+ (Catalina+)
- Rust: 1.70+
- 数据库: SQLite 3.x
- 存储: 最少100MB用于历史记录

### 依赖项
```toml
# Cargo.toml
[dependencies]
sqlx = { version = "0.7", features = ["runtime-tokio-rustls", "sqlite", "chrono", "uuid"] }
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
chrono = { version = "0.4", features = ["serde"] }
uuid = { version = "1.6", features = ["v4", "serde"] }
regex = "1.10"
ring = "0.17"  # 加密支持
```

```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.room:room-runtime:2.5.0"
    implementation "androidx.room:room-ktx:2.5.0"
    kapt "androidx.room:room-compiler:2.5.0"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"
}
```

## 验收测试计划

### 功能测试
1. **记录存储**: 测试各种类型内容的历史记录存储
2. **搜索功能**: 测试关键词、正则表达式和语义搜索
3. **时间线视图**: 验证历史记录的时间线显示
4. **管理操作**: 测试删除、编辑和收藏功能

### 性能测试
1. **存储性能**: 测试大量历史记录的存储性能
2. **搜索性能**: 验证搜索功能的响应时间
3. **内存使用**: 监控历史记录功能的内存占用
4. **数据库性能**: 测试数据库查询和索引效率

### 安全测试
1. **加密存储**: 验证历史记录的加密存储
2. **访问控制**: 测试历史记录的访问权限控制
3. **敏感内容**: 验证敏感内容的检测和保护
4. **审计日志**: 测试操作日志的记录和查看

### 用户体验测试
1. **搜索体验**: 测试搜索功能的易用性和准确性
2. **时间线体验**: 验证时间线视图的直观性和操作性
3. **管理体验**: 测试历史记录管理功能的便利性
4. **性能体验**: 验证大量数据情况下的使用体验

## 风险与缓解

### 技术风险
- **存储空间**: 历史记录可能占用大量存储空间
  - 缓解: 自动清理机制，压缩存储，用户配置限制
- **搜索性能**: 大量数据时搜索性能可能下降
  - 缓解: 索引优化，分页加载，缓存策略
- **数据同步**: 多设备间的历史记录同步可能复杂
  - 缓解: 增量同步，冲突解决，离线支持

### 安全风险
- **隐私泄露**: 历史记录包含敏感信息
  - 缓解: 加密存储，访问控制，用户确认
- **数据恢复**: 删除的历史记录可能被恢复
  - 缓解: 安全删除，多次覆盖，清理工具
- **未授权访问**: 恶意应用可能访问历史记录
  - 缓解: 权限控制，沙盒隔离，访问审计

### 用户体验风险
- **信息过载**: 过多的历史记录可能让用户难以管理
  - 缓解: 智能分类，搜索过滤，自动清理
- **查找困难**: 在大量历史记录中查找特定内容可能困难
  - 缓解: 强大的搜索功能，智能推荐，标签系统
- **同步延迟**: 多设备同步可能有延迟
  - 缓解: 实时同步，状态提示，冲突处理

## 完成标准
- [ ] 历史记录自动存储功能正常工作
- [ ] 搜索功能支持多种搜索类型
- [ ] 时间线视图显示正确且美观
- [ ] 历史记录管理操作完整可用
- [ ] 隐私保护和安全机制有效
- [ ] 性能优化达到预期目标
- [ ] 所有单元测试和集成测试通过
- [ ] Android和macOS平台功能完整
- [ ] 用户界面友好且响应迅速
- [ ] 错误处理和用户反馈机制完善