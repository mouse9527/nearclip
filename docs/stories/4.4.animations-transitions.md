# 故事 4.4: 动画与转场效果

## 基本信息
- **故事编号**: 4.4
- **Epic**: Epic 4 - 用户体验与界面优化
- **故事名称**: 动画与转场效果
- **优先级**: 中
- **预计工期**: 4 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 应用具有流畅自然的动画和转场效果，
**以便** 我能够获得更好的视觉反馈和交互体验，使应用操作更加直观和愉悦。

## 验收标准

### AC 1: 微交互动画
- **按钮交互**: 按钮点击时的缩放、颜色变化和涟漪效果
- **开关切换**: 开关状态切换时的平滑过渡动画
- **卡片展开**: 卡片展开/收起时的内容渐显和高度变化
- **加载指示**: 数据加载时的进度指示器和骨架屏动画
- **悬停效果**: macOS平台上的悬停状态变化动画

### AC 2: 页面转场动画
- **页面切换**: 不同页面间的平滑转场效果
- **导航过渡**: 导航层级间的推入/推出动画
- **模态对话框**: 模态框的弹出和关闭动画
- **侧边栏滑动**: 侧边栏的滑入/滑出动画
- **标签切换**: 底部标签切换时的内容切换动画

### AC 3: 状态变化动画
- **数据更新**: 数据更新时的内容渐变动画
- **列表变化**: 列表项添加/删除时的插入/移除动画
- **状态指示**: 连接状态、同步状态的动态指示动画
- **进度展示**: 进度条的平滑增长动画
- **错误反馈**: 错误状态的抖动或闪烁提示动画

### AC 4: 手势交互动画
- **滑动手势**: 滑动删除、滑动刷新的跟随动画
- **长按手势**: 长按时的缩放和震动反馈
- **拖拽交互**: 拖拽时的实时跟随动画
- **捏合缩放**: 图片捏合缩放的平滑动画
- **手势反馈**: 手势识别成功/失败的视觉反馈

### AC 5: 性能优化适配
- **动画性能**: 确保动画帧率保持在60fps
- **设备适配**: 根据设备性能动态调整动画复杂度
- **内存管理**: 动画资源的合理管理和释放
- **电池优化**: 优化动画对电池消耗的影响
- **用户偏好**: 尊重用户的动画偏好设置

## 技术实现要点

### 1. 动画系统基础架构
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/animation/AnimationTokens.kt
import androidx.compose.animation.*
import androidx.compose.runtime.*
import androidx.compose.ui.unit.dp

// 动画时长规范
data class AnimationDuration(
    val instant: Int = 0,
    val fast: Int = 150,
    val normal: Int = 300,
    val slow: Int = 500,
    val slower: Int = 800
) {
    companion object {
        val default = AnimationDuration()
    }
}

// 缓动函数规范
data class AnimationEasing {
    val standard: CubicBezierEasing = CubicBezierEasing(0.2f, 0.0f, 0.0f, 1.0f)
    val standardDecelerate: CubicBezierEasing = CubicBezierEasing(0.0f, 0.0f, 0.0f, 1.0f)
    val standardAccelerate: CubicBezierEasing = CubicBezierEasing(0.3f, 0.0f, 1.0f, 1.0f)
    val emphasized: CubicBezierEasing = CubicBezierEasing(0.2f, 0.0f, 0.0f, 1.0f)
    val emphasizedDecelerate: CubicBezierEasing = CubicBezierEasing(0.05f, 0.7f, 0.1f, 1.0f)
    val emphasizedAccelerate: CubicBezierEasing = CubicBezierEasing(0.3f, 0.0f, 0.8f, 0.15f)
    val legacy: CubicBezierEasing = CubicBezierEasing(0.4f, 0.0f, 0.2f, 1.0f)
    val legacyDecelerate: CubicBezierEasing = CubicBezierEasing(0.0f, 0.0f, 0.0f, 1.0f)
    val legacyAccelerate: CubicBezierEasing = CubicBezierEasing(0.3f, 0.0f, 1.0f, 1.0f)
}

// 动画规格
data class AnimationSpecs(
    val duration: AnimationDuration = AnimationDuration.default,
    val easing: AnimationEasing = AnimationEasing()
) {
    // 标准动画规格
    val standardTween = tween<Color>(
        durationMillis = duration.normal,
        easing = easing.standard
    )

    val standardTweenFloat = tween<Float>(
        durationMillis = duration.normal,
        easing = easing.standard
    )

    val standardTweenInt = tween<Int>(
        durationMillis = duration.normal,
        easing = easing.standard
    )

    val standardTweenDp = tween<Dp>(
        durationMillis = duration.normal,
        easing = easing.standard
    )

    // 快速动画规格
    val fastTween = tween<Color>(
        durationMillis = duration.fast,
        easing = easing.standard
    )

    val fastTweenFloat = tween<Float>(
        durationMillis = duration.fast,
        easing = easing.standard
    )

    // 弹性动画规格
    val springSpec = spring<Float>(
        dampingRatio = Spring.DampingRatioMediumBouncy,
        stiffness = Spring.StiffnessMedium
    )

    // 强调动画规格
    val emphasizedTween = tween<Color>(
        durationMillis = duration.slow,
        easing = easing.emphasized
    )

    // 无限循环动画
    val infiniteRepeatable = InfiniteRepeatableSpec<Float>(
        animation = tween(
            durationMillis = duration.normal,
            easing = easing.standard
        ),
        repeatMode = RepeatMode.Reverse,
        initialStartOffset = StartOffset(0)
    )
}

// 动画主题
data class AnimationTheme(
    val specs: AnimationSpecs = AnimationSpecs(),
    val enableAnimations: Boolean = true,
    val reducedMotion: Boolean = false
)

// Composition Local for animation theme
val LocalAnimationTheme = staticCompositionLocalOf {
    AnimationTheme()
}
```

### 2. 微交互动画组件
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/animation/MicroInteractions.kt
import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.clickable
import androidx.compose.foundation.interaction.*
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material.ripple.rememberRipple
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.draw.scale
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

// 动画按钮
@Composable
fun AnimatedButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    variant: NearClipButtonVariant = NearClipButtonVariant.Primary,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    var isPressed by remember { mutableStateOf(false) }
    val interactionSource = remember { MutableInteractionSource() }
    val pressAnimation by animateFloatAsState(
        targetValue = if (isPressed) 0.95f else 1f,
        animationSpec = animationSpecs.fastTweenFloat,
        label = "button_press"
    )

    val colors = ButtonDefaults.buttonColors()
    val backgroundColor by animateColorAsState(
        targetValue = when (variant) {
            NearClipButtonVariant.Primary ->
                if (enabled) MaterialTheme.colorScheme.primary
                else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)
            NearClipButtonVariant.Secondary ->
                if (enabled) MaterialTheme.colorScheme.secondary
                else MaterialTheme.colorScheme.onSurface.copy(alpha = 0.12f)
            else -> Color.Transparent
        },
        animationSpec = animationSpecs.standardTween,
        label = "button_background"
    )

    Button(
        onClick = onClick,
        modifier = modifier
            .scale(pressAnimation)
            .clickable(
                interactionSource = interactionSource,
                indication = rememberRipple(),
                enabled = enabled,
                onClick = onClick
            ),
        enabled = enabled,
        colors = colors,
        interactionSource = interactionSource
    ) {
        Text(
            text = text,
            style = MaterialTheme.typography.labelLarge,
            color = MaterialTheme.colorScheme.onPrimary
        )
    }

    LaunchedEffect(interactionSource) {
        interactionSource.interactions.collect { interaction ->
            when (interaction) {
                is PressInteraction.Press -> isPressed = true
                is PressInteraction.Release -> isPressed = false
                is PressInteraction.Cancel -> isPressed = false
            }
        }
    }
}

// 动画开关
@Composable
fun AnimatedSwitch(
    checked: Boolean,
    onCheckedChange: (Boolean) -> Unit,
    modifier: Modifier = Modifier,
    enabled: Boolean = true,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    val targetOffset = if (checked) 24.dp else 0.dp
    val thumbOffset by animateDpAsState(
        targetValue = targetOffset,
        animationSpec = animationSpecs.springSpec,
        label = "switch_thumb_offset"
    )

    val trackColor by animateColorAsState(
        targetValue = if (checked) {
            MaterialTheme.colorScheme.primary
        } else {
            MaterialTheme.colorScheme.outline
        },
        animationSpec = animationSpecs.standardTween,
        label = "switch_track_color"
    )

    Box(
        modifier = modifier
            .width(52.dp)
            .height(32.dp)
            .clip(CircleShape)
            .background(trackColor.copy(alpha = 0.3f))
            .clickable(enabled = enabled, onClick = { onCheckedChange(!checked) }),
        contentAlignment = Alignment.CenterStart
    ) {
        // Track background
        Box(
            modifier = Modifier
                .fillMaxSize()
                .background(
                    trackColor,
                    CircleShape
                )
        )

        // Thumb
        Box(
            modifier = Modifier
                .padding(4.dp)
                .size(24.dp)
                .offset(x = thumbOffset)
                .background(
                    MaterialTheme.colorScheme.background,
                    CircleShape
                )
                .shadow(
                    elevation = 2.dp,
                    shape = CircleShape
                )
        )
    }
}

// 动画卡片
@Composable
fun AnimatedCard(
    modifier: Modifier = Modifier,
    expanded: Boolean = false,
    onExpandedChange: (Boolean) -> Unit = {},
    previewContent: @Composable () -> Unit,
    fullContent: @Composable () -> Unit,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    var cardHeight by remember { mutableStateOf(0.dp) }
    val targetHeight = if (expanded) {
        // 计算展开后的高度（这里需要实际测量）
        200.dp // 占位值
    } else {
        // 收起时的高度
        100.dp // 占位值
    }

    val animatedHeight by animateDpAsState(
        targetValue = targetHeight,
        animationSpec = animationSpecs.standardTweenDp,
        label = "card_height"
    )

    val cardElevation by animateDpAsState(
        targetValue = if (expanded) 8.dp else 2.dp,
        animationSpec = animationSpecs.standardTweenDp,
        label = "card_elevation"
    )

    Card(
        modifier = modifier
            .fillMaxWidth()
            .heightIn(min = 100.dp)
            .height(animatedHeight)
            .clickable { onExpandedChange(!expanded) },
        elevation = CardDefaults.cardElevation(
            defaultElevation = cardElevation
        )
    ) {
        Column {
            // 预览内容（始终显示）
            Box(
                modifier = Modifier
                    .fillMaxWidth()
                    .height(100.dp)
                    .padding(16.dp)
            ) {
                previewContent()
            }

            // 展开内容（动画显示）
            AnimatedVisibility(
                visible = expanded,
                enter = fadeIn(
                    animationSpec = animationSpecs.standardTween
                ) + expandVertically(
                    animationSpec = animationSpecs.standardTween
                ),
                exit = fadeOut(
                    animationSpec = animationSpecs.standardTween
                ) + shrinkVertically(
                    animationSpec = animationSpecs.standardTween
                )
            ) {
                Box(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(16.dp)
                ) {
                    fullContent()
                }
            }
        }
    }
}

// 加载动画
@Composable
fun AnimatedLoadingIndicator(
    modifier: Modifier = Modifier,
    size: androidx.compose.ui.unit.Dp = 40.dp,
    color: Color = MaterialTheme.colorScheme.primary,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    val infiniteTransition = rememberInfiniteTransition()
    val rotation by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 360f,
        animationSpec = infiniteRepeatable(
            animation = tween(
                durationMillis = animationSpecs.duration.normal,
                easing = LinearEasing
            ),
            repeatMode = RepeatMode.Restart
        ),
        label = "loading_rotation"
    )

    Box(
        modifier = modifier.size(size),
        contentAlignment = Alignment.Center
    ) {
        CircularProgressIndicator(
            modifier = Modifier
                .size(size)
                .graphicsLayer { rotationZ = rotation },
            color = color,
            strokeWidth = 3.dp
        )
    }
}

// 骨架屏动画
@Composable
fun AnimatedSkeleton(
    modifier: Modifier = Modifier,
    shape: androidx.compose.ui.graphics.Shape = MaterialTheme.shapes.medium,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    val infiniteTransition = rememberInfiniteTransition()
    val alpha by infiniteTransition.animateFloat(
        initialValue = 0.2f,
        targetValue = 0.8f,
        animationSpec = infiniteRepeatable(
            animation = tween(
                durationMillis = animationSpecs.duration.slow,
                easing = EaseInOutCubic
            ),
            repeatMode = RepeatMode.Reverse
        ),
        label = "skeleton_alpha"
    )

    Box(
        modifier = modifier
            .clip(shape)
            .background(
                color = MaterialTheme.colorScheme.onSurface.copy(alpha = alpha)
            )
    )
}
```

### 3. 页面转场动画
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/animation/NavigationTransitions.kt
import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.runtime.*
import androidx.compose.ui.unit.IntOffset
import androidx.navigation.NavBackStackEntry
import androidx.navigation.NavGraphBuilder
import androidx.navigation.compose.composable
import kotlin.math.roundToInt

// 自定义转场动画
object NearClipTransitions {

    // 水平滑动转场（用于前进/后退）
    val slideHorizontal = slideIntoContainer(
        towards = AnimatedContentTransitionScope.SlideDirection.Start,
        animationSpec = tween(
            durationMillis = 300,
            easing = FastOutSlowInEasing
        )
    ) with slideOutOfContainer(
        towards = AnimatedContentTransitionScope.SlideDirection.Start,
        animationSpec = tween(
            durationMillis = 300,
            easing = FastOutSlowInEasing
        )
    )

    // 垂直滑动转场（用于模态页面）
    val slideVertical = slideIntoContainer(
        towards = AnimatedContentTransitionScope.SlideDirection.Bottom,
        animationSpec = tween(
            durationMillis = 400,
            easing = FastOutSlowInEasing
        )
    ) with slideOutOfContainer(
        towards = AnimatedContentTransitionScope.SlideDirection.Bottom,
        animationSpec = tween(
            durationMillis = 400,
            easing = FastOutSlowInEasing
        )
    )

    // 淡入淡出转场
    val fade = fadeIn(
        animationSpec = tween(
            durationMillis = 200,
            easing = LinearEasing
        )
    ) with fadeOut(
        animationSpec = tween(
            durationMillis = 200,
            easing = LinearEasing
        )
    )

    // 缩放转场
    val scale = scaleIn(
        animationSpec = tween(
            durationMillis = 300,
            easing = FastOutSlowInEasing
        ),
        initialScale = 0.8f
    ) with scaleOut(
        animationSpec = tween(
            durationMillis = 300,
            easing = FastOutSlowInEasing
        ),
        targetScale = 1.2f
    )

    // 组合转场（淡入+滑动）
    val fadeAndSlideHorizontal = slideIntoContainer(
        towards = AnimatedContentTransitionScope.SlideDirection.Start,
        animationSpec = tween(
            durationMillis = 300,
            easing = FastOutSlowInEasing
        )
    ) + fadeIn(
        animationSpec = tween(
            durationMillis = 300,
            easing = LinearEasing
        )
    ) with slideOutOfContainer(
        towards = AnimatedContentTransitionScope.SlideDirection.Start,
        animationSpec = tween(
            durationMillis = 300,
            easing = FastOutSlowInEasing
        )
    ) + fadeOut(
        animationSpec = tween(
            durationMillis = 300,
            easing = LinearEasing
        )
    )
}

// 带动画的导航扩展
fun NavGraphBuilder.animatedComposable(
    route: String,
    arguments: List<NamedNavArgument> = emptyList(),
    deepLinks: List<NavDeepLink> = emptyList(),
    enterTransition: (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? = { NearClipTransitions.fadeAndSlideHorizontal },
    exitTransition: (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? = { NearClipTransitions.fadeAndSlideHorizontal },
    popEnterTransition: (AnimatedContentTransitionScope<NavBackStackEntry>.() -> EnterTransition)? = { NearClipTransitions.fadeAndSlideHorizontal },
    popExitTransition: (AnimatedContentTransitionScope<NavBackStackEntry>.() -> ExitTransition)? = { NearClipTransitions.fadeAndSlideHorizontal },
    content: @Composable (NavBackStackEntry) -> Unit
) {
    composable(
        route = route,
        arguments = arguments,
        deepLinks = deepLinks
    ) {
        AnimatedContent(
            targetState = it,
            transitionSpec = {
                val isForward = initialState.destination.route != "home"
                if (isForward) {
                    (enterTransition?.invoke(this) ?: EnterTransition.None) with
                    (exitTransition?.invoke(this) ?: ExitTransition.None)
                } else {
                    (popEnterTransition?.invoke(this) ?: EnterTransition.None) with
                    (popExitTransition?.invoke(this) ?: ExitTransition.None)
                }
            }
        ) { backStackEntry ->
            content(backStackEntry)
        }
    }
}

// 共享元素转场
@Composable
fun SharedElementTransition(
    isVisible: Boolean,
    content: @Composable () -> Unit
) {
    AnimatedVisibility(
        visible = isVisible,
        enter = fadeIn(
            animationSpec = tween(300, easing = FastOutSlowInEasing)
        ) + scaleIn(
            animationSpec = tween(300, easing = FastOutSlowInEasing),
            initialScale = 0.8f
        ),
        exit = fadeOut(
            animationSpec = tween(200, easing = FastOutSlowInEasing)
        ) + scaleOut(
            animationSpec = tween(200, easing = FastOutSlowInEasing),
            targetScale = 1.1f
        )
    ) {
        content()
    }
}
```

### 4. 状态动画组件
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/animation/StateAnimations.kt
import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.unit.dp

// 连接状态动画指示器
@Composable
fun ConnectionStatusIndicator(
    status: ConnectionStatus,
    modifier: Modifier = Modifier,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    val targetColor = when (status) {
        ConnectionStatus.CONNECTED -> Color.Green
        ConnectionStatus.CONNECTING -> Color.Orange
        ConnectionStatus.DISCONNECTED -> Color.Red
        ConnectionStatus.FAILED -> Color.Red
    }

    val animatedColor by animateColorAsState(
        targetValue = targetColor,
        animationSpec = animationSpecs.standardTween,
        label = "connection_status_color"
    )

    val isAnimating = status == ConnectionStatus.CONNECTING

    Box(
        modifier = modifier.size(12.dp),
        contentAlignment = Alignment.Center
    ) {
        if (isAnimating) {
            val infiniteTransition = rememberInfiniteTransition()
            val scale by infiniteTransition.animateFloat(
                initialValue = 0.8f,
                targetValue = 1.2f,
                animationSpec = infiniteRepeatable(
                    animation = tween(800, easing = EaseInOutCubic),
                    repeatMode = RepeatMode.Reverse
                ),
                label = "connecting_pulse"
            )

            Box(
                modifier = Modifier
                    .size(12.dp)
                    .background(
                        animatedColor,
                        CircleShape
                    )
                    .graphicsLayer { scaleX = scale; scaleY = scale }
            )
        } else {
            Box(
                modifier = Modifier
                    .size(12.dp)
                    .background(
                        animatedColor,
                        CircleShape
                    )
            )
        }
    }
}

// 进度条动画
@Composable
fun AnimatedProgressBar(
    progress: Float,
    modifier: Modifier = Modifier,
    color: Color = MaterialTheme.colorScheme.primary,
    backgroundColor: Color = MaterialTheme.colorScheme.surfaceVariant,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    val animatedProgress by animateFloatAsState(
        targetValue = progress,
        animationSpec = animationSpecs.standardTweenFloat,
        label = "progress_animation"
    )

    Box(
        modifier = modifier
            .fillMaxWidth()
            .height(8.dp)
            .background(
                backgroundColor,
                RoundedCornerShape(4.dp)
            )
    ) {
        Box(
            modifier = Modifier
                .fillMaxWidth(animatedProgress.coerceIn(0f, 1f))
                .fillMaxHeight()
                .background(
                    color,
                    RoundedCornerShape(4.dp)
                )
        )
    }
}

// 列表项动画
@Composable
fun <T> AnimatedListItem(
    item: T,
    isVisible: Boolean,
    modifier: Modifier = Modifier,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs,
    content: @Composable (T) -> Unit
) {
    AnimatedVisibility(
        visible = isVisible,
        modifier = modifier,
        enter = slideInVertically(
            initialOffsetY = { it / 4 }, // 从顶部1/4位置滑入
            animationSpec = animationSpecs.standardTween
        ) + fadeIn(
            animationSpec = animationSpecs.standardTween
        ),
        exit = slideOutVertically(
            targetOffsetY = { -it / 4 }, // 向上滑出到顶部1/4位置
            animationSpec = animationSpecs.standardTween
        ) + fadeOut(
            animationSpec = animationSpecs.standardTween
        )
    ) {
        content(item)
    }
}

// 错误抖动动画
@Composable
fun ShakingAnimation(
    isError: Boolean,
    modifier: Modifier = Modifier,
    content: @Composable () -> Unit
) {
    val offsetX by animateFloatAsState(
        targetValue = if (isError) 0f else 0f,
        animationSpec = if (isError) {
            key(isError) {
                tween<Float>(
                    durationMillis = 500,
                    easing = LinearEasing
                )
            }
        } else {
            tween(0)
        },
        label = "error_shake"
    )

    // 计算抖动偏移
    val shakeOffset = if (isError) {
        val time = (System.currentTimeMillis() % 500) / 500f
        val amplitude = 8f
        (sin(time * 2 * PI * 4) * amplitude).toFloat()
    } else {
        0f
    }

    Box(
        modifier = modifier.offset(x = shakeOffset.dp)
    ) {
        content()
    }
}

// 计数器动画
@Composable
fun AnimatedCounter(
    count: Int,
    modifier: Modifier = Modifier,
    animationSpecs: AnimationSpecs = LocalAnimationTheme.current.specs
) {
    val animatedCount by animateIntAsState(
        targetValue = count,
        animationSpec = animationSpecs.standardTweenInt,
        label = "counter_animation"
    )

    Text(
        text = animatedCount.toString(),
        modifier = modifier,
        style = MaterialTheme.typography.headlineMedium,
        color = MaterialTheme.colorScheme.primary
    )
}

enum class ConnectionStatus {
    CONNECTED,
    CONNECTING,
    DISCONNECTED,
    FAILED
}
```

### 5. SwiftUI macOS 动画实现
```swift
// src/platform/mac/NearClip/Animations/AnimationSystem.swift
import SwiftUI

// 动画配置
struct AnimationConfiguration {
    static let duration = Duration(
        milliseconds: (fast: 150, normal: 300, slow: 500, slower: 800)
    )

    static let easing = Easing(
        standard: Animation.easeInOut(duration: duration.normal),
        standardIn: Animation.easeIn(duration: duration.normal),
        standardOut: Animation.easeOut(duration: duration.normal),
        spring: Animation.spring(response: 0.5, dampingFraction: 0.8),
        bouncy: Animation.spring(response: 0.6, dampingFraction: 0.6)
    )
}

struct Easing {
    let standard: Animation
    let standardIn: Animation
    let standardOut: Animation
    let spring: Animation
    let bouncy: Animation
}

// 微交互动画视图
struct AnimatedButton: View {
    let title: String
    let action: () -> Void
    @State private var isPressed = false
    @State private var isHovered = false

    var body: some View {
        Button(action: action) {
            Text(title)
                .font(.nearclipLabelLarge)
                .fontWeight(.medium)
                .foregroundColor(.white)
                .padding(.horizontal, 16)
                .padding(.vertical, 12)
                .background(
                    RoundedRectangle(cornerRadius: 12)
                        .fill(Color.nearclipPrimary)
                        .scaleEffect(isPressed ? 0.95 : 1.0)
                        .shadow(
                            color: Color.black.opacity(0.1),
                            radius: isHovered ? 8 : 4,
                            x: 0,
                            y: isHovered ? 4 : 2
                        )
                )
        }
        .buttonStyle(PlainButtonStyle())
        .onTapGesture {
            withAnimation(.easeInOut(duration: 0.1)) {
                isPressed = true
            }

            DispatchQueue.main.asyncAfter(deadline: .now() + 0.1) {
                withAnimation(.easeInOut(duration: 0.1)) {
                    isPressed = false
                }
            }

            action()
        }
        .onHover { hovering in
            withAnimation(.easeInOut(duration: 0.2)) {
                isHovered = hovering
            }
        }
    }
}

// 动画卡片视图
struct AnimatedCard: View {
    let title: String
    let subtitle: String
    @State private var isExpanded = false

    var body: some View {
        VStack(alignment: .leading, spacing: 16) {
            HStack {
                VStack(alignment: .leading) {
                    Text(title)
                        .font(.nearclipTitleMedium)
                        .fontWeight(.semibold)
                        .foregroundColor(.primary)

                    Text(subtitle)
                        .font(.nearclipBodyMedium)
                        .foregroundColor(.secondary)
                }

                Spacer()

                Image(systemName: isExpanded ? "chevron.up" : "chevron.down")
                    .font(.system(size: 16, weight: .medium))
                    .foregroundColor(.secondary)
                    .rotationEffect(.degrees(isExpanded ? 180 : 0))
            }

            if isExpanded {
                Text("这是展开后的内容区域，可以显示更多的信息和操作选项。")
                    .font(.nearclipBodyMedium)
                    .foregroundColor(.secondary)
                    .transition(.asymmetric(
                        insertion: .opacity.combined(with: .move(edge: .top)),
                        removal: .opacity.combined(with: .move(edge: .top))
                    ))
            }
        }
        .padding(20)
        .background(
            RoundedRectangle(cornerRadius: 16)
                .fill(Color.white)
                .shadow(
                    color: Color.black.opacity(0.1),
                    radius: isExpanded ? 8 : 4,
                    x: 0,
                    y: isExpanded ? 4 : 2
                )
        )
        .onTapGesture {
            withAnimation(AnimationConfiguration.easing.spring) {
                isExpanded.toggle()
            }
        }
    }
}

// 状态指示器动画
struct ConnectionStatusIndicator: View {
    let status: ConnectionStatus
    @State private var pulseScale = 1.0

    var body: some View {
        Circle()
            .fill(statusColor)
            .frame(width: 12, height: 12)
            .scaleEffect(pulseScale)
            .onAppear {
                if status == .connecting {
                    withAnimation(
                        Animation.easeInOut(duration: 0.8)
                            .repeatForever(autoreverses: true)
                    ) {
                        pulseScale = 1.3
                    }
                }
            }
            .onChange(of: status) { newStatus in
                if newStatus == .connecting {
                    withAnimation(
                        Animation.easeInOut(duration: 0.8)
                            .repeatForever(autoreverses: true)
                    ) {
                        pulseScale = 1.3
                    }
                } else {
                    withAnimation(.easeOut(duration: 0.3)) {
                        pulseScale = 1.0
                    }
                }
            }
    }

    private var statusColor: Color {
        switch status {
        case .connected:
            return .green
        case .connecting:
            return .orange
        case .disconnected:
            return .red
        case .failed:
            return .red
        }
    }
}

// 进度条动画
struct AnimatedProgressBar: View {
    let progress: Double
    @State private var animatedProgress: Double = 0.0

    var body: some View {
        GeometryReader { geometry in
            ZStack(alignment: .leading) {
                Rectangle()
                    .fill(Color.gray.opacity(0.3))
                    .frame(height: 8)
                    .cornerRadius(4)

                Rectangle()
                    .fill(Color.nearclipPrimary)
                    .frame(width: geometry.size.width * animatedProgress, height: 8)
                    .cornerRadius(4)
            }
        }
        .frame(height: 8)
        .onAppear {
            withAnimation(AnimationConfiguration.easing.standard) {
                animatedProgress = progress
            }
        }
        .onChange(of: progress) { newProgress in
            withAnimation(AnimationConfiguration.easing.standard) {
                animatedProgress = newProgress
            }
        }
    }
}

// 列表项动画
struct AnimatedListItem<Content: View>: View {
    let isVisible: Bool
    let content: Content

    @State private var opacity = 0.0
    @State private var offset: CGFloat = 20

    init(isVisible: Bool, @ViewBuilder content: () -> Content) {
        self.isVisible = isVisible
        self.content = content()
    }

    var body: some View {
        content
            .opacity(opacity)
            .offset(y: offset)
            .onAppear {
                if isVisible {
                    withAnimation(AnimationConfiguration.easing.standard) {
                        opacity = 1.0
                        offset = 0
                    }
                }
            }
            .onChange(of: isVisible) { visible in
                withAnimation(AnimationConfiguration.easing.standard) {
                    opacity = visible ? 1.0 : 0.0
                    offset = visible ? 0 : 20
                }
            }
    }
}

// 页面转场动画
struct PageTransition<Content: View>: View {
    let isActive: Bool
    let content: Content

    init(isActive: Bool, @ViewBuilder content: () -> Content) {
        self.isActive = isActive
        self.content = content()
    }

    var body: some View {
        content
            .scaleEffect(isActive ? 1.0 : 0.8)
            .opacity(isActive ? 1.0 : 0.0)
            .animation(AnimationConfiguration.easing.bouncy, value: isActive)
    }
}

enum ConnectionStatus {
    case connected
    case connecting
    case disconnected
    case failed
}
```

### 6. 性能优化和适配
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/animation/PerformanceOptimizer.kt
import androidx.compose.runtime.*
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.platform.LocalContext

// 动画性能配置
data class AnimationPerformanceConfig(
    val enableComplexAnimations: Boolean = true,
    val maxFrameRate: Int = 60,
    val reduceMotion: Boolean = false,
    val batteryOptimization: Boolean = true
)

// 性能监控器
class AnimationPerformanceMonitor {
    private var frameCount = 0
    private var lastFrameTime = 0L
    private var averageFrameTime = 0L
    private val frameTimes = mutableListOf<Long>()

    fun recordFrame() {
        val currentTime = System.nanoTime()
        if (lastFrameTime > 0) {
            val frameTime = currentTime - lastFrameTime
            frameTimes.add(frameTime)

            // 保持最近100帧的数据
            if (frameTimes.size > 100) {
                frameTimes.removeAt(0)
            }

            averageFrameTime = frameTimes.average().toLong()
        }
        lastFrameTime = currentTime
        frameCount++
    }

    fun getCurrentFPS(): Double {
        return if (averageFrameTime > 0) {
            1_000_000_000.0 / averageFrameTime
        } else {
            60.0
        }
    }

    fun isPerformant(): Boolean {
        return getCurrentFPS() >= 30.0
    }
}

// 自适应动画配置
@Composable
fun rememberAdaptiveAnimationConfig(): AnimationPerformanceConfig {
    val context = LocalContext.current
    val configuration = LocalConfiguration.current

    return remember(context, configuration) {
        val isLowEndDevice = isLowEndDevice(context)
        val isBatteryOptimized = isPowerSaveMode(context)
        val reduceMotion = isReduceMotionEnabled(context)

        AnimationPerformanceConfig(
            enableComplexAnimations = !isLowEndDevice && !isBatteryOptimized,
            maxFrameRate = if (isLowEndDevice) 30 else 60,
            reduceMotion = reduceMotion,
            batteryOptimization = isBatteryOptimized
        )
    }
}

// 检测低端设备
private fun isLowEndDevice(context: Context): Boolean {
    val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
    val memoryInfo = ActivityManager.MemoryInfo()
    activityManager.getMemoryInfo(memoryInfo)

    // 低内存阈值（1GB）
    val lowMemoryThreshold = 1024 * 1024 * 1024L

    return memoryInfo.totalMem < lowMemoryThreshold * 2 // 总内存小于2GB认为是低端设备
}

// 检测省电模式
private fun isPowerSaveMode(context: Context): Boolean {
    val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
    return powerManager.isPowerSaveMode
}

// 检测减少动画设置
private fun isReduceMotionEnabled(context: Context): Boolean {
    return Settings.Global.getFloat(
        context.contentResolver,
        Settings.Global.ANIMATOR_DURATION_SCALE,
        1.0f
    ) == 0.0f
}

// 性能优化的动画组件
@Composable
fun PerformanceOptimizedAnimation(
    config: AnimationPerformanceConfig = rememberAdaptiveAnimationConfig(),
    content: @Composable () -> Unit
) {
    if (config.enableComplexAnimations && !config.reduceMotion) {
        content()
    } else {
        // 简化动画或禁用动画
        content()
    }
}

// 帧率限制的动画
@Composable
fun FrameRateLimitedAnimation(
    targetFPS: Int = 30,
    content: @Composable () -> Unit
) {
    val performanceMonitor = remember { AnimationPerformanceMonitor() }

    LaunchedEffect(Unit) {
        // 监控动画性能
        while (true) {
            withFrame {
                performanceMonitor.recordFrame()

                // 如果帧率过低，动态调整
                if (performanceMonitor.getCurrentFPS() < targetFPS) {
                    // 可以在这里触发降级策略
                }
            }
        }
    }

    content()
}
```

## 测试用例

### 动画测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/animation/AnimationTest.kt
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import org.junit.Rule
import org.junit.Test

class AnimationTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun animatedButton_respondsToClick() {
        var clicked = false

        composeTestRule.setContent {
            AnimatedButton(
                text = "Test Button",
                onClick = { clicked = true }
            )
        }

        composeTestRule
            .onNodeWithText("Test Button")
            .performClick()

        assert(clicked)
    }

    @Test
    fun connectionStatusIndicator_changesColor() {
        composeTestRule.setContent {
            ConnectionStatusIndicator(status = ConnectionStatus.CONNECTED)
        }

        // 验证连接状态指示器显示正确颜色
        composeTestRule
            .onNodeWithContentDescription("Connection status")
            .assertIsDisplayed()
    }
}
```

### SwiftUI动画测试
```swift
// src/platform/mac/NearClip/Animations/Tests/AnimationTests.swift
import XCTest
import SwiftUI
import ViewInspector

final class AnimationTests: XCTestCase {

    func testAnimatedButtonAnimation() throws {
        var buttonTapped = false
        var button = AnimatedButton(
            title: "Test",
            action: { buttonTapped = true }
        )

        // 模拟按钮点击
        try button.inspect().button().tap()
        XCTAssertTrue(buttonTapped)
    }

    func testAnimatedCardExpansion() throws {
        var card = AnimatedCard(
            title: "Test Card",
            subtitle: "Test subtitle"
        )

        // 测试卡片展开状态
        let isExpanded = try card.inspect().isExpanded()
        XCTAssertFalse(isExpanded) // 初始状态应该是收起的
    }
}
```

## 部署要求

### 开发依赖
```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.compose.animation:animation:$compose_version"
    implementation "androidx.compose.animation:animation-graphics:$compose_version"
}
```

### 性能配置
- 最低要求：支持60fps动画的设备
- 推荐配置：支持120fps的高刷新率显示
- 内存要求：动画相关内存占用不超过50MB

## 验收测试计划

### 功能测试
1. **微交互测试**: 验证按钮、开关等微交互动画
2. **转场测试**: 测试页面间转场动画效果
3. **状态动画测试**: 验证状态变化时的动画效果
4. **手势动画测试**: 测试滑动手势等交互动画

### 性能测试
1. **帧率测试**: 确保动画帧率保持在60fps
2. **内存测试**: 监控动画的内存使用情况
3. **电池测试**: 测试动画对电池续航的影响
4. **低端设备测试**: 在低端设备上验证动画降级

### 用户体验测试
1. **流畅度评估**: 用户对动画流畅度的主观评价
2. **易用性测试**: 动画是否提升了用户操作体验
3. **可访问性测试**: 尊重用户的动画偏好设置
4. **疲劳度测试**: 长时间使用是否会感到疲劳

## 风险与缓解

### 性能风险
- **动画卡顿**: 复杂动画可能导致性能问题
  - 缓解: 性能监控，自适应降级，优化算法
- **电池消耗**: 动画可能增加电池消耗
  - 缓解: 省电模式检测，动态调整，用户控制

### 兼容性风险
- **设备差异**: 不同设备的动画性能差异
  - 缓解: 设备检测，性能分级，自适应配置
- **系统版本**: 不同Android版本的动画API差异
  - 缓解: 兼容性处理，版本检查，降级方案

### 用户体验风险
- **动画过多**: 过多动画可能干扰用户
  - 缓解: 用户偏好设置，动画控制，简化选项
- **晕动症**: 某些动画可能导致晕动症
  - 缓解: 减少动画选项，医疗模式，用户控制

## 完成标准
- [ ] 所有微交互动画流畅自然
- [ ] 页面转场动画符合设计规范
- [ ] 状态变化动画准确反映状态
- [ ] 手势交互动画响应及时
- [ ] 动画性能达到60fps目标
- [ ] 支持低端设备的动画降级
- [ ] 尊重用户动画偏好设置
- [ ] 电池优化措施有效
- [ ] 所有平台动画功能测试通过
- [ ] 用户体验测试获得积极反馈