# Story 2.4: 连接状态管理与监控

## Status
Draft

## Story
**作为** 用户，
**我希望** 能够清楚地看到设备连接状态和同步状态，
**以便** 了解设备是否正常工作并及时处理连接问题。

## Acceptance Criteria
1. 实现连接状态的实时监控和显示
2. Mac 端在菜单栏显示连接状态图标
3. Android 端在应用界面显示连接状态
4. 提供连接质量指示（信号强度、延迟等）
5. 实现连接断开检测和自动重连机制

## Tasks / Subtasks
- [ ] 设计连接状态数据模型 (AC: 1)
  - [ ] 定义连接状态枚举和状态转换
  - [ ] 创建连接质量指标结构
  - [ ] 实现状态变更事件系统
  - [ ] 设计状态持久化机制
  - [ ] 创建状态历史记录功能
- [ ] 实现连接状态监控引擎 (AC: 1, 5)
  - [ ] 创建状态监控管理器
  - [ ] 实现心跳检测机制
  - [ ] 添加连接质量评估算法
  - [ ] 实现状态自动更新逻辑
  - [ ] 创建异常状态检测功能
- [ ] 实现 Mac 菜单栏状态显示 (AC: 2, 4)
  - [ ] 创建状态图标组件
  - [ ] 实现动态图标切换
  - [ ] 添加状态详细信息弹窗
  - [ ] 实现连接质量指示器
  - [ ] 创建状态通知系统
- [ ] 实现 Android 界面状态显示 (AC: 3, 4)
  - [ ] 创建状态栏指示器
  - [ ] 实现主界面状态面板
  - [ ] 添加连接质量可视化
  - [ ] 创建设备状态列表
  - [ ] 实现状态更新动画
- [ ] 实现自动重连机制 (AC: 5)
  - [ ] 创建重连策略管理器
  - [ ] 实现指数退避算法
  - [ ] 添加重连限制和超时
  - [ ] 创建重连状态反馈
  - [ ] 实现网络状态感知
- [ ] 实现状态通知和提醒 (AC: 1, 4)
  - [ ] 创建状态变更通知
  - [ ] 实现连接质量警告
  - [ ] 添加设备离线提醒
  - [ ] 创建重连进度提示
  - [ ] 实现状态汇总报告

## Dev Notes

### 连接状态数据模型设计
[Source: architecture/data-models.md]

#### 连接状态定义
```protobuf
// src/shared/protocol/connection_status.proto
syntax = "proto3";

package nearclip.connection;

// 连接状态枚举
enum ConnectionStatus {
  CONNECTION_UNKNOWN = 0;
  CONNECTION_DISCONNECTED = 1;
  CONNECTION_CONNECTING = 2;
  CONNECTION_CONNECTED = 3;
  CONNECTION_PAIRING = 4;
  CONNECTION_SYNCING = 5;
  CONNECTION_ERROR = 6;
  CONNECTION_RECONNECTING = 7;
}

// 连接质量指标
message ConnectionQuality {
  int32 signal_strength = 1;           // 信号强度 (0-100)
  int32 latency_ms = 2;               // 延迟 (毫秒)
  float throughput_kbps = 3;           // 吞吐量 (kbps)
  float packet_loss_rate = 4;          // 丢包率 (0.0-1.0)
  int32 connection_stability = 5;      // 连接稳定性 (0-100)
  int64 last_heartbeat = 6;            // 最后心跳时间戳
  int32 battery_level = 7;             // 设备电量 (0-100)
}

// 设备连接状态
message DeviceConnectionStatus {
  string device_id = 1;
  string device_name = 2;
  ConnectionStatus status = 3;
  ConnectionQuality quality = 4;
  int64 connected_since = 5;           // 连接开始时间
  int64 last_activity = 6;             // 最后活动时间
  int32 reconnect_attempts = 7;        // 重连尝试次数
  string error_message = 8;            // 错误信息
  map<string, string> metadata = 9;    // 扩展元数据
}

// 连接状态更新事件
message ConnectionStatusEvent {
  string device_id = 1;
  ConnectionStatus old_status = 2;
  ConnectionStatus new_status = 3;
  int64 timestamp = 4;
  string reason = 5;                   // 状态变更原因
  ConnectionQuality quality = 6;       // 当前连接质量
}

// 连接统计信息
message ConnectionStatistics {
  int64 total_connections = 1;         // 总连接次数
  int64 successful_connections = 2;    // 成功连接次数
  int64 failed_connections = 3;        // 失败连接次数
  int64 total_uptime_ms = 4;           // 总在线时长
  int64 total_downtime_ms = 5;         // 总离线时长
  float average_signal_strength = 6;    // 平均信号强度
  float average_latency = 7;           // 平均延迟
  int64 last_connected_at = 8;         // 最后连接时间
  int64 last_disconnected_at = 9;      // 最后断开时间
}
```

#### Rust 连接状态管理器
```rust
// src/shared/rust/src/connection/status_manager.rs
use chrono::{DateTime, Utc, Duration};
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::{RwLock, mpsc};
use tokio::time::{interval, sleep};
use serde::{Deserialize, Serialize};
use thiserror::Error;
use log::{info, warn, error};

#[derive(Error, Debug)]
pub enum ConnectionStatusError {
    #[error("Device not found: {0}")]
    DeviceNotFound(String),
    #[error("Invalid status transition: {0} -> {1}")]
    InvalidTransition(ConnectionStatus, ConnectionStatus),
    #[error("Status update timeout")]
    Timeout,
    #[error("Reconnection failed: {0}")]
    ReconnectionFailed(String),
}

#[derive(Debug, Clone, PartialEq, Serialize, Deserialize)]
pub enum ConnectionStatus {
    Disconnected,
    Connecting,
    Connected,
    Pairing,
    Syncing,
    Error(String),
    Reconnecting,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConnectionQuality {
    pub signal_strength: i32,           // 0-100
    pub latency_ms: i32,               // milliseconds
    pub throughput_kbps: f32,           // kilobits per second
    pub packet_loss_rate: f32,          // 0.0-1.0
    pub connection_stability: i32,      // 0-100
    pub last_heartbeat: DateTime<Utc>,
    pub battery_level: Option<i32>,     // 0-100
}

impl Default for ConnectionQuality {
    fn default() -> Self {
        Self {
            signal_strength: 0,
            latency_ms: 0,
            throughput_kbps: 0.0,
            packet_loss_rate: 0.0,
            connection_stability: 0,
            last_heartbeat: Utc::now(),
            battery_level: None,
        }
    }
}

impl ConnectionQuality {
    pub fn overall_score(&self) -> i32 {
        let signal_weight = 0.3;
        let latency_weight = 0.25;
        let stability_weight = 0.25;
        let throughput_weight = 0.2;

        let latency_score = (100 - self.latency_ms.min(1000) / 10).max(0);
        let throughput_score = (self.throughput_kbps.min(1000.0) / 10.0) as i32;
        let packet_loss_score = ((1.0 - self.packet_loss_rate) * 100.0) as i32;

        (self.signal_strength as f32 * signal_weight +
         latency_score as f32 * latency_weight +
         self.connection_stability as f32 * stability_weight +
         throughput_score as f32 * throughput_weight +
         packet_loss_score as f32 * 0.1) as i32
    }

    pub fn quality_level(&self) -> QualityLevel {
        let score = self.overall_score();
        match score {
            90..=100 => QualityLevel::Excellent,
            75..=89 => QualityLevel::Good,
            60..=74 => QualityLevel::Fair,
            40..=59 => QualityLevel::Poor,
            0..=39 => QualityLevel::VeryPoor,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub enum QualityLevel {
    Excellent,
    Good,
    Fair,
    Poor,
    VeryPoor,
}

#[derive(Debug, Clone)]
pub struct DeviceConnectionStatus {
    pub device_id: String,
    pub device_name: String,
    pub status: ConnectionStatus,
    pub quality: ConnectionQuality,
    pub connected_since: Option<DateTime<Utc>>,
    pub last_activity: DateTime<Utc>,
    pub reconnect_attempts: i32,
    pub error_message: Option<String>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct ConnectionStatusEvent {
    pub device_id: String,
    pub old_status: ConnectionStatus,
    pub new_status: ConnectionStatus,
    pub timestamp: DateTime<Utc>,
    pub reason: String,
    pub quality: ConnectionQuality,
}

pub struct ConnectionStatusManager {
    devices: Arc<RwLock<HashMap<String, DeviceConnectionStatus>>>,
    event_sender: mpsc::UnboundedSender<ConnectionStatusEvent>,
    event_receiver: Option<mpsc::UnboundedReceiver<ConnectionStatusEvent>>,
    heartbeat_interval: Duration,
    quality_update_interval: Duration,
    reconnection_config: ReconnectionConfig,
}

#[derive(Debug, Clone)]
pub struct ReconnectionConfig {
    pub max_attempts: i32,
    pub base_delay: Duration,
    pub max_delay: Duration,
    pub backoff_multiplier: f32,
    pub jitter: bool,
}

impl Default for ReconnectionConfig {
    fn default() -> Self {
        Self {
            max_attempts: 5,
            base_delay: Duration::from_secs(1),
            max_delay: Duration::from_secs(30),
            backoff_multiplier: 2.0,
            jitter: true,
        }
    }
}

impl ConnectionStatusManager {
    pub fn new() -> Self {
        let (event_sender, event_receiver) = mpsc::unbounded_channel();

        Self {
            devices: Arc::new(RwLock::new(HashMap::new())),
            event_sender,
            event_receiver: Some(event_receiver),
            heartbeat_interval: Duration::from_secs(5),
            quality_update_interval: Duration::from_secs(2),
            reconnection_config: ReconnectionConfig::default(),
        }
    }

    /// 注册新设备
    pub async fn register_device(&self, device_id: String, device_name: String) -> Result<(), ConnectionStatusError> {
        let mut devices = self.devices.write().await;

        if devices.contains_key(&device_id) {
            return Err(ConnectionStatusError::DeviceNotFound(format!("Device {} already registered", device_id)));
        }

        let status = DeviceConnectionStatus {
            device_id: device_id.clone(),
            device_name,
            status: ConnectionStatus::Disconnected,
            quality: ConnectionQuality::default(),
            connected_since: None,
            last_activity: Utc::now(),
            reconnect_attempts: 0,
            error_message: None,
            metadata: HashMap::new(),
        };

        devices.insert(device_id, status);
        Ok(())
    }

    /// 更新设备连接状态
    pub async fn update_device_status(
        &self,
        device_id: &str,
        new_status: ConnectionStatus,
        reason: Option<String>,
    ) -> Result<(), ConnectionStatusError> {
        let mut devices = self.devices.write().await;
        let device = devices.get_mut(device_id)
            .ok_or_else(|| ConnectionStatusError::DeviceNotFound(device_id.to_string()))?;

        let old_status = device.status.clone();

        // 验证状态转换
        if !self.is_valid_transition(&old_status, &new_status) {
            return Err(ConnectionStatusError::InvalidTransition(old_status, new_status));
        }

        // 更新状态
        let timestamp = Utc::now();
        device.status = new_status.clone();
        device.last_activity = timestamp;

        // 更新连接时间
        match (&old_status, &new_status) {
            (ConnectionStatus::Disconnected, ConnectionStatus::Connected) => {
                device.connected_since = Some(timestamp);
                device.reconnect_attempts = 0;
                device.error_message = None;
            }
            (ConnectionStatus::Connected, ConnectionStatus::Disconnected) => {
                device.connected_since = None;
            }
            (ConnectionStatus::Error(_), ConnectionStatus::Connected) => {
                device.connected_since = Some(timestamp);
                device.reconnect_attempts = 0;
                device.error_message = None;
            }
            _ => {}
        }

        // 发送状态变更事件
        let event = ConnectionStatusEvent {
            device_id: device_id.to_string(),
            old_status,
            new_status,
            timestamp,
            reason: reason.unwrap_or_else(|| "Manual update".to_string()),
            quality: device.quality.clone(),
        };

        drop(devices); // 释放锁
        let _ = self.event_sender.send(event);

        Ok(())
    }

    /// 更新连接质量
    pub async fn update_connection_quality(
        &self,
        device_id: &str,
        quality: ConnectionQuality,
    ) -> Result<(), ConnectionStatusError> {
        let mut devices = self.devices.write().await;
        let device = devices.get_mut(device_id)
            .ok_or_else(|| ConnectionStatusError::DeviceNotFound(device_id.to_string()))?;

        device.quality = quality;
        device.last_activity = Utc::now();

        Ok(())
    }

    /// 获取设备状态
    pub async fn get_device_status(&self, device_id: &str) -> Option<DeviceConnectionStatus> {
        let devices = self.devices.read().await;
        devices.get(device_id).cloned()
    }

    /// 获取所有设备状态
    pub async fn get_all_device_status(&self) -> Vec<DeviceConnectionStatus> {
        let devices = self.devices.read().await;
        devices.values().cloned().collect()
    }

    /// 获取已连接设备
    pub async fn get_connected_devices(&self) -> Vec<DeviceConnectionStatus> {
        let devices = self.devices.read().await;
        devices
            .values()
            .filter(|d| matches!(d.status, ConnectionStatus::Connected | ConnectionStatus::Syncing))
            .cloned()
            .collect()
    }

    /// 启动状态监控
    pub async fn start_monitoring(&self) {
        self.start_heartbeat_monitor().await;
        self.start_quality_monitor().await;
        self.start_auto_reconnection().await;
    }

    /// 心跳监控
    async fn start_heartbeat_monitor(&self) {
        let devices = self.devices.clone();
        let interval = self.heartbeat_interval;
        let event_sender = self.event_sender.clone();

        tokio::spawn(async move {
            let mut heartbeat_timer = interval(interval);

            loop {
                heartbeat_timer.tick().await;

                let mut devices_lock = devices.write().await;
                let now = Utc::now();

                for (device_id, device) in devices_lock.iter_mut() {
                    // 检查心跳超时
                    if now.signed_duration_since(device.quality.last_heartbeat) > Duration::from_secs(15) {
                        if matches!(device.status, ConnectionStatus::Connected | ConnectionStatus::Syncing) {
                            let old_status = device.status.clone();
                            device.status = ConnectionStatus::Error("Heartbeat timeout".to_string());
                            device.error_message = Some("Heartbeat timeout".to_string());

                            let event = ConnectionStatusEvent {
                                device_id: device_id.clone(),
                                old_status,
                                new_status: ConnectionStatus::Error("Heartbeat timeout".to_string()),
                                timestamp: now,
                                reason: "Heartbeat timeout".to_string(),
                                quality: device.quality.clone(),
                            };

                            let _ = event_sender.send(event);
                        }
                    }
                }
            }
        });
    }

    /// 连接质量监控
    async fn start_quality_monitor(&self) {
        let devices = self.devices.clone();
        let interval = self.quality_update_interval;

        tokio::spawn(async move {
            let mut quality_timer = interval(interval);

            loop {
                quality_timer.tick().await;

                let mut devices_lock = devices.write().await;
                let now = Utc::now();

                for device in devices_lock.values_mut() {
                    if matches!(device.status, ConnectionStatus::Connected | ConnectionStatus::Syncing) {
                        // 更新连接稳定性
                        let uptime = device.connected_since
                            .map(|t| now.signed_duration_since(t).num_seconds())
                            .unwrap_or(0);

                        device.quality.connection_stability = if uptime > 300 {
                            // 5分钟后开始计算稳定性
                            ((uptime as f32 / 300.0).min(10.0) * 10.0) as i32
                        } else {
                            device.quality.connection_stability
                        };

                        // 模拟信号强度波动（实际应该从硬件获取）
                        device.quality.signal_strength = (device.quality.signal_strength +
                            (rand::random::<i32>() % 10 - 5)).clamp(0, 100);
                    }
                }
            }
        });
    }

    /// 自动重连机制
    async fn start_auto_reconnection(&self) {
        let devices = self.devices.clone();
        let config = self.reconnection_config.clone();

        tokio::spawn(async move {
            let mut reconnection_timer = interval(Duration::from_secs(10));

            loop {
                reconnection_timer.tick().await;

                let mut devices_lock = devices.write().await;

                for (device_id, device) in devices_lock.iter_mut() {
                    if should_attempt_reconnection(device, &config) {
                        device.status = ConnectionStatus::Reconnecting;
                        device.reconnect_attempts += 1;

                        // 启动重连任务
                        let device_id_clone = device_id.clone();
                        let config_clone = config.clone();

                        tokio::spawn(async move {
                            attempt_reconnection(&device_id_clone, &config_clone).await;
                        });
                    }
                }
            }
        });
    }

    /// 获取事件接收器
    pub fn take_event_receiver(&mut self) -> Option<mpsc::UnboundedReceiver<ConnectionStatusEvent>> {
        self.event_receiver.take()
    }

    /// 验证状态转换
    fn is_valid_transition(&self, from: &ConnectionStatus, to: &ConnectionStatus) -> bool {
        use ConnectionStatus::*;

        match (from, to) {
            // 允许的转换
            (Disconnected, Connecting) => true,
            (Connecting, Connected) => true,
            (Connecting, Pairing) => true,
            (Connecting, Error(_)) => true,
            (Pairing, Connected) => true,
            (Pairing, Error(_)) => true,
            (Connected, Syncing) => true,
            (Syncing, Connected) => true,
            (Connected, Disconnected) => true,
            (Syncing, Disconnected) => true,
            (Connected, Error(_)) => true,
            (Syncing, Error(_)) => true,
            (Error(_), Connecting) => true,
            (Error(_), Disconnected) => true,
            (Reconnecting, Connected) => true,
            (Reconnecting, Error(_)) => true,
            (Reconnecting, Disconnected) => true,

            // 相同状态
            (s1, s2) if s1 == s2 => true,

            // 其他转换不允许
            _ => false,
        }
    }
}

/// 判断是否应该尝试重连
fn should_attempt_reconnection(device: &DeviceConnectionStatus, config: &ReconnectionConfig) -> bool {
    if device.reconnect_attempts >= config.max_attempts {
        return false;
    }

    matches!(device.status, ConnectionStatus::Disconnected | ConnectionStatus::Error(_))
}

/// 执行重连
async fn attempt_reconnection(device_id: &str, config: &ReconnectionConfig) {
    info!("Attempting to reconnect to device: {}", device_id);

    // 计算延迟时间
    let delay = calculate_reconnection_delay(config);
    sleep(delay).await;

    // 这里应该调用实际的重连逻辑
    // 暂时模拟重连过程
    info!("Reconnection attempt for device: {}", device_id);

    // 实际实现中，这里会调用 BLE 连接逻辑
}

/// 计算重连延迟
fn calculate_reconnection_delay(config: &ReconnectionConfig) -> Duration {
    let base_delay_ms = config.base_delay.as_millis() as f32;
    let max_delay_ms = config.max_delay.as_millis() as f32;

    let delay = base_delay_ms * config.backoff_multiplier.powi(2); // 指数退避

    let mut delay = delay.min(max_delay_ms);

    // 添加抖动
    if config.jitter {
        let jitter_factor = 0.8 + (rand::random::<f32>() * 0.4); // 0.8-1.2
        delay *= jitter_factor;
    }

    Duration::from_millis(delay as u64)
}
```

### Android 连接状态界面

#### ConnectionStatusScreen
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/screens/ConnectionStatusScreen.kt
package com.nearclip.ui.screens

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.foundation.shape.CircleShape
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.nearclip.ui.viewmodel.ConnectionStatusViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun ConnectionStatusScreen(
    onNavigateBack: () -> Unit,
    onDeviceClick: (String) -> Unit,
    viewModel: ConnectionStatusViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    LaunchedEffect(Unit) {
        viewModel.startMonitoring()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("连接状态") },
                navigationIcon = {
                    IconButton(onClick = onNavigateBack) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "返回")
                    }
                },
                actions = {
                    IconButton(onClick = { viewModel.refreshStatus() }) {
                        Icon(Icons.Default.Refresh, contentDescription = "刷新")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // 连接概览
            ConnectionOverview(
                totalDevices = uiState.totalDevices,
                connectedDevices = uiState.connectedDevices,
                overallQuality = uiState.overallQuality,
                modifier = Modifier.fillMaxWidth()
            )

            Divider()

            // 设备列表
            DeviceList(
                devices = uiState.devices,
                onDeviceClick = onDeviceClick,
                modifier = Modifier.fillMaxSize()
            )
        }
    }
}

@Composable
private fun ConnectionOverview(
    totalDevices: Int,
    connectedDevices: Int,
    overallQuality: ConnectionQuality,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.padding(16.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(20.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Column {
                    Text(
                        text = "连接概览",
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Medium
                    )
                    Text(
                        text = "$connectedDevices / $totalDevices 设备已连接",
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }

                OverallQualityIndicator(quality = overallQuality)
            }

            // 连接质量指标
            ConnectionQualityMetrics(quality = overallQuality)
        }
    }
}

@Composable
private fun OverallQualityIndicator(
    quality: ConnectionQuality,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier,
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(4.dp)
    ) {
        Box(
            modifier = Modifier
                .size(48.dp)
                .clip(CircleShape)
                .background(quality.color.copy(alpha = 0.2f)),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = quality.icon,
                contentDescription = null,
                tint = quality.color,
                modifier = Modifier.size(24.dp)
            )
        }

        Text(
            text = quality.level.displayName,
            style = MaterialTheme.typography.labelMedium,
            color = quality.color,
            fontWeight = FontWeight.Medium
        )
    }
}

@Composable
private fun ConnectionQualityMetrics(
    quality: ConnectionQuality,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier,
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        QualityMetricRow(
            icon = Icons.Default.Wifi,
            label = "信号强度",
            value = "${quality.signalStrength}%",
            progress = quality.signalStrength / 100f,
            color = getSignalStrengthColor(quality.signalStrength)
        )

        QualityMetricRow(
            icon = Icons.Default.Speed,
            label = "延迟",
            value = "${quality.latencyMs}ms",
            progress = (100 - quality.latencyMs.coerceIn(0, 1000) / 10).toFloat() / 100f,
            color = getLatencyColor(quality.latencyMs)
        )

        QualityMetricRow(
            icon = Icons.Default.Sync,
            label = "稳定性",
            value = "${quality.connectionStability}%",
            progress = quality.connectionStability / 100f,
            color = getStabilityColor(quality.connectionStability)
        )

        if (quality.batteryLevel != null) {
            QualityMetricRow(
                icon = Icons.Default.BatteryFull,
                label = "电量",
                value = "${quality.batteryLevel}%",
                progress = quality.batteryLevel!! / 100f,
                color = getBatteryColor(quality.batteryLevel!!)
            )
        }
    }
}

@Composable
private fun QualityMetricRow(
    icon: ImageVector,
    label: String,
    value: String,
    progress: Float,
    color: Color,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            modifier = Modifier.size(20.dp),
            tint = color
        )

        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = label,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )

            LinearProgressIndicator(
                progress = progress,
                modifier = Modifier
                    .fillMaxWidth()
                    .height(4.dp)
                    .clip(RoundedCornerShape(2.dp)),
                color = color,
                trackColor = color.copy(alpha = 0.2f)
            )
        }

        Text(
            text = value,
            style = MaterialTheme.typography.bodySmall,
            color = color,
            fontWeight = FontWeight.Medium,
            modifier = Modifier.widthIn(min = 50.dp)
        )
    }
}

@Composable
private fun DeviceList(
    devices: List<DeviceConnectionStatus>,
    onDeviceClick: (String) -> Unit,
    modifier: Modifier = Modifier
) {
    LazyColumn(
        modifier = modifier,
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(8.dp)
    ) {
        items(devices) { device ->
            DeviceConnectionCard(
                device = device,
                onClick = { onDeviceClick(device.deviceId) }
            )
        }
    }
}

@Composable
private fun DeviceConnectionCard(
    device: DeviceConnectionStatus,
    onClick: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier
            .fillMaxWidth()
            .clickable { onClick() },
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // 状态指示器
            StatusIndicator(
                status = device.status,
                quality = device.quality
            )

            // 设备信息
            Column(
                modifier = Modifier.weight(1f),
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    horizontalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Text(
                        text = device.deviceName,
                        style = MaterialTheme.typography.titleMedium,
                        fontWeight = FontWeight.Medium
                    )

                    StatusBadge(status = device.status)
                }

                Text(
                    text = formatConnectionDuration(device.connectedSince),
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                if (device.errorMessage != null) {
                    Text(
                        text = device.errorMessage!!,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.error
                    )
                }
            }

            // 质量指标
            Column(
                horizontalAlignment = Alignment.End,
                verticalArrangement = Arrangement.spacedBy(4.dp)
            ) {
                Text(
                    text = "${device.quality.signalStrength}%",
                    style = MaterialTheme.typography.bodySmall,
                    color = getSignalStrengthColor(device.quality.signalStrength)
                )

                Text(
                    text = "${device.quality.latencyMs}ms",
                    style = MaterialTheme.typography.bodySmall,
                    color = getLatencyColor(device.quality.latencyMs)
                )
            }
        }
    }
}

@Composable
private fun StatusIndicator(
    status: ConnectionStatus,
    quality: ConnectionQuality,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .size(40.dp)
            .clip(CircleShape)
            .background(status.color.copy(alpha = 0.2f)),
        contentAlignment = Alignment.Center
    ) {
        Icon(
            imageVector = status.icon,
            contentDescription = null,
            tint = status.color,
            modifier = Modifier.size(20.dp)
        )
    }
}

@Composable
private fun StatusBadge(
    status: ConnectionStatus,
    modifier: Modifier = Modifier
) {
    Surface(
        modifier = modifier,
        color = status.color.copy(alpha = 0.2f),
        shape = RoundedCornerShape(4.dp)
    ) {
        Text(
            text = status.displayName,
            style = MaterialTheme.typography.labelSmall,
            color = status.color,
            fontWeight = FontWeight.Medium,
            modifier = Modifier.padding(horizontal = 6.dp, vertical = 2.dp)
        )
    }
}

// 辅助函数
private fun formatConnectionDuration(connectedSince: Long?): String {
    val now = System.currentTimeMillis()
    val connected = connectedSince ?: return "未连接"
    val duration = now - connected

    val hours = duration / (1000 * 60 * 60)
    val minutes = (duration % (1000 * 60 * 60)) / (1000 * 60)

    return when {
        hours > 0 -> "${hours}小时${minutes}分钟"
        minutes > 0 -> "${minutes}分钟"
        else -> "刚刚连接"
    }
}

private fun getSignalStrengthColor(strength: Int): Color {
    return when {
        strength >= 80 -> Color(0xFF4CAF50)
        strength >= 60 -> Color(0xFF8BC34A)
        strength >= 40 -> Color(0xFFFFC107)
        strength >= 20 -> Color(0xFFFF9800)
        else -> Color(0xFFF44336)
    }
}

private fun getLatencyColor(latency: Int): Color {
    return when {
        latency <= 50 -> Color(0xFF4CAF50)
        latency <= 100 -> Color(0xFF8BC34A)
        latency <= 200 -> Color(0xFFFFC107)
        latency <= 500 -> Color(0xFFFF9800)
        else -> Color(0xFFF44336)
    }
}

private fun getStabilityColor(stability: Int): Color {
    return when {
        stability >= 90 -> Color(0xFF4CAF50)
        stability >= 75 -> Color(0xFF8BC34A)
        stability >= 60 -> Color(0xFFFFC107)
        stability >= 40 -> Color(0xFFFF9800)
        else -> Color(0xFFF44336)
    }
}

private fun getBatteryColor(level: Int): Color {
    return when {
        level >= 60 -> Color(0xFF4CAF50)
        level >= 30 -> Color(0xFFFFC107)
        else -> Color(0xFFF44336)
    }
}
```

### Mac 连接状态界面

#### SwiftUI ConnectionStatusView
```swift
// src/platform/mac/NearClip/Sources/Views/ConnectionStatusView.swift
import SwiftUI

struct ConnectionStatusView: View {
    @ObservedObject var connectionManager: ConnectionManager
    @State private var selectedDevice: DeviceConnectionStatus?

    var body: some View {
        VStack(spacing: 0) {
            // Header
            headerView

            Divider()

            // Overview
            overviewView

            Divider()

            // Device List
            deviceListView

            Spacer()
        }
        .frame(width: 380, height: 500)
        .onAppear {
            connectionManager.startMonitoring()
        }
        .sheet(item: $selectedDevice) { device in
            DeviceDetailView(device: device)
        }
    }

    private var headerView: some View {
        HStack {
            Text("连接状态")
                .font(.title2)
                .fontWeight(.semibold)

            Spacer()

            Button(action: connectionManager.refreshStatus) {
                Image(systemName: "arrow.clockwise")
            }
            .buttonStyle(BorderlessButtonStyle())
        }
        .padding(.horizontal, 20)
        .padding(.vertical, 12)
    }

    private var overviewView: some View {
        VStack(spacing: 16) {
            // Connection Summary
            HStack {
                VStack(alignment: .leading, spacing: 4) {
                    Text("连接设备")
                        .font(.headline)
                        .fontWeight(.medium)

                    Text("\(connectionManager.connectedDevices.count) / \(connectionManager.totalDevices) 已连接")
                        .font(.subheadline)
                        .foregroundColor(.secondary)
                }

                Spacer()

                OverallQualityView(quality: connectionManager.overallQuality)
            }

            // Quality Metrics
            if connectionManager.connectedDevices.count > 0 {
                QualityMetricsView(quality: connectionManager.overallQuality)
            }
        }
        .padding(20)
    }

    private var deviceListView: some View {
        ScrollView {
            LazyVStack(spacing: 8) {
                ForEach(connectionManager.devices, id: \.deviceId) { device in
                    DeviceConnectionCard(
                        device: device,
                        onClick: { selectedDevice = device }
                    )
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 8)
        }
    }
}

struct OverallQualityView: View {
    let quality: ConnectionQuality

    var body: some View {
        VStack(spacing: 8) {
            ZStack {
                Circle()
                    .fill(quality.color.opacity(0.2))
                    .frame(width: 50, height: 50)

                Image(systemName: quality.iconName)
                    .font(.system(size: 24))
                    .foregroundColor(quality.color)
            }

            Text(quality.level.displayName)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(quality.color)
        }
    }
}

struct QualityMetricsView: View {
    let quality: ConnectionQuality

    var body: some View {
        VStack(spacing: 12) {
            QualityMetricRow(
                icon: "wifi",
                label: "信号强度",
                value: "\(quality.signalStrength)%",
                progress: Double(quality.signalStrength) / 100.0,
                color: getSignalStrengthColor(quality.signalStrength)
            )

            QualityMetricRow(
                icon: "speedometer",
                label: "延迟",
                value: "\(quality.latencyMs)ms",
                progress: Double(max(0, 100 - quality.latencyMs / 10)) / 100.0,
                color: getLatencyColor(quality.latencyMs)
            )

            QualityMetricRow(
                icon: "waveform.path.ecg",
                label: "稳定性",
                value: "\(quality.connectionStability)%",
                progress: Double(quality.connectionStability) / 100.0,
                color: getStabilityColor(quality.connectionStability)
            )

            if let batteryLevel = quality.batteryLevel {
                QualityMetricRow(
                    icon: "battery.100",
                    label: "电量",
                    value: "\(batteryLevel)%",
                    progress: Double(batteryLevel) / 100.0,
                    color: getBatteryColor(batteryLevel)
                )
            }
        }
    }
}

struct QualityMetricRow: View {
    let icon: String
    let label: String
    let value: String
    let progress: Double
    let color: Color

    var body: some View {
        HStack(alignment: .center, spacing: 12) {
            Image(systemName: icon)
                .font(.system(size: 16))
                .foregroundColor(color)
                .frame(width: 20)

            VStack(alignment: .leading, spacing: 2) {
                Text(label)
                    .font(.caption)
                    .foregroundColor(.secondary)

                ProgressView(value: progress)
                    .progressViewStyle(LinearProgressViewStyle(tint: color))
                    .scaleEffect(y: 0.5)
            }

            Text(value)
                .font(.caption)
                .fontWeight(.medium)
                .foregroundColor(color)
                .frame(width: 50, alignment: .trailing)
        }
    }
}

struct DeviceConnectionCard: View {
    let device: DeviceConnectionStatus
    let onClick: () -> Void

    var body: some View {
        Button(action: onClick) {
            HStack(spacing: 16) {
                // Status Indicator
                StatusIndicatorView(status: device.status, quality: device.quality)

                // Device Info
                VStack(alignment: .leading, spacing: 4) {
                    HStack {
                        Text(device.deviceName)
                            .font(.subheadline)
                            .fontWeight(.medium)

                        StatusBadgeView(status: device.status)
                    }

                    Text(formatConnectionDuration(device.connectedSince))
                        .font(.caption)
                        .foregroundColor(.secondary)

                    if let errorMessage = device.errorMessage {
                        Text(errorMessage)
                            .font(.caption)
                            .foregroundColor(.red)
                    }
                }

                Spacer()

                // Quick Stats
                VStack(alignment: .trailing, spacing: 2) {
                    Text("\(device.quality.signalStrength)%")
                        .font(.caption)
                        .foregroundColor(getSignalStrengthColor(device.quality.signalStrength))

                    Text("\(device.quality.latencyMs)ms")
                        .font(.caption)
                        .foregroundColor(getLatencyColor(device.quality.latencyMs))
                }
            }
            .padding(.horizontal, 16)
            .padding(.vertical, 12)
            .background(Color(NSColor.controlBackgroundColor))
            .cornerRadius(8)
        }
        .buttonStyle(PlainButtonStyle())
        .cursor(.pointingHand)
    }
}

struct StatusIndicatorView: View {
    let status: ConnectionStatus
    let quality: ConnectionQuality

    var body: some View {
        ZStack {
            Circle()
                .fill(status.color.opacity(0.2))
                .frame(width: 32, height: 32)

            Image(systemName: status.iconName)
                .font(.system(size: 16))
                .foregroundColor(status.color)
        }
    }
}

struct StatusBadgeView: View {
    let status: ConnectionStatus

    var body: some View {
        Text(status.displayName)
            .font(.caption2)
            .fontWeight(.medium)
            .padding(.horizontal, 6)
            .padding(.vertical, 2)
            .background(status.color.opacity(0.2))
            .foregroundColor(status.color)
            .cornerRadius(4)
    }
}

struct DeviceDetailView: View {
    let device: DeviceConnectionStatus
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Text(device.deviceName)
                    .font(.title2)
                    .fontWeight(.semibold)

                Spacer()

                Button("完成") {
                    dismiss()
                }
            }
            .padding()

            Divider()

            // Content
            ScrollView {
                VStack(spacing: 20) {
                    // Status Section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("连接状态")
                            .font(.headline)
                            .fontWeight(.medium)

                        HStack {
                            StatusIndicatorView(status: device.status, quality: device.quality)
                            VStack(alignment: .leading) {
                                Text(device.status.displayName)
                                    .font(.subheadline)
                                    .fontWeight(.medium)
                                Text(formatConnectionDuration(device.connectedSince))
                                    .font(.caption)
                                    .foregroundColor(.secondary)
                            }
                            Spacer()
                        }
                    }

                    // Quality Section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("连接质量")
                            .font(.headline)
                            .fontWeight(.medium)

                        QualityMetricsView(quality: device.quality)
                    }

                    // Details Section
                    VStack(alignment: .leading, spacing: 12) {
                        Text("详细信息")
                            .font(.headline)
                            .fontWeight(.medium)

                        VStack(spacing: 8) {
                            DetailRow(label: "设备ID", value: String(device.deviceId.suffix(8)))
                            DetailRow(label: "连接时间", value: formatDate(device.connectedSince))
                            DetailRow(label: "最后活动", value: formatDate(device.lastActivity))
                            DetailRow(label: "重连次数", value: "\(device.reconnectAttempts)")

                            if let errorMessage = device.errorMessage {
                                DetailRow(label: "错误信息", value: errorMessage)
                            }
                        }
                    }
                }
                .padding()
            }

            Spacer()
        }
        .frame(width: 400, height: 500)
    }
}

struct DetailRow: View {
    let label: String
    let value: String

    var body: some View {
        HStack {
            Text(label)
                .font(.subheadline)
                .foregroundColor(.secondary)
                .frame(width: 80, alignment: .leading)

            Text(value)
                .font(.subheadline)
                .fontWeight(.medium)

            Spacer()
        }
        .padding(.vertical, 4)
    }
}

// 辅助函数
private func formatConnectionDuration(_ connectedSince: Date?) -> String {
    guard let connectedSince = connectedSince else {
        return "未连接"
    }

    let now = Date()
    let duration = now.timeIntervalSince(connectedSince)

    let hours = Int(duration) / 3600
    let minutes = (Int(duration) % 3600) / 60

    if hours > 0 {
        return "\(hours)小时\(minutes)分钟"
    } else if minutes > 0 {
        return "\(minutes)分钟"
    } else {
        return "刚刚连接"
    }
}

private func formatDate(_ date: Date?) -> String {
    guard let date = date else {
        return "未知"
    }

    let formatter = DateFormatter()
    formatter.dateStyle = .medium
    formatter.timeStyle = .short
    return formatter.string(from: date)
}

// 颜色函数
private func getSignalStrengthColor(_ strength: Int) -> Color {
    switch strength {
    case 80...100:
        return .green
    case 60..<80:
        return .mint
    case 40..<60:
        return .yellow
    case 20..<40:
        return .orange
    default:
        return .red
    }
}

private func getLatencyColor(_ latency: Int) -> Color {
    switch latency {
    case 0...50:
        return .green
    case 51...100:
        return .mint
    case 101...200:
        return .yellow
    case 201...500:
        return .orange
    default:
        return .red
    }
}

private func getStabilityColor(_ stability: Int) -> Color {
    switch stability {
    case 90...100:
        return .green
    case 75..<90:
        return .mint
    case 60..<75:
        return .yellow
    case 40..<60:
        return .orange
    default:
        return .red
    }
}

private func getBatteryColor(_ level: Int) -> Color {
    switch level {
    case 60...100:
        return .green
    case 30..<60:
        return .yellow
    default:
        return .red
    }
}

#Preview {
    ConnectionStatusView(connectionManager: ConnectionManager.preview)
}
```

### 菜单栏状态指示器

#### Mac MenuBarStatusItem
```swift
// src/platform/mac/NearClip/Sources/Views/MenuBarStatusItem.swift
import SwiftUI
import AppKit

struct MenuBarStatusItem: View {
    @ObservedObject var connectionManager: ConnectionManager
    @State private var isHovered = false

    var body: some View {
        HStack(spacing: 4) {
            // Status Icon
            Image(systemName: statusIconName)
                .font(.system(size: 14, weight: .medium))
                .foregroundColor(statusColor)

            // Connected Device Count
            if connectionManager.connectedDevices.count > 0 {
                Text("\(connectionManager.connectedDevices.count)")
                    .font(.caption)
                    .fontWeight(.medium)
                    .foregroundColor(statusColor)
            }
        }
        .padding(.horizontal, 8)
        .padding(.vertical, 4)
        .background(
            RoundedRectangle(cornerRadius: 6)
                .fill(Color(NSColor.controlBackgroundColor).opacity(isHovered ? 0.8 : 0.6))
        )
        .onHover { hovering in
            isHovered = hovering
        }
        .help(statusTooltip)
    }

    private var statusIconName: String {
        switch connectionManager.overallStatus {
        case .connected:
            return "wifi"
        case .connecting:
            return "wifi.exclamationmark"
        case .disconnected:
            return "wifi.slash"
        case .error:
            return "xmark.circle"
        }
    }

    private var statusColor: Color {
        switch connectionManager.overallStatus {
        case .connected:
            return .green
        case .connecting:
            return .orange
        case .disconnected:
            return .gray
        case .error:
            return .red
        }
    }

    private var statusTooltip: String {
        let deviceCount = connectionManager.connectedDevices.count
        let totalCount = connectionManager.totalDevices

        if deviceCount == 0 {
            return "NearClip - 未连接设备"
        } else if deviceCount == totalCount {
            return "NearClip - 所有设备已连接"
        } else {
            return "NearClip - \(deviceCount)/\(totalCount) 设备已连接"
        }
    }
}

// Menu Bar Manager
class MenuBarManager: ObservableObject {
    private var statusItem: NSStatusItem!
    private var popover: NSPopover!
    @Published var connectionManager: ConnectionManager

    init() {
        self.connectionManager = ConnectionManager.preview // 在实际应用中应该注入
        setupMenuBar()
        setupPopover()
    }

    private func setupMenuBar() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.squareLength)

        if let button = statusItem.button {
            button.action = #selector(statusBarButtonClicked)
            button.target = self
        }

        updateStatusItem()
    }

    private func setupPopover() {
        popover = NSPopover()
        popover.contentSize = NSSize(width: 380, height: 500)
        popover.behavior = .transient
        popover.contentViewController = NSHostingController(
            rootView: ConnectionStatusView(connectionManager: connectionManager)
        )
    }

    @objc private func statusBarButtonClicked() {
        if let button = statusItem.button {
            if popover.isShown {
                popover.performClose(nil)
            } else {
                popover.show(relativeTo: button.bounds, of: button, preferredEdge: .minY)
                button.keyDown(with: NSEvent(keyEvent: .init())
            }
        }
    }

    private func updateStatusItem() {
        if let button = statusItem.button {
            let statusView = NSHostingView(
                rootView: MenuBarStatusItem(connectionManager: connectionManager)
            )
            statusView.frame = NSRect(x: 0, y: 0, width: 60, height: 20)
            button.subviews.forEach { $0.removeFromSuperview() }
            button.addSubview(statusView)
        }
    }
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | 初始故事创建，添加连接状态管理与监控 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写