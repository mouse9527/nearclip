# Story 1.3: Mac 基础应用框架搭建

## Status
Ready

## Story
**作为** 开发者，
**我希望** 搭建 Mac 应用的基础框架，包含 SwiftUI、菜单栏集成和 FFI 集成层，
**以便** 为后续功能开发提供符合 macOS 用户体验的应用基础，并能够与 Rust 共享逻辑库进行通信。

## Acceptance Criteria
1. 创建新的 macOS 项目，使用 Swift + SwiftUI
2. 实现菜单栏图标和基础状态显示
3. 建立基础的窗口结构和导航
4. 配置必要的系统权限和访问请求
5. 实现基础的应用生命周期管理
6. 创建 Rust FFI 集成层，为调用共享逻辑库做准备

## Tasks / Subtasks
- [ ] 创建 macOS 项目基础结构 (AC: 1)
  - [ ] 设置 src/platform/mac/NearClip/ 目录结构
  [ ] 创建 Package.swift 配置文件
  [ ] 配置 Xcode 项目设置
  [ ] 创建 Info.plist 基础配置
  [ ] 设置应用签名和证书
- [ ] 实现菜单栏集成 (AC: 2)
  [ ] 创建菜单栏状态图标 (NSStatusItem)
  - [ ] 实现连接状态指示器
  [   - 未连接状态 (灰色图标)
  [   - 连接中状态 (蓝色图标)
  [   - 已连接状态 (绿色图标)
  - [ 创建菜单栏弹出菜单
  - [ ] 实现快速操作按钮
  - [ ] 设置图标切换动画
- [ ] 建立窗口和导航结构 (AC: 3)
  [ ] 创建主窗口 (NSWindow)
  [ ] 实现 SwiftUI 导航视图
  [ ] 创建主要页面组件
  - [ ] 设备发现页面
  - [ ] 设备管理页面
  - [ ] 设置页面
  [ ] 设置页面间导航
  [ ] 实现窗口状态管理
- [ ] 配置系统权限 (AC: 4)
  [ ] 配置蓝牙访问权限
  [ ] 配置粘贴板访问权限
  [ ] 实现权限请求逻辑
  [ ] 创建权限检查工具类
  [ ] 处理权限拒绝情况
  [ ] 设置应用沙箱配置
- [ ] 实现应用生命周期管理 (AC: 5)
  [ ] 创建 AppDelegate 生命周期管理
  [ ] 实现应用启动和退出逻辑
  [ ] 处理应用进入后台/前台
  [ ] 实现状态保存和恢复
  [ ] 设置应用退出清理逻辑
- [ ] 创建 Rust FFI 集成层 (AC: 6)
  [ ] 创建 NearClipManager 类
  [ ] 加载 Rust 共享库
  [ ] 创建 C ABI 函数声明
  [ ] 实现 FFI 安全封装
  [ ] 创建设备发现和数据同步接口
  [ ] 设置 Swift 异步回调处理

## Dev Notes

### macOS 项目结构
根据统一项目结构文档 [Source: architecture/unified-project-structure.md]，Mac 应用位于：

```
src/platform/mac/
├── NearClip/
│   ├── Sources/
│   │   ├── App/
│   │   │   ├── ContentView.swift
│   │   │   └── NearClipApp.swift
│   │   ├── Services/              # Rust FFI 调用层
│   │   │   ├── NearClipManager.swift
│   │   │   ├── ClipboardMonitor.swift
│   │   │   └── MenuBarManager.swift
│   │   ├── Views/                 # UI 组件
│   │   │   ├── DeviceDiscoveryView.swift
│   │   │   ├── DeviceManagementView.swift
│   │   │   ├── SettingsView.swift
│   │   │   └── Components/
│   │   │       ├── DeviceCard.swift
│   │   │       ├── StatusIndicator.swift
│   │   │       └── SyncProgressBar.swift
│   │   ├── Models/                # 数据模型
│   │   │   ├── Device.swift
│   │   │   ├── SyncRecord.swift
│   │   │   └── AppState.swift
│   │   └── Utils/                 # 工具类
│   │       ├── Logger.swift
│   │       └── Extensions.swift
│   ├── Tests/
│   │   ├── NearClipTests/
│   │   │   ├── ServicesTests/
│   │   │   ├── ViewsTests/
│   │   │   └── IntegrationTests/
│   │   └── UITests/
│   │       └── NearClipUITests/
│   └── Package.swift
└── NearClip.xcodeproj/
```

### 技术栈信息
[Source: architecture/tech-stack.md]
- **Mac 语言**: Swift 5.9
- **Mac 框架**: SwiftUI 5.0
- **UI 组件库**: 原生 macOS 组件
- **FFI 接口**: C ABI (Swift ↔ Rust 通信)
- **状态管理**: SwiftUI + Combine
- **缓存**: Core Data
- **测试**: XCTest

### Rust FFI 集成架构
[Source: architecture/api-specification.md]

#### Swift C ABI 接口
```swift
import Foundation

// Rust 函数声明
@_silgen_name("nearclip_start_discovery")
func nearclip_start_discovery(_ callback: @convention(c) (UnsafePointer<NearclipDevice>) -> Void) -> NearclipResult

@_silgen_name("nearclip_connect_to_device")
func nearclip_connect_to_device(_ deviceId: UnsafePointer<Int8>) -> NearclipResult

@_silgen_name("nearclip_send_sync_message")
func nearclip_send_sync_message(_ deviceId: UnsafePointer<Int8>, content: UnsafePointer<Int8>, length: Int) -> NearclipResult

@_silgen_name("nearclip_set_sync_callback")
func nearclip_set_sync_callback(_ callback: @convention(c) (UnsafePointer<Int8>, UnsafePointer<Int8>, Int32) -> Void) -> NearclipResult
```

#### FFI 安全封装
```swift
class NearClipManager: ObservableObject {
    private var deviceCallback: ((Device) -> Void)?
    private var syncCallback: ((String, Data) -> Void)?

    func startDeviceDiscovery(callback: @escaping (Device) -> Void) throws {
        self.deviceCallback = callback

        let result = nearclip_start_discovery { [weak self] cDevice in
            guard let self = self else { return }
            let device = self.convertCDevice(cDevice)
            DispatchQueue.main.async {
                callback(device)
            }
        }

        guard result == .success else {
            throw NearclipError.connectionFailed("Failed to start discovery")
        }
    }

    private func convertCDevice(_ cDevice: UnsafePointer<NearclipDevice>) -> Device {
        let deviceId = String(cString: cDevice.pointee.deviceId)
        let deviceName = String(cString: cDevice.pointee.deviceName)
        let deviceType = DeviceType(rawValue: String(cString: cDevice.pointee.deviceType.rawValue)) ?? .unknown

        return Device(
            id: deviceId,
            name: deviceName,
            type: deviceType,
            connectionStatus: cDevice.pointee.isConnected ? .connected : .disconnected,
            lastSeen: Date(timeIntervalSince1970: cDevice.pointee.lastSeen),
            batteryLevel: cDevice.pointee.batteryLevel != 0 ? Int(cDevice.pointee.batteryLevel) : nil
        )
    }
}
```

### 菜单栏集成设计
[Source: architecture/components.md]

#### MenuBarManager
```swift
import SwiftUI

class MenuBarManager: ObservableObject {
    @Published var connectionStatus: ConnectionStatus = .disconnected
    @Published var isMonitoring: Bool = false
    @Published var deviceCount: Int = 0

    private var statusItem: NSStatusItem!
    private var popover: NSPopover!
    private var contentView: ContentView!

    init() {
        setupMenuBar()
    }

    private func setupMenuBar() {
        statusItem = NSStatusBar.system.statusItem(withLength: NSStatusItem.squareLength)

        // 设置状态图标
        updateStatusIcon()

        // 创建弹出菜单
        createPopover()

        // 设置点击事件
        statusItem.buttonAction = #selector(statusItemClicked)
        statusItem.target = self
    }

    @objc func statusItemClicked() {
        guard let contentView = contentView else { return }

        if popover.isShown {
            popover.performClose(nil)
        } else {
            popover.show(relativeTo: statusItem.button, preferredEdge: .minY)
        }
    }

    func updateStatusIcon() {
        let iconName: String
        switch connectionStatus {
        case .connected:
            iconName = "status.connected"
        case .pairing:
            iconName = "status.pairing"
        case .disconnected:
            iconName = "status.disconnected"
        case .error:
            iconName = "status.error"
        }

        if let icon = NSImage(systemSymbolName: iconName) {
            statusItem.button = icon
        }
    }
}
```

### 应用生命周期管理
```swift
import Cocoa

class AppDelegate: NSObject, NSApplicationDelegate {
    var nearClipManager: NearClipManager!
    var menuBarManager: MenuBarManager!
    var clipboardMonitor: ClipboardMonitor!

    func applicationDidFinishLaunching(_ notification: Notification) {
        // 初始化管理器
        initializeManagers()

        // 设置主窗口
        setupMainWindow()

        // 启动应用
        startApplication()
    }

    func applicationShouldTerminate(_ sender: NSApplication) -> Bool {
        // 清理资源
        cleanup()
        return true
    }

    func applicationWillUnhide(_ notification: Notification) {
        // 应用从后台回到前台
        resumeApplication()
    }

    func applicationWillResignActive(_ notification: Notification) {
        // 应用即将进入后台
        pauseApplication()
    }

    private func initializeManagers() {
        nearClipManager = NearClipManager()
        menuBarManager = MenuBarManager()
        clipboardMonitor = ClipboardMonitor()

        // 设置观察者
        setupObservers()
    }

    private func setupObservers() {
        // 观察连接状态变化
        nearClipManager.$connectionStatus
            .receive(on: DispatchQueue.main)
            .assign(to: \.connectionStatus, on: menuBarManager)

        // 观察设备数量变化
        nearClipManager.$connectedDevices
            .receive(on: DispatchQueue.main)
            .map { $0.count }
            .assign(to: \.deviceCount, on: menuBarManager)
    }
}
```

### 数据模型定义
[Source: architecture/data-models.md]

#### Device 模型
```swift
import Foundation

struct Device: Codable, Identifiable, Equatable {
    let id: String
    let name: String
    let type: DeviceType
    var connectionStatus: ConnectionStatus
    let lastSeen: Date
    let capabilities: [Capability]
    let alias: String?
    let batteryLevel: Int?

    var id: String { id }
}

enum DeviceType: String, Codable, CaseIterable {
    case unknown = "UNKNOWN"
    case android = "ANDROID"
    case mac = "MAC"
}

enum ConnectionStatus: String, Codable, CaseIterable {
    case unknown = "UNKNOWN"
    case disconnected = "DISCONNECTED"
    case connected = "CONNECTED"
    case pairing = "PAIRING"
    case error = "ERROR"
}

enum Capability: String, Codable, CaseIterable {
    case unknown = "UNKNOWN"
    case ble = "BLE"
    case wifiDirect = "WIFI_DIRECT"
    case clipboardRead = "CLIPBOARD_READ"
    case clipboardWrite = "CLIPBOARD_WRITE"
}
```

### SwiftUI 界面设计
```swift
import SwiftUI

struct ContentView: View {
    @ObservedObject private var nearClipManager: NearClipManager
    @ObservedObject private var menuBarManager: MenuBarManager

    var body: some View {
        NavigationView {
            VStack {
                // 设备发现页面
                DeviceDiscoveryView()
                    .environmentObject(nearClipManager)

                Divider()

                // 设备管理页面
                DeviceManagementView()
                    .environmentObject(nearClipManager)

                Divider()

                // 设置页面
                SettingsView()
                    .environmentObject(nearClipManager)
            }
            .navigationTitle("NearClip")
        }
    }
}
```

### 测试策略
[Source: architecture/testing-strategy.md]

#### 测试文件结构
```
src/platform/mac/NearClip/Tests/
├── NearClipTests/
│   ├── ServicesTests/
│   │   ├── NearClipManagerTests.swift
│   │   ├── MenuBarManagerTests.swift
│   │   └── ClipboardMonitorTests.swift
│   ├── ViewsTests/
│   │   ├── DeviceDiscoveryViewTests.swift
│   │   ├── DeviceManagementViewTests.swift
│   │   └── SettingsViewTests.swift
│   └── IntegrationTests/
│       ├── RustIntegrationTests.swift
│       └── BleIntegrationTests.swift
└── UITests/
    └── NearClipUITests/
        ├── MenuBarTests.swift
        └── NavigationTests.swift
```

#### 单元测试示例
```swift
import XCTest
@testable import NearClip

class NearClipManagerTests: XCTestCase {
    var nearClipManager: NearClipManager!

    override func setUp() {
        super.setUp()
        nearClipManager = NearClipManager()
    }

    func testInitialize() throws {
        // Given
        let manager = NearClipManager()

        // When
        let result = manager.initialize()

        // Then
        XCTAssertTrue(result.isSuccess, "NearClipManager should initialize successfully")
    }

    func testStartDeviceDiscovery() throws {
        // Given
        let mockDevice = Device(
            id: "test-device-1",
            name: "Test Mac",
            type: .mac,
            connectionStatus: .disconnected,
            lastSeen: Date(),
            capabilities: [.ble, .clipboardRead]
        )
        var discoveredDevices: [Device] = []

        // When
        let expectation = XCTestExpectation(description: "Device discovered")
        nearClipManager.startDeviceDiscovery { device in
            discoveredDevices.append(device)
            expectation.fulfill()
        }

        // Then
        wait(for: [expectation], timeout: 5.0)
        XCTAssertEqual(discoveredDevices.count, 1)
        XCTAssertEqual(discoveredDevices.first?.id, mockDevice.id)
    }
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | 初始故事创建，添加 Rust FFI 集成要求 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写
