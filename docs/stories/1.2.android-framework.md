# Story 1.2: Android 基础应用框架搭建

## Status
Draft

## Story
**作为** 开发者，
**我希望** 搭建 Android 应用的基础框架，包含 Jetpack Compose UI、FFI 集成层和基础权限配置，
**以便** 为后续功能开发提供坚实的应用架构基础，并能够与 Rust 共享逻辑库进行通信。

## Acceptance Criteria
1. 创建新的 Android 项目，使用 Kotlin + Jetpack Compose
2. 配置必要的权限：蓝牙访问、网络访问、粘贴板访问等
3. 建立基础的应用架构（MVVM + Repository 模式）
4. 创建基础的导航结构和主要页面占位符
5. 配置基础的依赖注入和状态管理
6. 创建 Rust FFI 集成层，为调用共享逻辑库做准备

## Tasks / Subtasks
- [ ] 创建 Android 项目基础结构 (AC: 1)
  - [ ] 设置 src/platform/android/app/ 目录结构
  - [ ] 创建 build.gradle.kts 配置文件
  - [ ] 配置 Gradle 项目设置
  - [ ] 创建 AndroidManifest.xml 基础配置
- [ ] 配置应用权限和安全性 (AC: 2)
  - [ ] 添加蓝牙权限 (BLUETOOTH, BLUETOOTH_ADMIN)
  - [ ] 添加网络权限 (INTERNET)
  - [ ] 添加粘贴板权限
  - [ ] 配置运行时权限请求逻辑
  - [ ] 创建权限检查工具类
- [ ] 建立应用架构 (AC: 3)
  - [ ] 创建 MVVM 架构组件包结构
  - [ ] 实现 Repository 模式
  - [ ] 创建 ViewModel 基类
  - [ ] 设置依赖注入框架
  - [ ] 创建数据层和 UI 层分离
- [ ] 创建导航和页面结构 (AC: 4)
  - [ ] 使用 Jetpack Compose Navigation 设置导航图
  - [ ] 创建主要页面 Compose 组件
  - [ ] 设置底部导航栏或抽屉导航
  - [ ] 创建页面路由管理
  - [ ] 实现页面间数据传递
- [ ] 配置状态管理和依赖注入 (AC: 5)
  - [ ] 设置 Hilt 或 Koin 依赖注入
  - [ ] 实现 ViewModel 状态管理
  - [ ] 创建状态存储和恢复
  - [ ] 配置协程作用域管理
- [ ] 创建 Rust FFI 集成层 (AC: 6)
  - [ ] 创建 RustNativeBridge 类
  - [ ] 加载 Rust 共享库
  - [ ] 创建 JNI 函数声明
  - [ ] 实现 FFI 安全封装
  - [ ] 创建设备发现和数据同步接口

## Dev Notes

### Android 项目结构
根据统一项目结构文档 [Source: architecture/unified-project-structure.md]，Android 应用位于：

```
src/platform/android/
├── app/
│   ├── src/
│   │   ├── main/
│   │   │   ├── java/com/nearclip/
│   │   │   │   ├── ui/            # UI 组件
│   │   │   │   ├── services/      # Rust FFI 调用层
│   │   │   │   ├── data/          # 数据层
│   │   │   │   │   ├── repository/
│   │   │   │   │   ├── database/
│   │   │   │   │   └── preferences/
│   │   │   │   ├── presentation/   # ViewModels 和 UI
│   │   │   │   │   ├── viewmodel/
│   │   │   │   │   └── theme/
│   │   │   │   └── MainActivity.kt
│   │   │   └── res/               # 资源文件
│   │   └── test/                  # 测试代码
│   ├── build.gradle.kts
│   └── proguard-rules.pro
├── build.gradle.kts
└── gradle.properties
```

### 技术栈信息
[Source: architecture/tech-stack.md]
- **Android 语言**: Kotlin 1.9.20
- **Android 框架**: Jetpack Compose 1.5.4
- **状态管理**: ViewModel + StateFlow
- **依赖注入**: Hilt 或 Koin
- **数据库**: Room 2.5.0
- **FFI 接口**: JNI (Kotlin ↔ Rust 通信)

### Rust FFI 集成架构
[Source: architecture/api-specification.md]

#### Kotlin JNI 接口
```kotlin
class RustNativeBridge {
    companion object {
        init {
            System.loadLibrary("nearclip_core")
        }

        @JvmStatic
        external fun initializeNearclip(): Int

        @JvmStatic
        external fun startDeviceDiscovery(callback: DeviceDiscoveryCallback): Int

        @JvmStatic
        external fun connectToDevice(deviceId: String): Int

        @JvmStatic
        external fun sendSyncMessage(deviceId: String, content: ByteArray): Int

        @JvmStatic
        external fun setSyncCallback(callback: SyncCallback)

        @JvmStatic
        external fun getLastError(): String
    }
}
```

#### FFI 安全封装
```kotlin
class NearClipManager private constructor(
    private val rustBridge: RustNativeBridge
) {
    fun startDeviceDiscoverySafe(callback: (Device) -> Unit): Result<Unit> {
        return try {
            val result = rustBridge.startDeviceDiscovery(object : DeviceDiscoveryCallback {
                override fun onDeviceFound(device: Device) {
                    callback(device)
                }
            })

            if (result == 0) {
                Result.success(Unit)
            } else {
                Result.failure(NearclipException("Failed to start discovery: $result"))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```

### 关键组件设计
[Source: architecture/components.md]

#### MainActivity
```kotlin
@AndroidEntryPoint
class MainActivity : ComponentActivity() {
    private val viewModel: NearClipViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)

        // 初始化 Rust 库
        val initResult = NearClipManager.initialize()
        if (initResult.isFailure) {
            // 处理初始化失败
            Log.e("NearClip", "Failed to initialize Rust library", initResult.exceptionOrNull())
        }

        setContent {
            NearClipNavigation(navController = rememberNavController())
        }
    }
}
```

#### NearClipViewModel
```kotlin
@HiltViewModel
class NearClipViewModel @Inject constructor(
    private val nearClipManager: NearClipManager,
    private val deviceRepository: DeviceRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(NearClipUiState())
    val uiState: StateFlow<NearClipUiState> = _uiState.asStateFlow()

    fun startDeviceDiscovery() {
        viewModelScope.launch {
            _uiState.update { it.copy(isLoading = true) }

            nearClipManager.startDeviceDiscoverySafe { device ->
                // 更新设备列表
                val currentDevices = _uiState.value.discoveredDevices.toMutableList()
                currentDevices.add(device)
                _uiState.update {
                    it.copy(
                        discoveredDevices = currentDevices,
                        isLoading = false
                    )
                }
            }
        }
    }
}
```

### 数据层架构
[Source: architecture/data-models.md]

#### Repository 模式
```kotlin
interface DeviceRepository {
    suspend fun getAllDevices(): Flow<List<Device>>
    suspend fun getDeviceById(deviceId: String): Device?
    suspend fun insertDevice(device: Device)
    suspend fun updateDevice(device: Device)
    suspend fun deleteDevice(deviceId: String)
}

@Singleton
class DeviceRepositoryImpl @Inject constructor(
    private val deviceDao: DeviceDao,
    private val rustBridge: RustNativeBridge
) : DeviceRepository {

    override suspend fun getAllDevices(): Flow<List<Device>> {
        return deviceDao.getAllDevices()
    }

    override suspend fun getDeviceById(deviceId: String): Device? {
        return deviceDao.getDeviceById(deviceId)
    }
}
```

### Testing

#### 测试标准
[Source: architecture/testing-strategy.md]

**测试文件位置：**
```
src/platform/android/app/src/test/
├── ui/
│   ├── components/
│   │   ├── DeviceCardTest.kt
│   │   ├── StatusIndicatorTest.kt
│   │   └── NavigationTest.kt
│   └── screens/
│       ├── HomeScreenTest.kt
│       └── DeviceDiscoveryScreenTest.kt
├── viewmodel/
│   └── NearClipViewModelTest.kt
└── integration/
    ├── RustIntegrationTest.kt
    └── BleIntegrationTest.kt
```

**测试框架：**
- Android: JUnit 4.13.2 + Espresso
- Coroutines: kotlinx-coroutines-test
- Mock: MockK

#### 单元测试示例
```kotlin
@Test
fun `NearClipViewModel should update uiState when device discovered`() = runTest {
    // Given
    val mockNearClipManager = mockk<NearClipManager>()
    val mockDeviceRepository = mockk<DeviceRepository>()
    val viewModel = NearClipViewModel(mockNearClipManager, mockDeviceRepository)
    val testDevice = Device(
        deviceId = "test-device-1",
        deviceName = "Test Android",
        deviceType = DeviceType.ANDROID,
        publicKey = "test-key",
        lastSeen = System.currentTimeMillis(),
        connectionStatus = ConnectionStatus.DISCONNECTED
    )

    // When
    every { mockNearClipManager.startDeviceDiscoverySafe(any()) } returns Result.success(Unit)

    // Then
    viewModel.startDeviceDiscovery()

    // Verify callback was registered
    verify { mockNearClipManager.startDeviceDiscoverySuccess(any()) }
}
```

#### 集成测试示例
```kotlin
@Test
fun `Rust FFI integration should work correctly`() {
    // Test native library loading
    val result = NearClipManager.initialize()
    assertThat(result.isSuccess).isTrue()

    // Test FFI calls
    val mockCallback = mockk<DeviceDiscoveryCallback>()
    val discoveryResult = nearclipStartDeviceDiscovery(mockCallback)
    assertThat(discoveryResult).isEqualTo(0)
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-16 | 1.0 | 初始故事创建，添加 Rust FFI 集成要求 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写