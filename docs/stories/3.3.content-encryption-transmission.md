# 故事 3.3: 内容加密与传输

## 基本信息
- **故事编号**: 3.3
- **Epic**: Epic 3 - 跨设备粘贴板同步
- **故事名称**: 内容加密与传输
- **优先级**: 高
- **预计工期**: 6 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 我的粘贴板内容能够安全、快速地传输到配对设备，
**以便** 我能够在不同设备间无缝同步内容，同时确保数据安全和隐私保护。

## 验收标准

### AC 1: 端到端加密机制
- **加密算法**: 使用AES-256-GCM进行内容加密
- **密钥管理**: 每个设备对使用独立的会话密钥
- **密钥交换**: 基于ECDH (Elliptic Curve Diffie-Hellman) 的密钥交换
- **完整性保护**: 每个传输包包含HMAC-SHA256签名
- **前向安全**: 定期轮换会话密钥，确保前向安全

### AC 2: 高效传输协议
- **传输协议**: 基于BLE 4.2+的可靠传输层
- **数据分片**: 支持大文件的智能分片传输（最大10GB）
- **断点续传**: 支持传输中断后的断点续传功能
- **并发控制**: 支持多个内容的并发传输管理
- **网络适应**: 根据信号强度自动调整传输策略

### AC 3: 压缩与优化
- **智能压缩**: 根据内容类型选择最佳压缩算法
- **文本压缩**: 使用LZ77算法压缩文本内容
- **图片压缩**: 智能图片压缩，保持质量的同时减少大小
- **重复数据去重**: 检测并避免传输重复数据
- **传输优化**: 小内容合并传输，大内容分片传输

### AC 4: 传输状态管理
- **实时状态**: 提供详细的传输进度和状态信息
- **传输队列**: 实现智能传输队列，支持优先级管理
- **失败重试**: 智能重试机制，指数退避策略
- **传输限制**: 支持用户配置的传输大小和频率限制
- **网络监测**: 实时监测网络状态，调整传输策略

### AC 5: 安全验证机制
- **设备认证**: 传输前验证设备身份和授权状态
- **内容校验**: 传输完成后进行内容完整性校验
- **时间戳验证**: 验证传输时间戳，防止重放攻击
- **访问控制**: 确保只有授权设备能接收内容
- **审计日志**: 记录所有传输操作的详细日志

## 技术实现要点

### 1. Rust加密传输引擎
```rust
// src/shared/rust/src/transfer/mod.rs
pub mod encryption;
pub mod protocol;
pub mod compression;
pub mod manager;
pub mod queue;

pub use encryption::EncryptionEngine;
pub use protocol::TransferProtocol;
pub use compression::CompressionEngine;
pub use manager::TransferManager;
pub use queue::TransferQueue;
```

### 2. 加密引擎
```rust
// src/shared/rust/src/transfer/encryption.rs
use ring::aead::{Aad, AES_256_GCM, LessSafeKey, Nonce, UnboundKey};
use ring::rand::{SecureRandom, SystemRandom};
use ring::signature::{EcdsaKeyPair, ECDSA_P256_SHA256_FIXED_SIGNING};

pub struct EncryptionEngine {
    device_key_pair: EcdsaKeyPair,
    session_keys: HashMap<DeviceId, SessionKey>,
    rng: SystemRandom,
}

impl EncryptionEngine {
    pub fn new() -> Result<Self, EncryptionError> {
        let rng = SystemRandom::new();
        let key_pair = generate_device_key_pair(&rng)?;

        Ok(Self {
            device_key_pair: key_pair,
            session_keys: HashMap::new(),
            rng,
        })
    }

    pub async fn establish_session(&mut self, peer_device: &DeviceId) -> Result<SessionKey, EncryptionError> {
        // 1. 生成临时密钥对
        let ephemeral_key = generate_ephemeral_key_pair()?;

        // 2. 执行ECDH密钥交换
        let shared_secret = self.perform_ecdh_exchange(peer_device, &ephemeral_key).await?;

        // 3. 派生会话密钥
        let session_key = self.derive_session_key(&shared_secret)?;

        // 4. 存储会话密钥
        self.session_keys.insert(peer_device.clone(), session_key.clone());

        Ok(session_key)
    }

    pub fn encrypt_content(&self, device_id: &DeviceId, content: &[u8]) -> Result<EncryptedContent, EncryptionError> {
        let session_key = self.session_keys.get(device_id)
            .ok_or(EncryptionError::NoSessionKey)?;

        // 生成随机nonce
        let mut nonce_bytes = [0u8; 12];
        self.rng.fill(&mut nonce_bytes)?;
        let nonce = Nonce::assume_unique_for_key(nonce_bytes);

        // 加密内容
        let sealing_key = LessSafeKey::new(UnboundKey::new(&AES_256_GCM, &session_key.encryption_key)?);
        let mut encrypted_data = content.to_vec();

        sealing_key.seal_in_place_append_tag(
            Aad::from(&self.generate_associated_data()),
            nonce,
            &mut encrypted_data,
        )?;

        // 生成HMAC
        let hmac = self.generate_hmac(&encrypted_data, &session_key.mac_key)?;

        Ok(EncryptedContent {
            data: encrypted_data,
            nonce: nonce.as_ref().to_vec(),
            hmac,
            timestamp: Utc::now(),
        })
    }

    pub fn decrypt_content(&self, device_id: &DeviceId, encrypted: &EncryptedContent) -> Result<Vec<u8>, EncryptionError> {
        let session_key = self.session_keys.get(device_id)
            .ok_or(EncryptionError::NoSessionKey)?;

        // 验证HMAC
        self.verify_hmac(&encrypted.data, &encrypted.hmac, &session_key.mac_key)?;

        // 解密内容
        let opening_key = LessSafeKey::new(UnboundKey::new(&AES_256_GCM, &session_key.encryption_key)?);
        let nonce = Nonce::assume_unique_for_key(try_into_array(&encrypted.nonce)?);

        let mut decrypted_data = encrypted.data.clone();
        let decrypted_len = opening_key.open_in_place(
            Aad::from(&self.generate_associated_data()),
            nonce,
            &mut decrypted_data,
        )?;

        Ok(decrypted_data[..decrypted_len].to_vec())
    }
}
```

### 3. 传输协议
```rust
// src/shared/rust/src/transfer/protocol.rs
pub struct TransferProtocol {
    ble_manager: BleManager,
    packet_handler: PacketHandler,
    transfer_state: Arc<Mutex<HashMap<TransferId, TransferState>>>,
}

impl TransferProtocol {
    pub async fn initiate_transfer(&self,
        target_device: DeviceId,
        content: ClipboardContent
    ) -> Result<TransferId, ProtocolError> {

        // 1. 生成传输ID
        let transfer_id = TransferId::new();

        // 2. 准备传输元数据
        let metadata = TransferMetadata {
            id: transfer_id,
            source_device: self.device_id(),
            target_device,
            content_type: content.content_type,
            size: content.data.len(),
            checksum: calculate_checksum(&content.data),
            timestamp: Utc::now(),
        };

        // 3. 创建传输状态
        let state = TransferState::new(metadata.clone());
        self.transfer_state.lock().unwrap().insert(transfer_id, state);

        // 4. 协商传输参数
        let transfer_params = self.negotiate_transfer_parameters(&target_device).await?;

        // 5. 开始数据传输
        self.start_data_transfer(transfer_id, content, transfer_params).await?;

        Ok(transfer_id)
    }

    async fn start_data_transfer(&self,
        transfer_id: TransferId,
        content: ClipboardContent,
        params: TransferParams
    ) -> Result<(), ProtocolError> {

        // 1. 加密内容
        let encrypted = self.encryption_engine
            .encrypt_content(&params.target_device, &content.data)?;

        // 2. 分片处理
        let chunks = self.create_chunks(&encrypted.data, params.chunk_size);

        // 3. 发送元数据包
        let metadata_packet = Packet::Metadata {
            transfer_id,
            metadata: TransferMetadata {
                content_type: content.content_type,
                total_chunks: chunks.len(),
                encrypted_size: encrypted.data.len(),
                checksum: calculate_checksum(&encrypted.data),
                timestamp: Utc::now(),
            },
        };
        self.send_packet(&params.target_device, metadata_packet).await?;

        // 4. 发送数据块
        for (chunk_index, chunk_data) in chunks.into_iter().enumerate() {
            let data_packet = Packet::DataChunk {
                transfer_id,
                chunk_index: chunk_index as u32,
                data: chunk_data,
            };

            self.send_packet(&params.target_device, data_packet).await?;

            // 等待确认
            self.wait_for_chunk_ack(&params.target_device, transfer_id, chunk_index as u32).await?;
        }

        // 5. 发送完成包
        let complete_packet = Packet::TransferComplete { transfer_id };
        self.send_packet(&params.target_device, complete_packet).await?;

        Ok(())
    }

    async fn handle_received_packet(&self, source_device: DeviceId, packet: Packet) -> Result<(), ProtocolError> {
        match packet {
            Packet::Metadata { metadata, transfer_id } => {
                self.handle_metadata_received(source_device, transfer_id, metadata).await?;
            },
            Packet::DataChunk { transfer_id, chunk_index, data } => {
                self.handle_chunk_received(source_device, transfer_id, chunk_index, data).await?;
            },
            Packet::TransferComplete { transfer_id } => {
                self.handle_transfer_complete(source_device, transfer_id).await?;
            },
            _ => return Err(ProtocolError::UnknownPacketType),
        }
        Ok(())
    }
}
```

### 4. 压缩引擎
```rust
// src/shared/rust/src/transfer/compression.rs
pub struct CompressionEngine {
    text_compressor: TextCompressor,
    image_compressor: ImageCompressor,
    generic_compressor: GenericCompressor,
}

impl CompressionEngine {
    pub async fn compress(&self, content: &ClipboardContent) -> Result<CompressedContent, CompressionError> {
        match content.content_type {
            ContentType::Text => {
                let compressed = self.text_compressor.compress(&content.data)?;
                Ok(CompressedContent {
                    data: compressed,
                    original_size: content.data.len(),
                    compression_type: CompressionType::LZ77,
                })
            },
            ContentType::Image => {
                let compressed = self.image_compressor.compress(&content.data)?;
                Ok(CompressedContent {
                    data: compressed,
                    original_size: content.data.len(),
                    compression_type: CompressionType::WebP,
                })
            },
            _ => {
                let compressed = self.generic_compressor.compress(&content.data)?;
                Ok(CompressedContent {
                    data: compressed,
                    original_size: content.data.len(),
                    compression_type: CompressionType::Gzip,
                })
            }
        }
    }

    pub fn calculate_compression_benefit(&self, content: &ClipboardContent) -> f32 {
        // 预估压缩收益，决定是否值得压缩
        let original_size = content.data.len();
        if original_size < 1024 { // 小于1KB不压缩
            return 0.0;
        }

        match content.content_type {
            ContentType::Text => self.estimate_text_compression(&content.data),
            ContentType::Image => self.estimate_image_compression(&content.data),
            _ => 0.3, // 默认30%压缩率
        }
    }
}
```

### 5. 传输管理器
```rust
// src/shared/rust/src/transfer/manager.rs
pub struct TransferManager {
    active_transfers: Arc<Mutex<HashMap<TransferId, ActiveTransfer>>>,
    transfer_queue: TransferQueue,
    encryption_engine: EncryptionEngine,
    compression_engine: CompressionEngine,
    protocol: TransferProtocol,
}

impl TransferManager {
    pub async fn queue_transfer(&self,
        target_device: DeviceId,
        content: ClipboardContent,
        priority: TransferPriority
    ) -> Result<TransferId, TransferError> {

        // 1. 验证设备状态
        self.validate_device_state(&target_device)?;

        // 2. 预处理内容
        let processed_content = self.preprocess_content(content).await?;

        // 3. 创建传输任务
        let transfer_task = TransferTask {
            id: TransferId::new(),
            target_device,
            content: processed_content,
            priority,
            created_at: Utc::now(),
            retry_count: 0,
        };

        // 4. 加入队列
        self.transfer_queue.enqueue(transfer_task).await?;

        Ok(transfer_task.id)
    }

    async fn preprocess_content(&self, mut content: ClipboardContent) -> Result<ClipboardContent, TransferError> {
        // 1. 检查压缩收益
        let compression_benefit = self.compression_engine.calculate_compression_benefit(&content);

        if compression_benefit > 0.1 { // 压缩收益超过10%才压缩
            let compressed = self.compression_engine.compress(&content).await?;
            content.data = compressed.data;
            content.metadata.compressed = true;
            content.metadata.original_size = compressed.original_size;
        }

        // 2. 分片处理（如果内容过大）
        if content.data.len() > MAX_CHUNK_SIZE * 10 {
            content = self.split_content(content)?;
        }

        Ok(content)
    }

    pub async fn start_processing_queue(&self) {
        while let Some(task) = self.transfer_queue.dequeue().await {
            let result = self.process_transfer_task(task).await;

            match result {
                Ok(transfer_id) => {
                    log::info!("Transfer {} started successfully", transfer_id);
                },
                Err(error) => {
                    log::error!("Transfer failed: {}", error);
                    // 错误处理和重试逻辑
                }
            }
        }
    }

    async fn process_transfer_task(&self, task: TransferTask) -> Result<TransferId, TransferError> {
        // 1. 确保会话密钥存在
        if !self.encryption_engine.has_session_key(&task.target_device) {
            self.encryption_engine.establish_session(&task.target_device).await?;
        }

        // 2. 开始传输
        let transfer_id = self.protocol.initiate_transfer(
            task.target_device,
            task.content
        ).await?;

        // 3. 注册活跃传输
        let active_transfer = ActiveTransfer {
            id: transfer_id,
            task,
            started_at: Utc::now(),
            status: TransferStatus::InProgress,
        };

        self.active_transfers.lock().unwrap().insert(transfer_id, active_transfer);

        Ok(transfer_id)
    }
}
```

### 6. Android平台集成
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/transfer/TransferService.kt
class TransferService : Service() {
    private lateinit var rustBridge: RustNativeBridge
    private lateinit var notificationManager: NotificationManager

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        when (intent?.action) {
            ACTION_START_TRANSFER -> {
                val content = intent.getParcelableExtra<ClipboardContent>(EXTRA_CONTENT)
                val deviceId = intent.getStringExtra(EXTRA_DEVICE_ID)

                if (content != null && deviceId != null) {
                    startTransfer(content, deviceId)
                }
            }
        }
        return START_STICKY
    }

    private fun startTransfer(content: ClipboardContent, deviceId: String) {
        // 调用Rust传输引擎
        val transferId = rustBridge.startTransfer(
            deviceId = deviceId,
            contentType = content.type.value,
            data = content.data,
            priority = 1 // 高优先级
        )

        // 显示传输进度通知
        showTransferNotification(transferId)

        // 监听传输状态
        observeTransferStatus(transferId)
    }

    private fun observeTransferStatus(transferId: String) {
        // 使用Flow或LiveData监听传输状态
        rustBridge.getTransferStatusFlow(transferId)
            .onEach { status ->
                updateTransferNotification(transferId, status)
                if (status.isCompleted()) {
                    handleTransferCompleted(transferId, status)
                }
            }
            .launchIn(lifecycleScope)
    }
}
```

### 7. macOS平台集成
```swift
// src/platform/mac/NearClip/Transfer/TransferManager.swift
class TransferManagerImpl: TransferManager {
    private let rustBridge: RustNativeBridge
    private let notificationCenter = NotificationCenter.default

    func startTransfer(content: ClipboardContent, to deviceId: String) async throws -> String {
        // 准备传输数据
        let transferData = TransferData(
            deviceId: deviceId,
            contentType: content.type.rawValue,
            data: content.data,
            priority: 1
        )

        // 调用Rust传输引擎
        let transferId = try await rustBridge.startTransfer(transferData)

        // 监听传输状态
        await observeTransferStatus(transferId)

        return transferId
    }

    private func observeTransferStatus(_ transferId: String) async {
        // 使用AsyncStream监听传输状态
        let statusStream = rustBridge.getTransferStatusStream(transferId)

        for await status in statusStream {
            await MainActor.run {
                NotificationCenter.default.post(
                    name: .transferStatusChanged,
                    object: TransferStatusUpdate(
                        transferId: transferId,
                        status: status
                    )
                )
            }

            if status.isCompleted {
                await handleTransferCompleted(transferId, status: status)
                break
            }
        }
    }
}
```

## 测试用例

### 单元测试
```rust
// src/shared/rust/src/transfer/tests.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_encryption_decryption() {
        let engine = EncryptionEngine::new().unwrap();
        let device_id = DeviceId::new();

        // 建立会话
        engine.establish_session(&device_id).await.unwrap();

        let original_data = b"Test secret message";
        let encrypted = engine.encrypt_content(&device_id, original_data).unwrap();
        let decrypted = engine.decrypt_content(&device_id, &encrypted).unwrap();

        assert_eq!(original_data, &decrypted[..]);
    }

    #[tokio::test]
    async fn test_large_file_transfer() {
        let manager = TransferManager::new().await;
        let large_content = create_large_test_content(10 * 1024 * 1024); // 10MB
        let target_device = create_test_device();

        let transfer_id = manager.queue_transfer(
            target_device.id,
            large_content,
            TransferPriority::Normal
        ).await.unwrap();

        // 等待传输完成
        let result = manager.wait_for_transfer_completion(transfer_id).await;
        assert!(result.is_ok());
    }

    #[tokio::test]
    async fn test_compression_efficiency() {
        let compressor = CompressionEngine::default();
        let text_content = create_repetitive_text_content(); // 高重复率文本

        let compressed = compressor.compress(&text_content).await.unwrap();
        let compression_ratio = compressed.data.len() as f32 / text_content.data.len() as f32;

        assert!(compression_ratio < 0.5); // 压缩率至少50%
    }
}
```

### 集成测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/transfer/TransferIntegrationTest.kt
@RunWith(AndroidJUnit4::class)
class TransferIntegrationTest {

    @Test
    fun testEndToEndTransfer() {
        val content = createTestClipboardContent()
        val targetDevice = createPairedDevice()

        // 开始传输
        val transferId = transferService.startTransfer(content, targetDevice.id)

        // 等待传输完成
        val result = transferService.waitForTransfer(transferId, timeout = 30000)

        assertThat(result.isSuccess).isTrue()
        assertThat(result.getOrNull()?.status).isEqualTo(TransferStatus.COMPLETED)
    }
}
```

### 性能测试
```rust
// src/shared/rust/src/transfer/tests/performance.rs
#[tokio::test]
async fn test_transfer_throughput() {
    let manager = TransferManager::new().await;
    let content_sizes = vec![1_000, 10_000, 100_000, 1_000_000]; // 1KB到1MB

    for size in content_sizes {
        let content = create_test_content(size);
        let start_time = Instant::now();

        let transfer_id = manager.queue_transfer(
            create_test_device_id(),
            content,
            TransferPriority::Normal
        ).await.unwrap();

        let result = manager.wait_for_transfer_completion(transfer_id).await;
        let elapsed = start_time.elapsed();

        assert!(result.is_ok());
        let throughput = size as f64 / elapsed.as_secs_f64();
        println!("Size: {} bytes, Throughput: {:.2} bytes/sec", size, throughput);

        // 确保吞吐量满足要求
        assert!(throughput > 100_000.0); // 至少100KB/s
    }
}
```

## 部署要求

### 环境配置
- Android: API 24+ (Android 7.0+)
- macOS: 10.15+ (Catalina+)
- Rust: 1.70+
- BLE: 4.2+ 支持
- 内存: 最少128MB用于传输缓存

### 依赖项
```toml
# Cargo.toml
[dependencies]
ring = "0.17"        # 加密库
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
flate2 = "1.0"       # 压缩库
image = "0.24"       # 图像处理
crc = "3.0"          # 校验和计算
```

```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.work:work-runtime-ktx:2.8.1"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"
}
```

## 验收测试计划

### 功能测试
1. **加密测试**: 验证AES-256-GCM加密的正确性和安全性
2. **传输测试**: 测试各种大小和类型内容的传输
3. **压缩测试**: 验证不同内容类型的压缩效果
4. **状态管理**: 测试传输状态的正确更新

### 安全测试
1. **密钥管理**: 验证密钥生成、交换和轮换机制
2. **完整性校验**: 测试HMAC签名验证功能
3. **前向安全**: 验证密钥轮换的前向安全性
4. **重放攻击**: 测试防重放攻击机制

### 性能测试
1. **传输速度**: 测试不同网络条件下的传输速度
2. **压缩效率**: 验证压缩算法的效率和效果
3. **并发处理**: 测试多个并发传输的处理能力
4. **资源使用**: 监控CPU和内存使用情况

### 兼容性测试
1. **设备兼容**: 测试不同Android版本和macOS版本的兼容性
2. **BLE兼容**: 验证不同BLE芯片和版本的兼容性
3. **内容格式**: 测试各种粘贴板格式的传输兼容性

## 风险与缓解

### 技术风险
- **BLE连接不稳定**: 无线连接可能不稳定
  - 缓解: 实现重连机制，智能传输策略
- **大文件传输**: 大文件传输可能超时或失败
  - 缓解: 分片传输，断点续传，进度监控
- **加密性能**: 加密可能影响传输性能
  - 缓解: 硬件加速支持，优化加密算法

### 安全风险
- **密钥泄露**: 会话密钥可能被泄露
  - 缓解: 定期密钥轮换，安全存储，前向安全
- **中间人攻击**: 传输过程可能被劫持
  - 缓解: 设备认证，端到端加密，完整性校验
- **重放攻击**: 恶意重放传输数据
  - 缓解: 时间戳验证，nonce机制，序列号

### 用户体验风险
- **传输延迟**: 传输过程可能较长
  - 缓解: 压缩优化，进度提示，后台传输
- **传输失败**: 传输可能频繁失败
  - 缓解: 智能重试，错误提示，用户反馈
- **电池消耗**: 长时间传输影响电池
  - 缓解: 传输优化，网络适应，省电模式

## 完成标准
- [ ] AES-256-GCM加密机制正常工作
- [ ] ECDH密钥交换功能完整
- [ ] BLE传输协议稳定可靠
- [ ] 大文件分片传输功能正常
- [ ] 压缩算法有效工作
- [ ] 传输状态实时更新
- [ ] 所有单元测试和集成测试通过
- [ ] 安全测试和性能测试通过
- [ ] 用户界面显示传输进度
- [ ] 错误处理和重试机制完善