# Story 2.2: QR 码配对功能实现

## Status
Draft

## Story
**作为** 用户，
**我希望** 能够通过扫描 QR 码快速配对设备，
**以便** 避免复杂的设备选择过程，实现便捷的设备连接。

## Acceptance Criteria
1. 实现设备端 QR 码生成功能，显示配对码
2. 实现扫描端 QR 码识别功能，自动填入配对信息
3. QR 码包含设备身份信息和临时配对令牌
4. 提供清晰的扫描界面和操作指引
5. 处理 QR 码识别失败和重试逻辑

## Tasks / Subtasks
- [ ] 设计 QR 码配对协议 (AC: 3)
  - [ ] 定义 QR 码数据格式和结构
  - [ ] 实现设备身份信息编码
  - [ ] 创建临时配对令牌生成机制
  - [ ] 设计 QR 码版本和容错级别
  - [ ] 实现配对信息加密和签名
- [ ] 实现 QR 码生成功能 (AC: 1)
  - [ ] 创建 Rust QR 码生成库集成
  - [ ] 实现设备信息序列化到 QR 码
  - [ ] 创建 QR 码显示界面（Android 和 Mac）
  - [ ] 添加 QR 码有效期和自动刷新
  - [ ] 实现 QR 码样式和品牌定制
- [ ] 实现 QR 码扫描功能 (AC: 2, 4)
  - [ ] 集成 Android 相机扫描库（ML Kit）
  - [ ] 集成 Mac 相机扫描功能（AVFoundation）
  - [ ] 创建扫描界面和取景框
  - [ ] 实现扫描指引和用户提示
  - [ ] 添加扫描成功反馈和动画效果
- [ ] 实现配对流程处理 (AC: 2, 5)
  - [ ] 创建 QR 码解析和验证逻辑
  - [ ] 实现自动配对请求发送
  - [ ] 添加配对状态跟踪和反馈
  - [ ] 实现配对超时和重试机制
  - [ ] 创建配对成功/失败界面
- [ ] 实现错误处理和用户体验 (AC: 5)
  - [ ] 处理 QR 码格式错误
  - [ ] 实现扫描失败重试逻辑
  - [ ] 添加光线不足提示
  - [ ] 创建手动输入配对码备选方案
  - [ ] 实现配对取消和退出机制
- [ ] 安全性和性能优化
  - [ ] 实现配对令牌安全存储
  - [ ] 添加 QR 码防重放攻击
  - [ ] 优化扫描响应速度
  - [ ] 实现内存和相机资源管理
  - [ ] 添加配对日志和安全审计

## Dev Notes

### QR 码配对协议设计
[Source: architecture/api-specification.md]

#### QR 码数据结构
```protobuf
// src/shared/protocol/qr_pairing.proto
syntax = "proto3";

package nearclip.qr_pairing;

// QR 码配对数据
message QRPairingData {
  string version = 1;                    // 协议版本
  string device_id = 2;                  // 设备唯一标识
  string device_name = 3;                // 设备显示名称
  DeviceType device_type = 4;            // 设备类型
  string pairing_token = 5;              // 临时配对令牌
  int64 expires_at = 6;                  // 过期时间戳
  string signature = 7;                  // 数据签名
  bytes public_key = 8;                  // 设备公钥
  map<string, string> metadata = 9;      // 扩展元数据
}

// 设备类型枚举
enum DeviceType {
  DEVICE_TYPE_UNKNOWN = 0;
  DEVICE_TYPE_ANDROID = 1;
  DEVICE_TYPE_MAC = 2;
  DEVICE_TYPE_WINDOWS = 3;
  DEVICE_TYPE_IOS = 4;
}

// 配对确认请求
message PairingConfirmation {
  string device_id = 1;                  // 发起设备ID
  string target_device_id = 2;           // 目标设备ID
  string pairing_token = 3;              // 配对令牌
  bytes signed_token = 4;                // 签名令牌
  bytes session_key = 5;                 // 会话密钥
  int64 timestamp = 6;                   // 时间戳
}

// 配对确认响应
message PairingResponse {
  bool success = 1;                      // 是否成功
  string device_id = 2;                  // 确认设备ID
  string session_id = 3;                 // 会话ID
  string error_message = 4;              // 错误信息
  bytes device_certificate = 5;          // 设备证书
}
```

#### Rust QR 码处理实现
```rust
// src/shared/rust/src/qr/manager.rs
use qrcode::QrCode;
use image::Luma;
use chrono::{DateTime, Utc, Duration};
use ring::signature::{self, Ed25519};
use base64::{Engine as _, engine::general_purpose};
use serde::{Deserialize, Serialize};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum QRError {
    #[error("QR code generation failed: {0}")]
    GenerationFailed(String),
    #[error("QR code parsing failed: {0}")]
    ParsingFailed(String),
    #[error("Invalid pairing token: {0}")]
    InvalidToken(String),
    #[error("Expired pairing token")]
    TokenExpired,
    #[error("Signature verification failed")]
    SignatureVerificationFailed,
    #[error("Unsupported QR code version: {0}")]
    UnsupportedVersion(String),
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct QRPairingData {
    pub version: String,
    pub device_id: String,
    pub device_name: String,
    pub device_type: DeviceType,
    pub pairing_token: String,
    pub expires_at: DateTime<Utc>,
    pub signature: String,
    pub public_key: Vec<u8>,
    pub metadata: std::collections::HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum DeviceType {
    Unknown,
    Android,
    Mac,
    Windows,
    Ios,
}

pub struct QRPairingManager {
    private_key: Ed25519::KeyPair,
    token_validity_duration: Duration,
}

impl QRPairingManager {
    pub fn new(private_key: Ed25519::KeyPair) -> Self {
        Self {
            private_key,
            token_validity_duration: Duration::minutes(5), // 5分钟有效期
        }
    }

    /// 生成 QR 码配对数据
    pub fn generate_pairing_data(
        &self,
        device_id: String,
        device_name: String,
        device_type: DeviceType,
    ) -> Result<QRPairingData, QRError> {
        let pairing_token = self.generate_pairing_token();
        let expires_at = Utc::now() + self.token_validity_duration;

        let mut data = QRPairingData {
            version: "1.0".to_string(),
            device_id: device_id.clone(),
            device_name,
            device_type,
            pairing_token: pairing_token.clone(),
            expires_at,
            signature: String::new(), // 将在签名后填充
            public_key: self.private_key.public_key().as_ref().to_vec(),
            metadata: std::collections::HashMap::new(),
        };

        // 序列化数据并签名
        let serialized = serde_json::to_string(&data)
            .map_err(|e| QRError::GenerationFailed(e.to_string()))?;

        let signature = self.private_key.sign(serialized.as_bytes());
        data.signature = general_purpose::STANDARD.encode(signature.as_ref());

        Ok(data)
    }

    /// 生成 QR 码图像
    pub fn generate_qr_code(&self, data: &QRPairingData) -> Result<Vec<u8>, QRError> {
        let json_data = serde_json::to_string(data)
            .map_err(|e| QRError::GenerationFailed(e.to_string()))?;

        let qr_code = QrCode::new(json_data.as_bytes())
            .map_err(|e| QRError::GenerationFailed(e.to_string()))?;

        let image = qr_code.render::<Luma<u8>>().build();

        // 转换为 PNG 格式
        let mut buffer = Vec::new();
        {
            let encoder = image::codecs::png::PngEncoder::new(&mut buffer);
            image.write_with_encoder(encoder)
                .map_err(|e| QRError::GenerationFailed(e.to_string()))?;
        }

        Ok(buffer)
    }

    /// 解析 QR 码数据
    pub fn parse_qr_data(&self, qr_data: &str) -> Result<QRPairingData, QRError> {
        let data: QRPairingData = serde_json::from_str(qr_data)
            .map_err(|e| QRError::ParsingFailed(e.to_string()))?;

        // 验证版本
        if data.version != "1.0" {
            return Err(QRError::UnsupportedVersion(data.version));
        }

        // 验证过期时间
        if Utc::now() > data.expires_at {
            return Err(QRError::TokenExpired);
        }

        // 验证签名
        self.verify_signature(&data)?;

        Ok(data)
    }

    /// 生成配对确认
    pub fn generate_pairing_confirmation(
        &self,
        pairing_data: &QRPairingData,
        target_device_id: String,
    ) -> Result<PairingConfirmation, QRError> {
        let confirmation = PairingConfirmation {
            device_id: pairing_data.device_id.clone(),
            target_device_id,
            pairing_token: pairing_data.pairing_token.clone(),
            signed_token: String::new(), // 将在签名后填充
            session_key: self.generate_session_key(),
            timestamp: Utc::now().timestamp_millis() as u64,
        };

        Ok(confirmation)
    }

    /// 验证配对确认
    pub fn verify_pairing_confirmation(
        &self,
        confirmation: &PairingConfirmation,
        expected_token: &str,
    ) -> Result<(), QRError> {
        if confirmation.pairing_token != expected_token {
            return Err(QRError::InvalidToken("Token mismatch".to_string()));
        }

        // 验证时间戳
        let now = Utc::now().timestamp_millis() as u64;
        if now.saturating_sub(confirmation.timestamp) > 300_000 { // 5分钟
            return Err(QRError::TokenExpired);
        }

        Ok(())
    }

    /// 生成配对令牌
    fn generate_pairing_token(&self) -> String {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let token: [u8; 32] = rng.gen();
        general_purpose::STANDARD.encode(token)
    }

    /// 生成会话密钥
    fn generate_session_key(&self) -> Vec<u8> {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let key: [u8; 32] = rng.gen();
        key.to_vec()
    }

    /// 验证签名
    fn verify_signature(&self, data: &QRPairingData) -> Result<(), QRError> {
        let public_key = ring::signature::UnparsedPublicKey::new(
            &ring::signature::ED25519,
            &data.public_key,
        );

        // 重新序列化数据（不包含签名）
        let mut data_without_signature = data.clone();
        data_without_signature.signature.clear();
        let serialized = serde_json::to_string(&data_without_signature)
            .map_err(|e| QRError::ParsingFailed(e.to_string()))?;

        let signature = general_purpose::STANDARD.decode(&data.signature)
            .map_err(|_| QRError::SignatureVerificationFailed)?;

        public_key.verify(serialized.as_bytes(), &signature)
            .map_err(|_| QRError::SignatureVerificationFailed)?;

        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PairingConfirmation {
    pub device_id: String,
    pub target_device_id: String,
    pub pairing_token: String,
    pub signed_token: String,
    pub session_key: Vec<u8>,
    pub timestamp: u64,
}
```

### Android QR 码功能实现

#### QR 码生成界面
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/screens/QRCodeDisplayScreen.kt
package com.nearclip.ui.screens

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.nearclip.ui.viewmodel.QRCodeDisplayViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun QRCodeDisplayScreen(
    onClose: () -> Unit,
    onPairingSuccess: () -> Unit,
    viewModel: QRCodeDisplayViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val configuration = LocalConfiguration.current

    LaunchedEffect(Unit) {
        viewModel.generateQRCode()
    }

    LaunchedEffect(uiState.pairingStatus) {
        when (uiState.pairingStatus) {
            PairingStatus.SUCCESS -> onPairingSuccess()
            PairingStatus.FAILED -> {
                // 显示错误提示
            }
            else -> { /* No action needed */ }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("设备配对") },
                navigationIcon = {
                    IconButton(onClick = onClose) {
                        Icon(Icons.Default.Close, contentDescription = "关闭")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(24.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(24.dp)
        ) {
            // 说明文字
            Text(
                text = "让其他设备扫描此 QR 码进行配对",
                style = MaterialTheme.typography.headlineSmall,
                fontWeight = FontWeight.Medium,
                textAlign = TextAlign.Center
            )

            // QR 码显示区域
            QRCodeDisplay(
                qrCodeImage = uiState.qrCodeImage,
                isLoading = uiState.isLoading,
                modifier = Modifier.size(
                    minOf(configuration.screenWidthDp.dp - 48.dp, 300.dp)
                )
            )

            // 设备信息
            DeviceInfoCard(
                deviceName = uiState.deviceName,
                deviceId = uiState.deviceId,
                modifier = Modifier.fillMaxWidth()
            )

            // 配对状态
            PairingStatusCard(
                status = uiState.pairingStatus,
                errorMessage = uiState.errorMessage,
                onRefresh = { viewModel.refreshQRCode() },
                modifier = Modifier.fillMaxWidth()
            )

            // 操作按钮
            ActionButtons(
                onRefresh = { viewModel.refreshQRCode() },
                onShare = { viewModel.shareQRCode() },
                isRefreshing = uiState.isRefreshing,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
private fun QRCodeDisplay(
    qrCodeImage: ImageBitmap?,
    isLoading: Boolean,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .clip(RoundedCornerShape(16.dp))
            .background(Color.White),
        contentAlignment = Alignment.Center
    ) {
        when {
            isLoading -> {
                CircularProgressIndicator(
                    modifier = Modifier.size(48.dp),
                    strokeWidth = 3.dp
                )
            }
            qrCodeImage != null -> {
                Image(
                    bitmap = qrCodeImage,
                    contentDescription = "配对 QR 码",
                    modifier = Modifier
                        .fillMaxSize()
                        .padding(16.dp)
                )
            }
            else -> {
                Column(
                    horizontalAlignment = Alignment.CenterHorizontally,
                    verticalArrangement = Arrangement.spacedBy(8.dp)
                ) {
                    Icon(
                        imageVector = Icons.Default.QrCode,
                        contentDescription = null,
                        modifier = Modifier.size(48.dp),
                        tint = Color.Gray
                    )
                    Text(
                        text = "QR 码生成失败",
                        style = MaterialTheme.typography.bodyMedium,
                        color = Color.Gray
                    )
                }
            }
        }

        // 刷新动画
        if (isLoading) {
            val infiniteTransition = rememberInfiniteTransition(label = "rotation")
            val rotation by infiniteTransition.animateFloat(
                initialValue = 0f,
                targetValue = 360f,
                animationSpec = infiniteRepeatable(
                    animation = tween(1000, easing = LinearEasing),
                    repeatMode = RepeatMode.Restart
                ),
                label = "rotation"
            )

            Icon(
                imageVector = Icons.Default.Refresh,
                contentDescription = "刷新中",
                modifier = Modifier
                    .size(24.dp)
                    .rotate(rotation),
                tint = MaterialTheme.colorScheme.primary
            )
        }
    }
}

@Composable
private fun DeviceInfoCard(
    deviceName: String,
    deviceId: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Text(
                text = "设备信息",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Medium
            )

            Text(
                text = deviceName,
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface
            )

            Text(
                text = "设备ID: ${deviceId.takeLast(8)}",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
private fun PairingStatusCard(
    status: PairingStatus,
    errorMessage: String?,
    onRefresh: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = when (status) {
                PairingStatus.SUCCESS -> MaterialTheme.colorScheme.primaryContainer
                PairingStatus.FAILED -> MaterialTheme.colorScheme.errorContainer
                else -> MaterialTheme.colorScheme.surfaceVariant
            }
        )
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically,
            horizontalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Icon(
                imageVector = when (status) {
                    PairingStatus.SUCCESS -> Icons.Default.CheckCircle
                    PairingStatus.FAILED -> Icons.Default.Error
                    PairingStatus.WAITING -> Icons.Default.QrCodeScanner
                    PairingStatus.EXPIRED -> Icons.Default.AccessTime
                },
                contentDescription = null,
                tint = when (status) {
                    PairingStatus.SUCCESS -> MaterialTheme.colorScheme.primary
                    PairingStatus.FAILED -> MaterialTheme.colorScheme.error
                    else -> MaterialTheme.colorScheme.onSurfaceVariant
                }
            )

            Column(modifier = Modifier.weight(1f)) {
                Text(
                    text = when (status) {
                        PairingStatus.SUCCESS -> "配对成功"
                        PairingStatus.FAILED -> "配对失败"
                        PairingStatus.WAITING -> "等待配对"
                        PairingStatus.EXPIRED -> "QR 码已过期"
                    },
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium
                )

                if (status == PairingStatus.FAILED && errorMessage != null) {
                    Text(
                        text = errorMessage,
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorScheme.error
                    )
                }
            }

            if (status == PairingStatus.FAILED || status == PairingStatus.EXPIRED) {
                IconButton(onClick = onRefresh) {
                    Icon(
                        imageVector = Icons.Default.Refresh,
                        contentDescription = "刷新 QR 码"
                    )
                }
            }
        }
    }
}

@Composable
private fun ActionButtons(
    onRefresh: () -> Unit,
    onShare: () -> Unit,
    isRefreshing: Boolean,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        OutlinedButton(
            onClick = onRefresh,
            enabled = !isRefreshing,
            modifier = Modifier.weight(1f)
        ) {
            if (isRefreshing) {
                CircularProgressIndicator(
                    modifier = Modifier.size(16.dp),
                    strokeWidth = 2.dp
                )
                Spacer(modifier = Modifier.width(8.dp))
            }
            Text("刷新")
        }

        Button(
            onClick = onShare,
            modifier = Modifier.weight(1f)
        ) {
            Icon(
                imageVector = Icons.Default.Share,
                contentDescription = null,
                modifier = Modifier.size(18.dp)
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text("分享")
        }
    }
}
```

#### QR 码扫描界面
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/screens/QRCodeScannerScreen.kt
package com.nearclip.ui.screens

import androidx.camera.core.*
import androidx.camera.view.PreviewView
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.geometry.Size
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalLifecycleOwner
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.compose.ui.viewinterop.AndroidView
import androidx.core.content.ContextCompat
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.nearclip.ui.viewmodel.QRCodeScannerViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun QRCodeScannerScreen(
    onClose: () -> Unit,
    onPairingSuccess: () -> Unit,
    viewModel: QRCodeScannerViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()
    val context = LocalContext.current
    val lifecycleOwner = LocalLifecycleOwner.current

    LaunchedEffect(Unit) {
        viewModel.startScanning()
    }

    LaunchedEffect(uiState.scanningResult) {
        when (uiState.scanningResult) {
            is ScanningResult.SUCCESS -> onPairingSuccess()
            is ScanningResult.ERROR -> {
                // 显示错误提示
            }
            else -> { /* No action needed */ }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("扫描 QR 码") },
                navigationIcon = {
                    IconButton(onClick = onClose) {
                        Icon(Icons.Default.Close, contentDescription = "关闭")
                    }
                }
            )
        }
    ) { paddingValues ->
        Box(modifier = Modifier.fillMaxSize()) {
            // 相机预览
            AndroidView(
                factory = { ctx ->
                    PreviewView(ctx).apply {
                        implementationMode = PreviewView.ImplementationMode.COMPATIBLE
                    }
                },
                modifier = Modifier.fillMaxSize()
            ) { previewView ->
                viewModel.setupCamera(previewView, lifecycleOwner)
            }

            // 扫描框覆盖层
            ScanningOverlay(
                modifier = Modifier.fillMaxSize(),
                isScanning = uiState.isScanning
            )

            // 状态指示器
            Column(
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
                    .padding(24.dp),
                verticalArrangement = Arrangement.SpaceBetween
            ) {
                // 顶部提示
                ScanningInstructions(
                    modifier = Modifier.align(Alignment.CenterHorizontally)
                )

                // 底部状态
                ScanningStatus(
                    status = uiState.scanningResult,
                    isScanning = uiState.isScanning,
                    onRetry = { viewModel.startScanning() },
                    modifier = Modifier.align(Alignment.CenterHorizontally)
                )
            }
        }
    }
}

@Composable
private fun ScanningOverlay(
    modifier: Modifier = Modifier,
    isScanning: Boolean
) {
    Canvas(modifier = modifier) {
        val strokeWidth = 4.dp.toPx()
        val cornerLength = 40.dp.toPx()
        val boxSize = size.width * 0.7f
        val boxStart = Offset(
            x = (size.width - boxSize) / 2,
            y = (size.height - boxSize) / 2
        )
        val boxEnd = Offset(
            x = boxStart.x + boxSize,
            y = boxStart.y + boxSize
        )

        // 绘制四个角的扫描框
        if (isScanning) {
            // 左上角
            drawLine(
                color = Color.White,
                start = boxStart,
                end = Offset(boxStart.x + cornerLength, boxStart.y),
                strokeWidth = strokeWidth
            )
            drawLine(
                color = Color.White,
                start = boxStart,
                end = Offset(boxStart.x, boxStart.y + cornerLength),
                strokeWidth = strokeWidth
            )

            // 右上角
            drawLine(
                color = Color.White,
                start = Offset(boxEnd.x - cornerLength, boxStart.y),
                end = boxEnd,
                strokeWidth = strokeWidth
            )
            drawLine(
                color = Color.White,
                start = Offset(boxEnd.x, boxStart.y),
                end = Offset(boxEnd.x, boxStart.y + cornerLength),
                strokeWidth = strokeWidth
            )

            // 左下角
            drawLine(
                color = Color.White,
                start = Offset(boxStart.x, boxEnd.y - cornerLength),
                end = Offset(boxStart.x, boxEnd.y),
                strokeWidth = strokeWidth
            )
            drawLine(
                color = Color.White,
                start = boxStart,
                end = Offset(boxStart.x + cornerLength, boxEnd.y),
                strokeWidth = strokeWidth
            )

            // 右下角
            drawLine(
                color = Color.White,
                start = Offset(boxEnd.x - cornerLength, boxEnd.y),
                end = boxEnd,
                strokeWidth = strokeWidth
            )
            drawLine(
                color = Color.White,
                start = Offset(boxEnd.x, boxEnd.y - cornerLength),
                end = boxEnd,
                strokeWidth = strokeWidth
            )
        }

        // 绘制半透明背景
        drawRect(
            color = Color.Black.copy(alpha = 0.5f),
            size = size
        )
    }
}

@Composable
private fun ScanningInstructions(
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = Color.Black.copy(alpha = 0.7f)
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            Icon(
                imageVector = Icons.Default.QrCodeScanner,
                contentDescription = null,
                tint = Color.White,
                modifier = Modifier.size(32.dp)
            )

            Text(
                text = "将 QR 码放入框内",
                style = MaterialTheme.typography.titleMedium,
                color = Color.White,
                fontWeight = FontWeight.Medium
            )

            Text(
                text = "保持设备稳定，等待自动识别",
                style = MaterialTheme.typography.bodyMedium,
                color = Color.White.copy(alpha = 0.8f),
                textAlign = TextAlign.Center
            )
        }
    }
}

@Composable
private fun ScanningStatus(
    status: ScanningResult,
    isScanning: Boolean,
    onRetry: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = when (status) {
                is ScanningResult.SUCCESS -> Color(0xFF4CAF50).copy(alpha = 0.9f)
                is ScanningResult.ERROR -> Color(0xFFF44336).copy(alpha = 0.9f)
                else -> Color.Black.copy(alpha = 0.7f)
            }
        )
    ) {
        Column(
            modifier = Modifier.padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            when (status) {
                is ScanningResult.SUCCESS -> {
                    Icon(
                        imageVector = Icons.Default.CheckCircle,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(32.dp)
                    )
                    Text(
                        text = "配对成功",
                        style = MaterialTheme.typography.titleMedium,
                        color = Color.White,
                        fontWeight = FontWeight.Medium
                    )
                }
                is ScanningResult.ERROR -> {
                    Icon(
                        imageVector = Icons.Default.Error,
                        contentDescription = null,
                        tint = Color.White,
                        modifier = Modifier.size(32.dp)
                    )
                    Text(
                        text = "扫描失败",
                        style = MaterialTheme.typography.titleMedium,
                        color = Color.White,
                        fontWeight = FontWeight.Medium
                    )
                    Text(
                        text = status.message,
                        style = MaterialTheme.typography.bodyMedium,
                        color = Color.White.copy(alpha = 0.8f),
                        textAlign = TextAlign.Center
                    )
                    Button(
                        onClick = onRetry,
                        colors = ButtonDefaults.buttonColors(
                            containerColor = Color.White,
                            contentColor = Color(0xFFF44336)
                        )
                    ) {
                        Icon(
                            imageVector = Icons.Default.Refresh,
                            contentDescription = null,
                            modifier = Modifier.size(16.dp)
                        )
                        Spacer(modifier = Modifier.width(8.dp))
                        Text("重试")
                    }
                }
                else -> {
                    if (isScanning) {
                        CircularProgressIndicator(
                            modifier = Modifier.size(32.dp),
                            strokeWidth = 3.dp,
                            color = Color.White
                        )
                        Text(
                            text = "正在扫描...",
                            style = MaterialTheme.typography.titleMedium,
                            color = Color.White,
                            fontWeight = FontWeight.Medium
                        )
                    } else {
                        Icon(
                            imageVector = Icons.Default.QrCodeScanner,
                            contentDescription = null,
                            tint = Color.White,
                            modifier = Modifier.size(32.dp)
                        )
                        Text(
                            text = "准备扫描",
                            style = MaterialTheme.typography.titleMedium,
                            color = Color.White,
                            fontWeight = FontWeight.Medium
                        )
                    }
                }
            }
        }
    }
}
```

### Mac QR 码功能实现

#### SwiftUI QR 码显示界面
```swift
// src/platform/mac/NearClip/Sources/Views/QRCodeDisplayView.swift
import SwiftUI
import CoreImage.CIFilterBuiltins

struct QRCodeDisplayView: View {
    @ObservedObject var qrPairingManager: QRPairingManager
    @State private var qrCodeImage: NSImage?
    @State private var isGenerating = false
    @State private var pairingStatus: PairingStatus = .waiting

    var body: some View {
        VStack(spacing: 24) {
            // Header
            headerView

            // QR Code Display
            qrCodeDisplayView

            // Device Info
            deviceInfoView

            // Status
            statusView

            // Actions
            actionButtons

            Spacer()
        }
        .frame(width: 400, height: 500)
        .onAppear {
            generateQRCode()
        }
    }

    private var headerView: some View {
        HStack {
            Text("设备配对")
                .font(.title2)
                .fontWeight(.semibold)

            Spacer()

            Button(action: { /* Close action */ }) {
                Image(systemName: "xmark.circle.fill")
                    .font(.title2)
                    .foregroundColor(.secondary)
            }
            .buttonStyle(BorderlessButtonStyle())
        }
        .padding(.horizontal, 20)
        .padding(.top, 20)
    }

    private var qrCodeDisplayView: some View {
        VStack(spacing: 16) {
            Text("让其他设备扫描此 QR 码进行配对")
                .font(.headline)
                .multilineTextAlignment(.center)

            ZStack {
                RoundedRectangle(cornerRadius: 16)
                    .fill(Color.white)
                    .frame(width: 280, height: 280)
                    .shadow(radius: 10)

                if let qrCodeImage = qrCodeImage {
                    Image(nsImage: qrCodeImage)
                        .resizable()
                        .interpolation(.none)
                        .frame(width: 240, height: 240)
                } else if isGenerating {
                    ProgressView()
                        .scaleEffect(1.5)
                } else {
                    VStack(spacing: 12) {
                        Image(systemName: "qrcode")
                            .font(.system(size: 48))
                            .foregroundColor(.secondary)
                        Text("QR 码生成失败")
                            .font(.headline)
                            .foregroundColor(.secondary)
                    }
                }
            }

            Text("QR 码将在 5 分钟后过期")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.horizontal, 20)
    }

    private var deviceInfoView: some View {
        VStack(alignment: .leading, spacing: 8) {
            Text("设备信息")
                .font(.subheadline)
                .fontWeight(.semibold)

            HStack {
                Image(systemName: "computer")
                    .foregroundColor(.accentColor)

                Text(qrPairingManager.deviceName)
                    .font(.body)

                Spacer()

                Text("ID: \(String(qrPairingManager.deviceId.suffix(8)))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
        .padding(.horizontal, 20)
    }

    private var statusView: some View {
        HStack(spacing: 12) {
            statusIcon

            VStack(alignment: .leading, spacing: 4) {
                Text(statusTitle)
                    .font(.subheadline)
                    .fontWeight(.medium)

                if let statusMessage = statusMessage {
                    Text(statusMessage)
                        .font(.caption)
                        .foregroundColor(.secondary)
                }
            }

            Spacer()

            if needsRefresh {
                Button("刷新") {
                    generateQRCode()
                }
                .buttonStyle(.bordered)
            }
        }
        .padding()
        .background(statusBackgroundColor.opacity(0.1))
        .cornerRadius(8)
        .padding(.horizontal, 20)
    }

    private var actionButtons: some View {
        HStack(spacing: 12) {
            Button(action: generateQRCode) {
                HStack {
                    Image(systemName: "arrow.clockwise")
                    Text("刷新")
                }
            }
            .buttonStyle(.bordered)
            .disabled(isGenerating)

            Button(action: shareQRCode) {
                HStack {
                    Image(systemName: "square.and.arrow.up")
                    Text("分享")
                }
            }
            .buttonStyle(.borderedProminent)
        }
        .padding(.horizontal, 20)
    }

    private var statusIcon: some View {
        Image(systemName: statusIconName)
            .foregroundColor(statusColor)
    }

    private var statusIconName: String {
        switch pairingStatus {
        case .success:
            return "checkmark.circle.fill"
        case .failed:
            return "xmark.circle.fill"
        case .expired:
            return "clock.fill"
        case .waiting:
            return "qrcode"
        }
    }

    private var statusColor: Color {
        switch pairingStatus {
        case .success:
            return .green
        case .failed:
            return .red
        case .expired:
            return .orange
        case .waiting:
            return .blue
        }
    }

    private var statusTitle: String {
        switch pairingStatus {
        case .success:
            return "配对成功"
        case .failed:
            return "配对失败"
        case .expired:
            return "QR 码已过期"
        case .waiting:
            return "等待配对"
        }
    }

    private var statusMessage: String? {
        switch pairingStatus {
        case .failed:
            return "请检查 QR 码是否有效"
        case .expired:
            return "请生成新的 QR 码"
        default:
            return nil
        }
    }

    private var statusBackgroundColor: Color {
        switch pairingStatus {
        case .success:
            return .green
        case .failed:
            return .red
        case .expired:
            return .orange
        case .waiting:
            return .blue
        }
    }

    private var needsRefresh: Bool {
        pairingStatus == .failed || pairingStatus == .expired
    }

    private func generateQRCode() {
        isGenerating = true
        pairingStatus = .waiting

        Task {
            do {
                qrCodeImage = try await qrPairingManager.generateQRCode()
                pairingStatus = .waiting
                startPairingTimeout()
            } catch {
                print("Failed to generate QR code: \(error)")
                pairingStatus = .failed
            }
            isGenerating = false
        }
    }

    private func startPairingTimeout() {
        Task {
            try await Task.sleep(nanoseconds: 5 * 60 * 1_000_000_000) // 5 minutes
            if pairingStatus == .waiting {
                pairingStatus = .expired
            }
        }
    }

    private func shareQRCode() {
        guard let qrCodeImage = qrCodeImage else { return }

        let pasteboard = NSPasteboard.general
        pasteboard.clearContents()
        pasteboard.writeObjects([qrCodeImage])

        // Show notification
        let notification = NSUserNotification()
        notification.title = "QR 码已复制"
        notification.informativeText = "QR 码已复制到剪贴板"
        notification.soundName = NSUserNotificationDefaultSoundName
        NSUserNotificationCenter.default.deliver(notification)
    }
}

enum PairingStatus {
    case waiting
    case success
    case failed
    case expired
}

#Preview {
    QRCodeDisplayView(qrPairingManager: QRPairingManager.preview)
}
```

#### QR 码扫描界面
```swift
// src/platform/mac/NearClip/Sources/Views/QRCodeScannerView.swift
import SwiftUI
import AVFoundation
import Vision

struct QRCodeScannerView: View {
    @StateObject private var cameraManager = CameraManager()
    @State private var scanningState: ScanningState = .idle
    @State private var errorMessage: String?

    var body: some View {
        ZStack {
            // Camera preview
            CameraPreviewView(cameraManager: cameraManager)
                .ignoresSafeArea()

            // Scanning overlay
            ScanningOverlayView(state: scanningState)

            // UI overlay
            VStack {
                // Header
                headerView

                Spacer()

                // Status and instructions
                statusView

                Spacer()

                // Actions
                actionButtons
            }
            .padding()
        }
        .onAppear {
            startScanning()
        }
        .onDisappear {
            cameraManager.stopSession()
        }
        .onChange(of: cameraManager.qrCodeResult) { result in
            handleQRCodeResult(result)
        }
    }

    private var headerView: some View {
        HStack {
            Button("取消") {
                // Handle cancel
            }
            .buttonStyle(.bordered)

            Spacer()

            Text("扫描 QR 码")
                .font(.title2)
                .fontWeight(.semibold)

            Spacer()

            // Placeholder for symmetry
            Color.clear
                .frame(width: 60)
        }
        .padding(.top, 10)
    }

    private var statusView: some View {
        VStack(spacing: 16) {
            switch scanningState {
            case .idle:
                statusContent(
                    icon: "qrcode",
                    title: "准备扫描",
                    message: "将 QR 码放入扫描框内"
                )

            case .scanning:
                statusContent(
                    icon: "viewfinder",
                    title: "正在扫描...",
                    message: "保持设备稳定"
                )

            case .processing:
                statusContent(
                    icon: "gear.circle",
                    title: "处理中",
                    message: "正在验证配对信息"
                )

            case .success:
                statusContent(
                    icon: "checkmark.circle.fill",
                    title: "配对成功",
                    message: "设备已成功配对"
                )
                .foregroundColor(.green)

            case .failed(let message):
                statusContent(
                    icon: "xmark.circle.fill",
                    title: "扫描失败",
                    message: message
                )
                .foregroundColor(.red)
            }
        }
        .padding()
        .background(.thinMaterial)
        .cornerRadius(12)
        .padding(.horizontal)
    }

    private func statusContent(icon: String, title: String, message: String) -> some View {
        VStack(spacing: 12) {
            Image(systemName: icon)
                .font(.system(size: 32))

            Text(title)
                .font(.headline)
                .fontWeight(.semibold)

            Text(message)
                .font(.subheadline)
                .multilineTextAlignment(.center)
        }
    }

    private var actionButtons: some View {
        HStack(spacing: 16) {
            switch scanningState {
            case .failed:
                Button("重试") {
                    startScanning()
                }
                .buttonStyle(.borderedProminent)

            default:
                Button("手动输入") {
                    // Show manual input dialog
                }
                .buttonStyle(.bordered)
            }
        }
        .padding(.bottom, 20)
    }

    private func startScanning() {
        scanningState = .scanning
        errorMessage = nil
        cameraManager.startSession()
    }

    private func handleQRCodeResult(_ result: Result<String, Error>) {
        switch result {
        case .success(let qrData):
            scanningState = .processing
            processQRCodeData(qrData)
        case .failure(let error):
            scanningState = .failed(error.localizedDescription)
        }
    }

    private func processQRCodeData(_ data: String) {
        Task {
            do {
                // Process QR code data through pairing manager
                let success = try await QRPairingManager.processQRCode(data)

                if success {
                    scanningState = .success
                    // Auto-close after success
                    try await Task.sleep(nanoseconds: 2_000_000_000)
                    // Close scanner view
                } else {
                    scanningState = .failed("无效的配对信息")
                }
            } catch {
                scanningState = .failed(error.localizedDescription)
            }
        }
    }
}

enum ScanningState: Equatable {
    case idle
    case scanning
    case processing
    case success
    case failed(String)
}

struct ScanningOverlayView: View {
    let state: ScanningState
    @State private var animationPhase = 0.0

    var body: some View {
        GeometryReader { geometry in
            let scanRect = calculateScanRect(size: geometry.size)

            ZStack {
                // Semi-transparent background
                Color.black.opacity(0.6)
                    .mask(
                        RoundedRectangle(cornerRadius: 20)
                            .frame(width: scanRect.width, height: scanRect.height)
                            .blendMode(.destinationOut)
                    )

                // Corner brackets
                if state == .scanning {
                    cornerBracket(at: CGPoint(x: scanRect.minX, y: scanRect.minY), corner: .topLeft)
                    cornerBracket(at: CGPoint(x: scanRect.maxX, y: scanRect.minY), corner: .topRight)
                    cornerBracket(at: CGPoint(x: scanRect.minX, y: scanRect.maxY), corner: .bottomLeft)
                    cornerBracket(at: CGPoint(x: scanRect.maxX, y: scanRect.maxY), corner: .bottomRight)

                    // Scanning line animation
                    scanningLine(rect: scanRect)
                }
            }
        }
    }

    private func cornerBracket(at point: CGPoint, corner: CornerType) -> some View {
        Path { path in
            let length: CGFloat = 20
            let thickness: CGFloat = 3

            switch corner {
            case .topLeft:
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x + length, y: point.y))
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x, y: point.y + length))
            case .topRight:
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x - length, y: point.y))
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x, y: point.y + length))
            case .bottomLeft:
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x + length, y: point.y))
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x, y: point.y - length))
            case .bottomRight:
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x - length, y: point.y))
                path.move(to: point)
                path.addLine(to: CGPoint(x: point.x, y: point.y - length))
            }
        }
        .stroke(Color.green, lineWidth: 3)
    }

    private func scanningLine(rect: CGRect) -> some View {
        let lineHeight: CGFloat = 2
        let scanHeight = rect.height - 20

        return Rectangle()
            .fill(Color.green)
            .frame(width: rect.width - 40, height: lineHeight)
            .cornerRadius(1)
            .offset(
                x: 20,
                y: rect.minY + 10 + (sin(animationPhase) * 0.5 + 0.5) * scanHeight
            )
            .onAppear {
                withAnimation(.easeInOut(duration: 2).repeatForever(autoreverses: false)) {
                    animationPhase = .pi * 2
                }
            }
    }

    private func calculateScanRect(size: CGSize) -> CGRect {
        let scanSize = min(size.width, size.height) * 0.7
        let x = (size.width - scanSize) / 2
        let y = (size.height - scanSize) / 2
        return CGRect(x: x, y: y, width: scanSize, height: scanSize)
    }

    enum CornerType {
        case topLeft, topRight, bottomLeft, bottomRight
    }
}

#Preview {
    QRCodeScannerView()
}
```

### 相机管理器

#### Mac CameraManager
```swift
// src/platform/mac/NearClip/Sources/Services/CameraManager.swift
import AVFoundation
import Vision
import Combine

class CameraManager: NSObject, ObservableObject {
    @Published var qrCodeResult: Result<String, Error>?
    @Published var isSessionRunning = false

    private var captureSession: AVCaptureSession?
    private var videoOutput: AVCaptureVideoDataOutput?
    private var sessionQueue = DispatchQueue(label: "camera.session.queue")
    private var captureDevice: AVCaptureDevice?

    override init() {
        super.init()
        setupCamera()
    }

    private func setupCamera() {
        sessionQueue.async { [weak self] in
            self?.configureSession()
        }
    }

    private func configureSession() {
        let session = AVCaptureSession()
        session.beginConfiguration()

        // Set session preset
        session.sessionPreset = .high

        // Add video input
        guard let videoDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: .unspecified),
              let videoInput = try? AVCaptureDeviceInput(device: videoDevice) else {
            print("Failed to get video input")
            return
        }

        if session.canAddInput(videoInput) {
            session.addInput(videoInput)
            self.captureDevice = videoDevice
        } else {
            print("Could not add video input")
            return
        }

        // Add video output
        let videoOutput = AVCaptureVideoDataOutput()
        videoOutput.setSampleBufferDelegate(self, queue: DispatchQueue(label: "video.output.queue"))
        videoOutput.alwaysDiscardsLateVideoFrames = true

        if session.canAddOutput(videoOutput) {
            session.addOutput(videoOutput)
            self.videoOutput = videoOutput
        } else {
            print("Could not add video output")
            return
        }

        session.commitConfiguration()
        self.captureSession = session
    }

    func startSession() {
        sessionQueue.async { [weak self] in
            guard let session = self?.captureSession else { return }

            if !session.isRunning {
                session.startRunning()
                DispatchQueue.main.async {
                    self?.isSessionRunning = true
                }
            }
        }
    }

    func stopSession() {
        sessionQueue.async { [weak self] in
            guard let session = self?.captureSession else { return }

            if session.isRunning {
                session.stopRunning()
                DispatchQueue.main.async {
                    self?.isSessionRunning = false
                }
            }
        }
    }

    func switchCamera() {
        sessionQueue.async { [weak self] in
            self?.configureNewCamera()
        }
    }

    private func configureNewCamera() {
        guard let currentSession = captureSession,
              let currentInput = currentSession.inputs.first as? AVCaptureDeviceInput else { return }

        let newPosition: AVCaptureDevice.Position = currentInput.device.position == .back ? .front : .back

        guard let newDevice = AVCaptureDevice.default(.builtInWideAngleCamera, for: .video, position: newPosition),
              let newInput = try? AVCaptureDeviceInput(device: newDevice) else { return }

        currentSession.beginConfiguration()
        currentSession.removeInput(currentInput)

        if currentSession.canAddInput(newInput) {
            currentSession.addInput(newInput)
            captureDevice = newDevice
        } else {
            currentSession.addInput(currentInput)
        }

        currentSession.commitConfiguration()
    }
}

extension CameraManager: AVCaptureVideoDataOutputSampleBufferDelegate {
    func captureOutput(_ output: AVCaptureOutput, didOutput sampleBuffer: CMSampleBuffer, from connection: AVCaptureConnection) {
        guard let pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) else { return }

        // Create Vision request
        let request = VNDetectBarcodesRequest { [weak self] request, error in
            if let error = error {
                DispatchQueue.main.async {
                    self?.qrCodeResult = .failure(error)
                }
                return
            }

            guard let observations = request.results as? [VNBarcodeObservation],
                  let firstObservation = observations.first,
                  let payload = firstObservation.payloadStringValue else {
                return
            }

            DispatchQueue.main.async {
                self?.qrCodeResult = .success(payload)
            }
        }

        // Configure request for QR codes
        request.symbologies = [.qr]

        // Perform request
        let handler = VNImageRequestHandler(cvPixelBuffer: pixelBuffer, orientation: .right, options: [:])
        try? handler.perform([request])
    }
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | 初始故事创建，添加 QR 码配对功能 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写