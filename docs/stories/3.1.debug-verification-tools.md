# Story 3.1: 开发调试与验证工具

## Status
Draft

## Story
**作为** 开发者/测试人员，
**我希望** 能够在开发过程中手动发送测试消息到其他设备，
**以便** 快速验证跨设备通信、加密传输和基础同步功能是否正常工作。

## Acceptance Criteria
1. 实现调试模式的手动消息发送界面
2. 支持自定义文本内容的跨设备传输
3. 提供通信过程的详细日志和状态反馈
4. 验证加密传输的端到端完整性
5. 测量实际的网络延迟和传输质量
6. 记录通信成功率和错误统计
7. **重要**：此功能仅在调试/开发模式下启用，不包含在正式用户版本中

## Tasks / Subtasks
- [ ] 设计调试工具架构 (AC: 1, 2)
  - [ ] 创建调试模式开关和权限验证
  - [ ] 设计调试界面组件结构
  - [ ] 实现跨平台调试界面一致性
  - [ ] 创建调试配置管理系统
  - [ ] 实现调试数据持久化
- [ ] 实现消息发送功能 (AC: 2, 3)
  - [ ] 创建文本输入和消息编辑界面
  - [ ] 实现跨设备消息传输协议
  - [ ] 添加消息格式化和验证
  - [ ] 创建消息历史记录功能
  - [ ] 实现批量消息发送
- [ ] 实现通信过程监控 (AC: 3, 4)
  - [ ] 创建实时日志显示组件
  - [ ] 实现网络状态监控
  - [ ] 添加加密/解密过程跟踪
  - [ ] 创建消息传输状态指示
  - [ ] 实现错误捕获和显示
- [ ] 实现性能测量功能 (AC: 5)
  - [ ] 创建网络延迟测量工具
  - [ ] 实现传输质量评估
  - [ ] 添加吞吐量统计
  - [ ] 创建性能图表和趋势分析
  - [ ] 实现性能基准对比
- [ ] 实现统计和报告功能 (AC: 6)
  - [ ] 创建通信成功率统计
  - [ ] 实现错误分类和计数
  - [ ] 添加通信日志导出功能
  - [ ] 创建测试报告生成器
  - [ ] 实现数据可视化图表
- [ ] 实现安全验证功能 (AC: 4, 7)
  - [ ] 创建加密完整性验证工具
  - [ ] 实现端到端消息完整性检查
  - [ ] 添加中间人攻击检测
  - [ ] 创建安全测试套件
  - [ ] 实现调试模式安全控制
- [ ] 创建高级调试功能
  - [ ] 实现网络模拟和压力测试
  - [ ] 添加协议消息查看器
  - [ ] 创建数据包捕获和分析
  - [ ] 实现远程调试接口
  - [ ] 添加调试自动化脚本

## Dev Notes

### 调试工具架构设计
[Source: architecture/components.md]

#### 调试模式配置
```protobuf
// src/shared/protocol/debug.proto
syntax = "proto3";

package nearclip.debug;

// 调试配置
protocol DebugConfig {
  bool debug_mode_enabled = 1;
  bool verbose_logging = 2;
  bool network_monitoring = 3;
  bool performance_profiling = 4;
  bool security_analysis = 5;
  LogLevel min_log_level = 6;
  repeated string enabled_features = 7;
  map<string, string> custom_settings = 8;
}

enum LogLevel {
  LOG_UNKNOWN = 0;
  LOG_DEBUG = 1;
  LOG_INFO = 2;
  LOG_WARNING = 3;
  LOG_ERROR = 4;
  LOG_CRITICAL = 5;
}

// 调试消息
protocol DebugMessage {
  string message_id = 1;
  MessageType type = 2;
  bytes payload = 3;
  string text_content = 4;
  int64 timestamp = 5;
  string sender_id = 6;
  repeated string recipient_ids = 7;
  DebugMetadata metadata = 8;
}

enum MessageType {
  TYPE_UNKNOWN = 0;
  TYPE_TEXT_MESSAGE = 1;
  TYPE_BINARY_DATA = 2;
  TYPE_PING = 3;
  TYPE_PONG = 4;
  TYPE_DIAGNOSTIC = 5;
  TYPE_PERFORMANCE_TEST = 6;
}

// 调试元数据
protocol DebugMetadata {
  int32 message_size = 1;
  int32 compression_ratio = 2;
  int32 encryption_overhead = 3;
  repeated string processing_steps = 4;
  int64 transmission_time_ms = 5;
  int64 processing_time_ms = 6;
}

// 性能指标
protocol PerformanceMetrics {
  string test_id = 1;
  PerformanceTestType test_type = 2;
  int64 start_time = 3;
  int64 end_time = 4;
  int32 message_count = 5;
  int64 total_bytes = 6;
  double throughput_bps = 7;
  double average_latency_ms = 8;
  double jitter_ms = 9;
  double packet_loss_rate = 10;
  int32 errors = 11;
}

enum PerformanceTestType {
  TEST_UNKNOWN = 0;
  TEST_LATENCY = 1;
  TEST_THROUGHPUT = 2;
  TEST_STRESS = 3;
  TEST_CONCURRENT = 4;
  TEST_RELIABILITY = 5;
}

// 安全分析结果
protocol SecurityAnalysis {
  string analysis_id = 1;
  SecurityCheckType check_type = 2;
  bool passed = 3;
  string description = 4;
  repeated SecurityIssue issues = 5;
  repeated SecurityRecommendation recommendations = 6;
  int64 timestamp = 7;
}

enum SecurityCheckType {
  CHECK_UNKNOWN = 0;
  CHECK_ENCRYPTION_VALIDITY = 1;
  CHECK_MESSAGE_INTEGRITY = 2;
  CHECK_MITM_DETECTION = 3;
  CHECK_REPLAY_ATTACK = 4;
  CHECK_CERTIFICATE_VALIDITY = 5;
}

protocol SecurityIssue {
  Severity severity = 1;
  string description = 2;
  string affected_component = 3;
  string recommendation = 4;
}

enum Severity {
  SEVERITY_UNKNOWN = 0;
  SEVERITY_LOW = 1;
  SEVERITY_MEDIUM = 2;
  SEVERITY_HIGH = 3;
  SEVERITY_CRITICAL = 4;
}
```

#### Rust 调试管理器
```rust
// src/shared/rust/src/debug/manager.rs
use chrono::{DateTime, Utc, Duration};
use std::collections::{HashMap, VecDeque};
use std::sync::Arc;
use tokio::sync::{RwLock, mpsc};
use tokio::time::{interval, sleep, timeout};
use serde::{Deserialize, Serialize};
use log::{info, warn, error, debug};
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct DebugManager {
    config: Arc<RwLock<DebugConfig>>,
    message_sender: mpsc::UnboundedSender<DebugMessage>,
    metrics_collector: Arc<MetricsCollector>,
    security_analyzer: Arc<SecurityAnalyzer>,
    is_enabled: Arc<RwLock<bool>>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebugConfig {
    pub debug_mode_enabled: bool,
    pub verbose_logging: bool,
    pub network_monitoring: bool,
    pub performance_profiling: bool,
    pub security_analysis: bool,
    pub min_log_level: LogLevel,
    pub enabled_features: Vec<String>,
    pub custom_settings: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebugMessage {
    pub message_id: String,
    pub message_type: MessageType,
    pub payload: Vec<u8>,
    pub text_content: Option<String>,
    pub timestamp: DateTime<Utc>,
    pub sender_id: String,
    pub recipient_ids: Vec<String>,
    pub metadata: DebugMetadata,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum MessageType {
    TextMessage,
    BinaryData,
    Ping,
    Pong,
    Diagnostic,
    PerformanceTest,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DebugMetadata {
    pub message_size: i32,
    pub compression_ratio: Option<i32>,
    pub encryption_overhead: Option<i32>,
    pub processing_steps: Vec<String>,
    pub transmission_time_ms: Option<i64>,
    pub processing_time_ms: Option<i64>,
}

#[derive(Debug, Clone)]
pub struct MetricsCollector {
    performance_metrics: Arc<RwLock<VecDeque<PerformanceMetrics>>>,
    connection_stats: Arc<RwLock<ConnectionStatistics>>,
    error_stats: Arc<RwLock<ErrorStatistics>>,
}

#[derive(Debug, Clone)]
pub struct ConnectionStatistics {
    pub total_messages: i64,
    pub successful_messages: i64,
    pub failed_messages: i64,
    pub total_bytes: i64,
    pub average_latency: f64,
    pub uptime: Duration,
    pub last_activity: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub struct ErrorStatistics {
    pub total_errors: i64,
    pub error_counts: HashMap<String, i64>,
    pub recent_errors: VecDeque<ErrorRecord>,
    pub last_error: Option<ErrorRecord>,
}

#[derive(Debug, Clone)]
pub struct ErrorRecord {
    pub error_id: String,
    pub error_type: String,
    pub message: String,
    pub timestamp: DateTime<Utc>,
    pub context: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct SecurityAnalyzer {
    analysis_results: Arc<RwLock<VecDeque<SecurityAnalysis>>>,
    issue_tracker: Arc<RwLock<VecDeque<SecurityIssue>>>,
}

#[derive(Debug, Clone)]
pub struct SecurityAnalysis {
    pub analysis_id: String,
    pub check_type: SecurityCheckType,
    pub passed: bool,
    pub description: String,
    pub issues: Vec<SecurityIssue>,
    pub recommendations: Vec<SecurityRecommendation>,
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Clone)]
pub struct SecurityIssue {
    pub severity: Severity,
    pub description: String,
    pub affected_component: String,
    pub recommendation: String,
}

#[derive(Debug, Clone)]
pub struct SecurityRecommendation {
    pub priority: i32,
    pub description: String,
    pub implementation_steps: Vec<String>,
}

impl DebugManager {
    pub new() -> Self {
        let (message_sender, message_receiver) = mpsc::unbounded_channel();

        let manager = Self {
            config: Arc::new(RwLock::new(DebugConfig::default())),
            message_sender,
            metrics_collector: Arc::new(MetricsCollector::new()),
            security_analyzer: Arc::new(SecurityAnalyzer::new()),
            is_enabled: Arc::new(RwLock::new(false)),
        };

        // 启动后台任务
        manager.start_background_tasks(message_receiver);

        manager
    }

    /// 启用调试模式
    pub async fn enable_debug_mode(&self, config: DebugConfig) -> Result<(), DebugError> {
        // 验证配置
        self.validate_config(&config)?;

        // 更新配置
        {
            let mut config_lock = self.config.write().await;
            *config_lock = config.clone();
        }

        // 启用调试模式
        {
            let mut enabled = self.is_enabled.write().await;
            *enabled = true;
        }

        info!("Debug mode enabled");
        Ok(())
    }

    /// 禁用调试模式
    pub async fn disable_debug_mode(&self) {
        let mut enabled = self.is_enabled.write().await;
        *enabled = false;
        info!("Debug mode disabled");
    }

    /// 发送调试消息
    pub async fn send_debug_message(
        &self,
        message_type: MessageType,
        content: Option<String>,
        recipients: Vec<String>,
    ) -> Result<String, DebugError> {
        if !self.is_enabled.read().await {
            return Err(DebugError::DebugModeDisabled);
        }

        let config = self.config.read().await;
        if !config.debug_mode_enabled {
            return Err(DebugError::DebugModeDisabled);
        }

        let message_id = Uuid::new_v4().to_string();
        let timestamp = Utc::now();

        // 准备消息载荷
        let payload = match message_type {
            MessageType::TextMessage => {
                let content = content.unwrap_or_default();
                content.as_bytes().to_vec()
            }
            MessageType::BinaryData => {
                // 这里应该从某个地方获取二进制数据
                vec![] // 实际实现中应该有参数传入
            }
            MessageType::Ping | MessageType::Pong => {
                vec![]
            }
            _ => vec![],
        };

        let metadata = DebugMetadata {
            message_size: payload.len() as i32,
            compression_ratio: None,
            encryption_overhead: None,
            processing_steps: vec![
                "Message creation".to_string(),
                "Validation".to_string(),
                "Queueing".to_string(),
            ],
            transmission_time_ms: None,
            processing_time_ms: Some(Utc::now().timestamp_millis() as i64 - timestamp.timestamp_millis() as i64),
        };

        let message = DebugMessage {
            message_id: message_id.clone(),
            message_type,
            payload,
            text_content: content,
            timestamp,
            sender_id: "debug_client".to_string(), // 应该从配置中获取
            recipient_ids: recipients,
            metadata,
        };

        // 发送消息
        self.message_sender.send(message)
            .map_err(|_| DebugError::MessageSendFailed)?;

        info!("Sent debug message: {}", message_id);
        Ok(message_id)
    }

    /// 发送性能测试
    pub async fn send_performance_test(
        &self,
        test_type: PerformanceTestType,
        target_device: String,
        test_params: PerformanceTestParams,
    ) -> Result<String, DebugError> {
        if !self.is_enabled.read().await {
            return Err(DebugError::DebugModeDisabled);
        }

        let test_id = Uuid::new_v4().to_string();
        let start_time = Utc::now();

        // 创建性能测试消息
        let test_message = DebugMessage {
            message_id: test_id.clone(),
            message_type: MessageType::PerformanceTest,
            payload: serde_json::to_vec(&test_params).unwrap_or_default(),
            text_content: Some(format!("Performance test: {:?}", test_type)),
            timestamp: start_time,
            sender_id: "debug_client".to_string(),
            recipient_ids: vec![target_device],
            metadata: DebugMetadata {
                message_size: 0,
                compression_ratio: None,
                encryption_overhead: None,
                processing_steps: vec!["Performance test initiated".to_string()],
                transmission_time_ms: None,
                processing_time_ms: None,
            },
        };

        self.message_sender.send(test_message)
            .map_err(|_| DebugError::MessageSendFailed)?;

        info!("Started performance test: {} ({})", test_id, test_type);
        Ok(test_id)
    }

    /// 执行安全分析
    pub async fn perform_security_analysis(
        &self,
        check_type: SecurityCheckType,
        target_data: &[u8],
    ) -> Result<String, DebugError> {
        if !self.is_enabled.read().await {
            return Err(DebugError::DebugModeDisabled);
        }

        let analysis_id = Uuid::new_v4().to_string();
        let timestamp = Utc::now();

        // 执行安全检查
        let result = match check_type {
            SecurityCheckType::EncryptionValidity => {
                self.check_encryption_validity(target_data)
            }
            SecurityCheckType::MessageIntegrity => {
                self.check_message_integrity(target_data)
            }
            SecurityCheckType::MitmDetection => {
                self.check_mitm_detection(target_data)
            }
            SecurityCheckType::ReplayAttack => {
                self.check_replay_attack(target_data)
            }
            SecurityCheckType::CertificateValidity => {
                self.check_certificate_validity(target_data)
            }
        };

        let (passed, issues, recommendations) = match result {
            Ok((issues, recs)) => (issues.is_empty(), issues, recs),
            Err(err) => (false, vec![], vec![SecurityRecommendation {
                priority: 1,
                description: format!("Security check failed: {}", err),
                implementation_steps: vec![
                    "检查网络连接安全性".to_string(),
                    "验证目标设备身份".to_string(),
                ],
            }]),
        };

        let analysis = SecurityAnalysis {
            analysis_id: analysis_id.clone(),
            check_type,
            passed,
            description: format!("Security analysis: {:?}", check_type),
            issues,
            recommendations,
            timestamp,
        };

        // 保存分析结果
        let mut results = self.security_analyzer.analysis_results.write().await;
        results.push_back(analysis);

        // 如果有安全问题，添加到问题跟踪器
        for issue in &analysis.issues {
            let mut tracker = self.security_analyzer.issue_tracker.write().await;
            tracker.push_back(issue.clone());
        }

        info!("Completed security analysis: {} ({})", analysis_id, check_type);
        Ok(analysis_id)
    }

    /// 获取性能指标
    pub async fn get_performance_metrics(&self, limit: Option<usize>) -> Vec<PerformanceMetrics> {
        let metrics = self.metrics_collector.performance_metrics.read().await;
        let len = metrics.len();

        if let Some(limit) = limit {
            metrics.range(len.saturating_sub(limit)).cloned().collect()
        } else {
            metrics.iter().cloned().collect()
        }
    }

    /// 获取连接统计
    pub async fn get_connection_statistics(&self) -> ConnectionStatistics {
        self.metrics_collector.connection_stats.read().await.clone()
    }

    /// 获取错误统计
    pub async fn get_error_statistics(&self) -> ErrorStatistics {
        self.metrics_collector.error_stats.read().await.clone()
    }

    /// 获取安全分析结果
    pub async fn get_security_analysis_results(&self, limit: Option<usize>) -> Vec<SecurityAnalysis> {
        let results = self.security_analyzer.analysis_results.read().await;
        let len = results.len();

        if let Some(limit) = limit {
            results.range(len.saturating_sub(limit)).cloned().collect()
        } else {
            results.iter().cloned().collect()
        }
    }

    /// 清理调试数据
    pub async fn cleanup_debug_data(&self, older_than: Duration) {
        let cutoff = Utc::now() - older_than;

        // 清理性能指标
        {
            let mut metrics = self.metrics_collector.performance_metrics.write().await;
            while let Some(front) = metrics.front() {
                if front.end_time < cutoff {
                    metrics.pop_front();
                } else {
                    break;
                }
            }
        }

        // 清理错误记录
        {
            let mut errors = self.metrics_collector.error_stats.write().await;
            while let Some(front) = errors.recent_errors.front() {
                if front.timestamp < cutoff {
                    errors.recent_errors.pop_front();
                } else {
                    break;
                }
            }
        }

        // 清理安全分析结果
        {
            let mut results = self.security_analyzer.analysis_results.write().await;
            while let Some(front) = results.front() {
                if front.timestamp < cutoff {
                    results.pop_front();
                } else {
                    break;
                }
            }
        }

        info!("Cleaned up debug data older than {:?}", older_than);
    }

    // 私有方法实现
    fn validate_config(&self, config: &DebugConfig) -> Result<(), DebugError> {
        if config.debug_mode_enabled && !config.network_monitoring {
            warn!("Debug mode enabled without network monitoring");
        }

        if config.security_analysis && !config.debug_mode_enabled {
            return Err(DebugError::InvalidConfig("Security analysis requires debug mode"));
        }

        Ok(())
    }

    fn start_background_tasks(&self, mut message_receiver: mpsc::UnboundedReceiver<DebugMessage>) {
        let metrics_collector = self.metrics_collector.clone();
        let security_analyzer = self.security_analyzer.clone();
        let is_enabled = self.is_enabled.clone();

        // 启动消息处理任务
        tokio::spawn(async move {
            while let Some(message) = message_receiver.recv().await {
                if *is_enabled.read().await {
                    Self::process_debug_message(message, &metrics_collector, &security_analyzer).await;
                }
            }
        });

        // 启动性能监控任务
        let metrics_collector_clone = metrics_collector.clone();
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(1));
            loop {
                interval.tick().await;
                if *is_enabled.read().await {
                    Self::update_performance_metrics(&metrics_collector_clone).await;
                }
            }
        });
    }

    async fn process_debug_message(
        message: DebugMessage,
        metrics_collector: &Arc<MetricsCollector>,
        security_analyzer: &Arc<SecurityAnalyzer>,
    ) {
        // 更新连接统计
        Self::update_connection_stats(message, metrics_collector).await;

        // 执行安全分析（如果启用）
        if message.payload.len() > 0 {
            if let Err(e) = Self::analyze_message_security(&message, security_analyzer).await {
                warn!("Security analysis failed: {}", e);
            }
        }
    }

    async fn update_connection_stats(
        message: DebugMessage,
        metrics_collector: &Arc<MetricsCollector>,
    ) {
        let mut stats = metrics_collector.connection_stats.write().await;

        stats.total_messages += 1;

        // 假设消息成功发送（实际应该根据传输结果更新）
        stats.successful_messages += 1;

        stats.total_bytes += message.payload.len() as i64;
        stats.last_activity = Utc::now();

        // 计算平均延迟（简化实现）
        if let Some(processing_time) = message.metadata.processing_time_ms {
            stats.average_latency = (stats.average_latency * (stats.total_messages - 1) as f64
                + processing_time as f64) / stats.total_messages as f64;
        }
    }

    async fn analyze_message_security(
        message: &DebugMessage,
        security_analyzer: &Arc<SecurityAnalyzer>,
    ) -> Result<(), Box<dyn std::error::Error>> {
        // 简化的安全检查实现
        let timestamp = Utc::now();

        // 检查消息完整性
        let hash = Self::calculate_message_hash(&message.payload);

        if let Some(expected_hash) = message.metadata.processing_steps.get(0) {
            if expected_hash != &hash {
                let issue = SecurityIssue {
                    severity: Severity::High,
                    description: "Message hash mismatch detected".to_string(),
                    affected_component: "MessageProcessor".to_string(),
                    recommendation: "Verify message integrity check implementation".to_string(),
                };

                let mut tracker = security_analyzer.issue_tracker.write().await;
                tracker.push_back(issue);

                return Err("Message integrity check failed".into());
            }
        }

        Ok(())
    }

    fn calculate_message_hash(data: &[u8]) -> String {
        use sha2::{Sha256, Digest};
        let mut hasher = Sha256::new();
        hasher.update(data);
        format!("{:x}", hasher.finalize())
    }

    async fn update_performance_metrics(metrics_collector: &Arc<MetricsCollector>) {
        // 更新运行时间统计
        let mut stats = metrics_collector.connection_stats.write().await;
        if let Some(start_time) = stats.uptime.checked_sub(Duration::from_secs(0)) {
            stats.uptime = start_time;
        }
    }

    // 安全检查方法
    fn check_encryption_validity(&self, data: &[u8]) -> Result<(Vec<SecurityIssue>, Vec<SecurityRecommendation>), String> {
        // 实现加密有效性检查
        let mut issues = Vec::new();
        let mut recommendations = Vec::new();

        // 检查数据是否被正确加密
        if data.len() < 16 {
            issues.push(SecurityIssue {
                severity: Severity::High,
                description: "Data appears to be unencrypted or too short".to_string(),
                affected_component: "EncryptionModule".to_string(),
                recommendation: "Ensure all sensitive data is properly encrypted".to_string(),
            });
        }

        Ok((issues, recommendations))
    }

    fn check_message_integrity(&self, data: &[u8]) -> Result<(Vec<SecurityIssue>, Vec<SecurityRecommendation>), String> {
        // 实现消息完整性检查
        Ok((Vec::new(), Vec::new()))
    }

    fn check_mitm_detection(&self, data: &[u8]) -> Result<(Vec<SecurityIssue>, Vec<SecurityRecommendation>), String> {
        // 实现中间人攻击检测
        Ok((Vec::new(), Vec::new()))
    }

    fn check_replay_attack(&self, data: &[u8]) -> Result<(Vec<SecurityIssue>, Vec<SecurityRecommendation>), String> {
        // 实现重放攻击检测
        Ok((Vec::new(), Vec::new()))
    }

    fn check_certificate_validity(&self, data: &[u8]) -> Result<(Vec<SecurityIssue>, Vec<SecurityRecommendation>), String> {
        // 实现证书有效性检查
        Ok((Vec::new(), Vec::new()))
    }
}

#[derive(Debug, Clone)]
pub struct PerformanceTestParams {
    pub message_size: i32,
    pub message_count: i32,
    pub interval_ms: i64,
    pub test_duration_ms: i64,
    pub data_pattern: String,
}

#[derive(Debug, Clone)]
pub struct PerformanceMetrics {
    pub test_id: String,
    pub test_type: PerformanceTestType,
    pub start_time: DateTime<Utc>,
    pub end_time: DateTime<Utc>,
    pub message_count: i32,
    pub total_bytes: i64,
    pub throughput_bps: f64,
    pub average_latency_ms: f64,
    pub jitter_ms: f64,
    pub packet_loss_rate: f64,
    pub errors: i32,
}

impl Default for DebugConfig {
    fn default() -> Self {
        Self {
            debug_mode_enabled: false,
            verbose_logging: false,
            network_monitoring: false,
            performance_profiling: false,
            security_analysis: false,
            min_log_level: LogLevel::Info,
            enabled_features: Vec::new(),
            custom_settings: HashMap::new(),
        }
    }
}

impl Default for ConnectionStatistics {
    fn default() -> Self {
        Self {
            total_messages: 0,
            successful_messages: 0,
            failed_messages: 0,
            total_bytes: 0,
            average_latency: 0.0,
            uptime: Duration::from_secs(0),
            last_activity: Utc::now(),
        }
    }
}

impl Default for ErrorStatistics {
    fn default() -> Self {
        Self {
            total_errors: 0,
            error_counts: HashMap::new(),
            recent_errors: VecDeque::new(),
            last_error: None,
        }
    }
}

impl Default for MetricsCollector {
    fn new() -> Self {
        Self {
            performance_metrics: Arc::new(RwLock::new(VecDeque::with_capacity(1000))),
            connection_stats: Arc::new(RwLock::new(ConnectionStatistics::default())),
            error_stats: Arc::new(RwLock::new(ErrorStatistics::default())),
        }
    }
}

impl Default for SecurityAnalyzer {
    fn new() -> Self {
        Self {
            analysis_results: Arc::new(RwLock::new(VecDeque::with_capacity(1000))),
            issue_tracker: Arc::new(RwLock::new(VecDeque::with_capacity(1000))),
        }
    }
}

#[derive(Debug, Clone)]
pub enum DebugError {
    DebugModeDisabled,
    InvalidConfig(String),
    MessageSendFailed,
    InvalidParameters(String),
    SecurityCheckFailed(String),
}
```

### Android 调试界面实现

#### DebugActivity
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/DebugActivity.kt
package com.nearclip.ui.debug

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.android.compose.HiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.nearclip.ui.debug.components.*
import com.nearclip.ui.viewmodel.DebugViewModel

class DebugActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            DebugScreen()
        }
    }
}

@Composable
fun DebugScreen(
    viewModel: DebugViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    LaunchedEffect(Unit) {
        viewModel.initializeDebugMode()
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("调试工具") },
                navigationIcon = {
                    IconButton(onClick = { finish() }) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "返回")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = Modifier
                .fillMaxSize()
                .padding(paddingValues)
        ) {
            // Debug Status
            DebugStatusCard(
                isDebugEnabled = uiState.isDebugEnabled,
                debugConfig = uiState.debugConfig,
                onToggleDebug = { enabled ->
                    viewModel.toggleDebugMode(enabled)
                }
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Message Sender
            MessageSenderCard(
                onSendMessage = { text, recipients ->
                    viewModel.sendDebugMessage(text, recipients)
                },
                onSendPing = { targets ->
                    viewModel.sendPing(targets)
                },
                onPerformanceTest = { target, params ->
                    viewModel.startPerformanceTest(target, params)
                },
                onSecurityAnalysis = { data ->
                    viewModel.performSecurityAnalysis(data)
                }
            )

            Spacer(modifier = Modifier.height(16.dp))

            // Metrics Display
            MetricsDisplayCard(
                connectionStats = uiState.connectionStats,
                performanceMetrics = uiState.performanceMetrics,
                errorStats = uiState.errorStats,
                securityResults = uiState.securityResults,
                onRefresh = { viewModel.refreshMetrics() }
            )

            // Log Viewer
            if (uiState.debugConfig.verboseLogging) {
                Spacer(modifier = Modifier.height(16.dp))
                LogViewerCard(
                    logs = uiState.recentLogs,
                    onClearLogs = { viewModel.clearLogs() }
                )
            }
        }
    }
}

@Composable
private fun DebugStatusCard(
    isDebugEnabled: Boolean,
    debugConfig: DebugConfig,
    onToggleDebug: (Boolean) -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            horizontalArrangement = Arrangement.SpaceBetween,
            verticalAlignment = Alignment.CenterVertically
        ) {
            Column(
                verticalArrangement = Arrangement.Center,
                horizontalAlignment = Alignment.Start
            ) {
                Text(
                    text = "调试模式",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium
                )

                Text(
                    text = if (isDebugEnabled) "已启用" else "已禁用",
                    style = MaterialTheme.typography.bodyMedium,
                    color = if (isDebugEnabled) {
                        MaterialTheme.colorScheme.primary
                    } else {
                        MaterialTheme.colorScheme.onSurfaceVariant
                    }
                )
            }

            Switch(
                checked = isDebugEnabled,
                onCheckedChange = onToggleDebug,
                enabled = true
            )
        }
    }
}

@Composable
private fun MessageSenderCard(
    onSendMessage: (String, List<String>) -> Unit,
    onSendPing: (List<String>) -> Unit,
    onPerformanceTest: (String, PerformanceTestParams) -> Unit,
    onSecurityAnalysis: (ByteArray) -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = Modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Text(
                text = "消息发送器",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Medium
            )

            // Text Input
            var messageText by remember { mutableStateOf("") }
            OutlinedTextField(
                value = messageText,
                onValueChange = { messageText = it },
                label = { Text("测试消息") },
                placeholder = { Text("输入要发送的测试消息...") },
                modifier = Modifier.fillMaxWidth(),
                maxLines = 3
            )

            // Device Selection
            var selectedDevices by remember { mutableStateOf(listOf<String>()) }
            Text(
                text = "目标设备: ${selectedDevices.join(", ")}",
                style = MaterialTheme.typography.bodyMedium,
                modifier = Modifier.padding(vertical = 8.dp)
            )

            // Action Buttons
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                Button(
                    onClick = { /* 显示设备选择对话框 */ },
                    modifier = Modifier.weight(1f)
                ) {
                    Text("选择设备")
                }

                Button(
                    onClick = {
                        if (messageText.isNotEmpty() && selectedDevices.isNotEmpty()) {
                            onSendMessage(messageText, selectedDevices)
                        }
                    },
                    modifier = Modifier.weight(1f),
                    enabled = messageText.isNotEmpty() && selectedDevices.isNotEmpty()
                ) {
                    Text("发送消息")
                }
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                OutlinedButton(
                    onClick = {
                        if (selectedDevices.isNotEmpty()) {
                            onSendPing(selectedDevices)
                        }
                    },
                    modifier = Modifier.weight(1f),
                    enabled = selectedDevices.isNotEmpty()
                ) {
                    Icon(Icons.Default.Speed, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("发送 Ping")
                }

                OutlinedButton(
                    onClick = { /* 显示性能测试对话框 */ },
                    modifier = Modifier.weight(1f)
                ) {
                    Icon(Icons.Default.Speed, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("性能测试")
                }

                OutlinedButton(
                    onClick = {
                        val testData = messageText.toByteArray()
                        if (testData.isNotEmpty()) {
                            onSecurityAnalysis(testData)
                        }
                    },
                    modifier = Modifier.weight(1f),
                    enabled = messageText.isNotEmpty()
                ) {
                    Icon(Icons.Default.Security, contentDescription = null, modifier = Modifier.size(16.dp))
                    Spacer(modifier = Modifier.width(4.dp))
                    Text("安全分析")
                }
            }
        }
    }
}

@Composable
private fun MetricsDisplayCard(
    connectionStats: ConnectionStatistics,
    performanceMetrics: List<PerformanceMetrics>,
    errorStats: ErrorStatistics,
    securityResults: List<SecurityAnalysis>,
    onRefresh: () -> Unit,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier.fillMaxWidth(),
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                Text(
                    text = "性能指标",
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium
                )

                IconButton(onClick = onRefresh) {
                    Icon(Icons.Default.Refresh, contentDescription = "刷新")
                }
            }

            // Connection Stats
            ConnectionStatsView(stats = connectionStats)

            Divider()

            // Performance Metrics
            if (performanceMetrics.isNotEmpty()) {
                PerformanceMetricsView(metrics = performanceMetrics.takeLast(5))
                Divider()
            }

            // Error Stats
            ErrorStatsView(stats = errorStats)

            // Security Results
            if (securityResults.isNotEmpty()) {
                SecurityResultsView(results = securityResults.takeLast(3))
            }
        }
    }
}

@Composable
private fun ConnectionStatsView(stats: ConnectionStatistics) {
    Column {
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text("连接统计", style = MaterialTheme.typography.titleSmall, fontWeight = FontWeight.Medium))
            Text(
                text = "运行时间: ${formatDuration(stats.uptime)}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly
        ) {
            StatItem(
                label = "总消息",
                value = stats.totalMessages.toString()
            )
            StatItem(
                label = "成功",
                value = stats.successfulMessages.toString(),
                color = Color(0xFF4CAF50)
            )
            StatItem(
                label = "失败",
                value = stats.failed_messages.toString(),
                color = Color(0xFFF44336)
            )
            StatItem(
                label = "平均延迟",
                value = "${String.format("%.1f", stats.average_latency)}ms"
            )
        }

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text(
                text = "数据传输",
                style = MaterialTheme.typography.titleSmall,
                fontWeight = FontWeight.Medium
            )
            Text(
                text = "总字节: ${formatBytes(stats.total_bytes)}",
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
private fun PerformanceMetricsView(
    metrics: List<PerformanceMetrics>
) {
    Column {
        Text(
            text = "性能测试结果",
            style = MaterialTheme.typography.titleSmall,
            fontWeight = FontWeight.Medium
        )

        metrics.forEach { metric ->
            PerformanceMetricItem(metric = metric)
        }
    }
}

@Composable
private fun PerformanceMetricItem(
    metric: PerformanceMetrics
) {
    Card(
        modifier = Modifier
            .fillMaxWidth()
            .padding(vertical = 8.dp),
        elevation = CardDefaults.cardElevation(defaultElevation = 1.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(12.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween
            ) {
                Text(
                    text = formatTestType(metric.testType),
                    style = MaterialTheme.typography.bodyMedium,
                    fontWeight = FontWeight.Medium
                )
                Text(
                    text = "${formatDuration(metric.end_time - metric.start_time)}",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }

            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                StatItem(
                    label = "消息数",
                    value = metric.message_count.toString()
                )
                StatItem(
                    label = "吞吐量",
                    value = formatThroughput(metric.throughput_bps)
                )
                StatItem(
                    label = "延迟",
                    value = "${String.format("%.1f", metric.average_latency_ms)}ms"
                )
                StatItem(
                    label = "抖动",
                    value = "${String.format("%.1f", metric.jitter_ms)}ms"
                )
                StatItem(
                    label = "错误",
                    value = metric.errors.toString(),
                    color = if (metric.errors > 0) Color(0xFFF44336) else Color(0xFF4CAF50)
                )
            }
        }
    }
}

@Composable
private fun ErrorStatsView(stats: ErrorStatistics) {
    Column {
        Text(
            text = "错误统计",
            style = MaterialTheme.typography.titleSmall,
            fontWeight = FontWeight.Medium
        )

        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceBetween
        ) {
            Text("总错误", style = MaterialTheme.typography.bodyMedium, fontWeight = FontWeight.Medium))
            Text(
                text = stats.total_errors.toString(),
                color = if (stats.total_errors > 0) Color(0xFFF44336) else Color(0xFF4CAF50)
            )
        }

        if (stats.total_errors > 0) {
            // 显示最近错误
            Text(
                text = "最近错误",
                style = MaterialTheme.typography.bodySmall,
                fontWeight = FontWeight.Medium
            )

            stats.recentErrors.take(3).forEach { error ->
                Card(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 4.dp)
                ) {
                    Text(
                        text = error.message,
                        style = MaterialTheme.typography.bodySmall,
                        maxLines = 2,
                        overflow = TextOverflow.Ellipsis
                    )
                    Text(
                        text = formatDateTime(error.timestamp),
                        style = MaterialTheme.typography.bodySmall,
                        color = MaterialTheme.colorTheme.onSurfaceVariant
                    )
                }
            }
        }
    }
}

@Composable
private fun SecurityResultsView(
    results: List<SecurityAnalysis>
) {
    Column {
        Text(
            text = "安全分析结果",
            style = MaterialTheme.typography.titleSmall,
            fontWeight = FontWeight.Medium
        )

        results.forEach { result ->
            Card(
                modifier = Modifier
                    .fillMaxWidth()
                    .padding(vertical = 4.dp)
            ) {
                Row(
                    modifier = Modifier
                        .fillMaxWidth(),
                        horizontalArrangement = Arrangement.SpaceBetween,
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Text(
                        text = formatSecurityCheckType(result.checkType),
                        style = MaterialTheme.typography.bodyMedium,
                        fontWeight = FontWeight.Medium
                    )

                    if (result.passed) {
                        Icon(
                            imageVector = Icons.Default.CheckCircle,
                            contentDescription = null,
                            tint = Color(0xFF4CAF50),
                            modifier = Modifier.size(20.dp)
                        )
                    } else {
                        Icon(
                            imageVector = Icons.Error,
                            contentDescription = null,
                            tint = Color(0xFFF44336),
                            modifier = Modifier.size(20.dp)
                        )
                    }
                }

                if (!result.issues.isEmpty()) {
                    Text(
                        text = "发现问题: ${result.issues.size}",
                        style = MaterialTheme.typography.bodySmall,
                        color = Color(0xFFF44336)
                    )
                }
            }
        }
    }
}

@Composable
private fun StatItem(
    label: String,
    value: String,
    color: Color = Color.Unspecified,
    modifier: Modifier = Modifier
) {
    Column(
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = label,
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant
        )
        Text(
            text = value,
            style = MaterialTheme.typography.bodyMedium,
            fontWeight = FontWeight.Medium,
            color = if color != Color.Unspecified) color else MaterialTheme.colorScheme.onSurface
        )
    }
}

// 辅助函数
private fun formatDuration(duration: Duration): String {
    val seconds = duration.seconds
    if (seconds < 60) {
        return "${seconds}秒"
    } else if (seconds < 3600) {
        val minutes = seconds / 60
        return "${minutes}分钟"
    } else {
        val hours = seconds / 3600
        return "${hours}小时"
    }
}

private fun formatBytes(bytes: i64): String {
    val kb = bytes / 1024.0
    if (kb < 1.0) {
        return "${bytes}B"
    } else if (kb < 1024.0) {
        return "${String.format("%.1f", kb)}KB"
    } else {
        val mb = kb / 1024.0
        return "${String.format("%.1f", mb)}MB"
    }
}

private fun formatTestType(testType: PerformanceTestType): String {
    return when (testType) {
        PerformanceTestType.Latency -> "延迟测试"
        PerformanceTestType.Throughput -> "吞吐量测试"
        PerformanceTestType.Stress -> "压力测试"
        PerformanceTestType.Concurrent -> "并发测试"
        PerformanceTestType.Reliability -> "可靠性测试"
    }
}

private fun formatSecurityCheckType(checkType: SecurityCheckType): String {
    return when (checkType) {
        SecurityCheckType.EncryptionValidity -> "加密有效性"
        SecurityCheckType.MessageIntegrity -> "消息完整性"
        SecurityCheckType.MitmDetection -> "中间人攻击检测"
        SecurityCheckType.ReplayAttack -> "重放攻击检测"
        SecurityCheckType.CertificateValidity -> "证书有效性"
    }
}

private fun formatDateTime(timestamp: Long): String {
    val formatter = java.text.SimpleDateFormat("HH:mm:ss", java.util.Locale.getDefault())
    return formatter.format(java.util.Date(timestamp))
}
```

### Mac 调试界面实现

#### SwiftUI DebugView
```swift
// src/platform/mac/NearClip/Sources/Views/DebugView.swift
import SwiftUI

struct DebugView: View {
    @ObservedObject var debugManager: DebugManager
    @State private var selectedDevices: Set<String> = []
    @State private var messageText = ""
    @State private var showingDeviceSelector = false
    @State private var showingPerformanceTestDialog = false
    @State private var showingSecurityAnalysisDialog = false

    var body: some View {
        VStack(spacing: 0) {
            // Header
            headerView

            Divider()

            // Debug Status
            debugStatusView

            Divider()

            // Message Sender
            messageSenderView

            Divider()

            // Metrics Display
            metricsScrollView

            Spacer()
        }
        .frame(width: 600, height: 700)
        .sheet(isPresented: $showingDeviceSelector) {
            DeviceSelectorView(
                selectedDevices: $selectedDevices,
                onDismiss: { showingDeviceSelector = false }
            )
        }
        .sheet(isPresented: $showingPerformanceTestDialog) {
            PerformanceTestDialog(
                selectedDevices: Array(selectedDevices),
                onDismiss: { showingPerformanceTestDialog = false },
                onTest: { params in
                    debugManager.startPerformanceTest(
                        targets: Array(selectedDevices),
                        params: params
                    )
                }
            )
        }
        .sheet(isPresented: $showingSecurityAnalysisDialog) {
            SecurityAnalysisDialog(
                testData: messageText.data(using: .utf8),
                onDismiss: { showingSecurityAnalysisDialog = false },
                onAnalyze: { data in
                    debugManager.performSecurityAnalysis(data: data)
                }
            )
        }
    }

    private var headerView: some View {
        HStack {
            Text("调试工具")
                .font(.title2)
                .fontWeight(.semibold)

            Spacer()

            Button("关闭") {
                NSApp.shared.terminate(nil)
            }
            .buttonStyle(.bordered)
        }
        .padding()
    }

    private var debugStatusView: some View {
        HStack {
            VStack(alignment: .leading, spacing: 4) {
                Text("调试模式")
                    .font(.headline)
                    .fontWeight(.medium)

                Text(debugManager.isEnabled ? "已启用" : "已禁用")
                    .font(.subheadline)
                    .foregroundColor(debugManager.isEnabled ? .green : .secondary)
            }

            Spacer()

            Toggle("启用调试模式", isOn: $debugManager.isEnabled)
                .toggleStyle(.switch)
        }
        .padding()
    }

    private var messageSenderView: some View {
        VStack(alignment: .leading, spacing: 16) {
            Text("消息发送器")
                .font(.headline)
                .fontWeight(.medium)

            // Message Input
            VStack(alignment: .leading, spacing: 8) {
                Text("测试消息")
                    .font(.subheadline)
                    .foregroundColor(.secondary)

                TextEditor(text: $messageText)
                    .frame(minHeight: 60, maxHeight: 120)
                    .background(Color(NSColor.textBackgroundColor))
                    .cornerRadius(8)
                    .overlay(
                        RoundedRectangle(cornerRadius: 8)
                            .stroke(Color.secondary.opacity(0.3), lineWidth: 1)
                    )
            }

            // Device Selection
            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Text("目标设备: \(selectedDevices.count)")
                        .font(.subheadline)
                        .foregroundColor(.secondary)

                    Spacer()

                    Button("选择设备") {
                        showingDeviceSelector = true
                    }
                    .buttonStyle(.bordered)
                }

                if !selectedDevices.isEmpty {
                    ScrollView(.horizontal) {
                        HStack(spacing: 8) {
                            ForEach(Array(selectedDevices.sorted()), id: \.self) { deviceId in
                                Chip(deviceId) {
                                    Text(deviceId.prefix(8))
                                }
                                .onTapGesture {
                                    selectedDevices.remove(deviceId)
                                }
                            }
                        }
                        .padding(.horizontal)
                    }
                }
            }

            // Action Buttons
            VStack(spacing: 12) {
                HStack(spacing: 12) {
                    Button("发送消息") {
                        if !messageText.isEmpty && !selectedDevices.isEmpty {
                            debugManager.sendDebugMessage(
                                type: .text,
                                content: messageText,
                                recipients: Array(selectedDevices)
                            )
                            messageText = ""
                        }
                    }
                    .disabled(messageText.isEmpty || selectedDevices.isEmpty)
                    .buttonStyle(.borderedProminent)
                    .controlSize(.large)

                    Button("发送 Ping") {
                        debugManager.sendPing(targets: Array(selectedDevices))
                    }
                    .disabled(selectedDevices.isEmpty)
                    .buttonStyle(.bordered)
                    .controlSize(.large)

                    Button("性能测试") {
                        showingPerformanceTestDialog = true
                    }
                    .disabled(selectedDevices.isEmpty)
                    .buttonStyle(.bordered)
                    .controlSize(.large)

                    Button("安全分析") {
                        showingSecurityAnalysisDialog = true
                    }
                    .disabled(messageText.isEmpty)
                    .buttonStyle(.bordered)
                    .controlSize(.large)
                }

                HStack(spacing: 12) {
                    Button("清除日志") {
                        debugManager.clearLogs()
                    }
                    .buttonStyle(.bordered)

                    Button("导出报告") {
                        debugManager.exportReport()
                    }
                    .buttonStyle(.borderedProminent)
                }
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }

    private var metricsScrollView: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 16) {
                // Connection Stats
                connectionStatsSection

                // Performance Metrics
                if !debugManager.performanceMetrics.isEmpty {
                    performanceMetricsSection
                }

                // Error Stats
                if debugManager.errorStats.totalErrors > 0 {
                    errorStatsSection
                }

                // Security Results
                if !debugManager.securityAnalysisResults.isEmpty {
                    securityAnalysisSection
                }
            }
            .padding()
        }
    }

    private var connectionStatsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            HStack {
                Text("连接统计")
                    .font(.headline)
                    .fontWeight(.medium)

                Text("运行时间: \(formatDuration(debugManager.connectionStats.uptime))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            LazyVGrid(columns: [
                GridItem(.flex(1)),
                GridItem(.flex(1)),
                GridItem(.flex(1)),
                GridItem(.flex(1))
            ], spacing: 12) {
                StatisticCard(
                    title: "总消息",
                    value: debugManager.connectionStats.totalMessages,
                    color: .blue
                )

                StatisticCard(
                    title: "成功",
                    value: debugManager.connectionStats.successfulMessages,
                    color: .green
                )

                StatisticCard(
                    title: "失败",
                    value: debugManager.connectionStats.failedMessages,
                    color: .red
                )

                StatisticCard(
                    title: "平均延迟",
                    value: String(format: "%.1f ms", debugManager.connectionStats.averageLatency)),
                    color: .orange
                )
            }

            HStack {
                Text("数据传输")
                    .font(.subheadline)
                    .fontWeight(.medium)

                Spacer()

                Text("总字节: \(formatBytes(debugManager.connectionStats.totalBytes))")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }

    private var performanceMetricsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("性能测试结果")
                .font(.headline)
                .fontWeight(.medium)

            LazyVStack(spacing: 8) {
                ForEach(debugManager.performanceMetrics.prefix(5)) { metric in
                    PerformanceMetricCard(metric: metric)
                }
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }

    private var errorStatsSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("错误统计")
                .font(.headline)
                .fontWeight(.medium)

            VStack(alignment: .leading, spacing: 8) {
                HStack {
                    Text("总错误")
                        .font(.subheadline)
                        .fontWeight(.medium)

                    Spacer()

                    Text("\(debugManager.errorStats.totalErrors)")
                        .foregroundColor(.red)
                }

                if !debugManager.errorStats.recentErrors.isEmpty {
                    VStack(alignment: .leading, spacing: 4) {
                        ForEach(debugManager.errorStats.recentErrors.prefix(3)) { error in
                            ErrorCard(error: error)
                        }
                    }
                }
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }

    private var securityAnalysisSection: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("安全分析结果")
                .font(.headline)
                .fontWeight(.medium)

            LazyVStack(spacing: 8) {
                ForEach(debugManager.securityAnalysisResults.prefix(3)) { result in
                    SecurityAnalysisCard(result: result)
                }
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }
}

struct StatisticCard: View {
    let title: String
    let value: Int
    let color: Color

    var body: some View {
        VStack(spacing: 4) {
            Text(value, format: .number)
                .font(.title3)
                .fontWeight(.bold)
                .foregroundColor(color)

            Text(title)
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .frame(maxWidth: .infinity)
        .padding()
        .background(color.opacity(0.1))
        .cornerRadius(6)
    }
}

struct PerformanceMetricCard: View {
    let metric: PerformanceMetrics

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text(formatTestType(metric.testType))
                    .font(.subheadline)
                    .fontWeight(.medium)

                Spacer()

                Text(formatDuration(metric.endTime - metric.startTime))
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            HStack {
                ForEach([
                    ("消息数", metric.messageCount),
                    ("吞吐量", formatThroughput(metric.throughputBps)),
                    ("延迟", "\(String(format: "%.1f", metric.averageLatency))ms"),
                    ("抖动", "\(String(format: "%.1f", metric.jitterMs))ms"),
                    ("错误", metric.errors)
                ], id: \.0) { label, value in
                    StatisticItem(label: label, value: value)
                }
            }

            if !metric.issues.isEmpty {
                Text("发现 \(metric.issues.count) 个问题")
                    .font(.caption)
                    .foregroundColor(.red)
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }
}

struct ErrorCard: View {
    let error: ErrorRecord

    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            Text(error.message)
                .font(.body)
                .lineLimit(2)
                .fixedSize(horizontal: false, vertical: true)

            Text(formatDate(error.timestamp))
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(12)
        .background(Color.red.opacity(0.1))
        .cornerRadius(6)
        .border(Color.red.opacity(0.3), width: 1)
    }
}

struct SecurityAnalysisCard: View {
    let result: SecurityAnalysis

    var body: some View {
        HStack {
            VStack(alignment: .leading, spacing: 8) {
                Text(formatSecurityCheckType(result.checkType))
                    .font(.subheadline)
                    .fontWeight(.medium)

                if result.issues.isEmpty {
                    Text("通过")
                        .foregroundColor(.green)
                } else {
                    Text("失败")
                        .foregroundColor(.red)
                }
            }

            Spacer()

            Image(systemName: result.passed ? "checkmark.circle.fill" : "xmark.circle.fill")
                .foregroundColor(result.passed ? .green : .red)
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(8)
    }
}

struct DeviceSelectorView: View {
    @Binding var selectedDevices: Set<String>
    @Environment(\.dismiss) private var dismiss

    var body: some View {
        VStack(spacing: 16) {
            Text("选择目标设备")
                .font(.headline)

            if availableDevices.isEmpty {
                Text("没有可用的设备")
                    .foregroundColor(.secondary)
                    .padding()
            } else {
                List(availableDevices, id: \.self) { device in
                    HStack {
                        Toggle(isOn: selectedDevices.contains(device.id)) {
                            selectedDevices.toggle(device.id)
                        }
                        Text(device.displayName)
                        Spacer()
                        Text(formatSignalStrength(device.signalStrength))
                            .foregroundColor(getSignalStrengthColor(device.signalStrength))
                    }
                }
            }

            HStack {
                Spacer()
                Button("完成") {
                    dismiss()
                }
                .buttonStyle(.borderedProminent)
            }
        }
        .padding()
        .frame(width: 400, height: 300)
    }
}

struct PerformanceTestDialog: View {
    let selectedDevices: [String]
    let onDismiss: () -> Void
    let onTest: (PerformanceTestParams) -> Void

    @State private var messageSize: Double = 100
    @State private var messageCount: Int = 10
    @State private var intervalMs: Int = 1000
    @State private var testDuration: Int = 10000
    @State private var dataPattern: String = "Test Message"

    var body: some View {
        VStack(spacing: 16) {
            Text("性能测试配置")
                .font(.headline)

            VStack(alignment: .leading, spacing: 12) {
                HStack {
                    Text("消息大小 (bytes):")
                    TextField("大小", value: Binding(
                        get: { messageSize },
                        set: { messageSize = $0 }
                    ))
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .frame(width: 100)
                }

                Stepper(
                    value: $messageCount,
                    in: 1...1000,
                    label: { Text("消息数量") }
                )

                HStack {
                    Text("间隔 (ms):")
                    TextField("间隔", value: Binding(
                        get: { intervalMs },
                        set: { intervalMs = $0 }
                    ))
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .frame(width: 100)
                }

                HStack {
                    Text("持续时间 (ms):")
                    TextField("持续时间", value: Binding(
                        get: { testDuration },
                        set: { testDuration = $0 }
                    ))
                    .textFieldStyle(RoundedBorderTextFieldStyle())
                    .frame(width: 100)
                }
            }

            VStack(alignment: .leading, spacing: 12) {
                Text("数据模式:")
                    .font(.subheadline)

                Picker("数据模式", selection: $dataPattern) {
                    ForEach(["Test Message", "Random Data", "Zero Data", "Pattern Data"], id: \.self) { option in
                        Text(option).tag(option)
                    }
                }
            }

            Text("目标设备: \(selectedDevices.count) 个")
                .font(.caption)
                .foregroundColor(.secondary)

            Spacer()

            HStack {
                Button("取消") {
                    onDismiss()
                }
                .buttonStyle(.bordered)

                Button("开始测试") {
                    let params = PerformanceTestParams(
                        messageSize: Int(messageSize),
                        messageCount: messageCount,
                        intervalMs: intervalMs,
                        testDuration: testDuration,
                        dataPattern: dataPattern
                    )
                    onTest(params)
                }
                .buttonStyle(.borderedProminent)
                .disabled(selectedDevices.isEmpty)
            }
        }
        .padding()
        .frame(width: 400, height: 350)
    }
}

struct SecurityAnalysisDialog: View {
    let testData: Data
    let onDismiss: () -> Void
    let onAnalyze: (Data) -> Void

    var body: some View {
        VStack(spacing: 16) {
            Text("安全分析")
                .font(.headline)

            VStack(alignment: .leading, spacing: 12) {
                Text("待分析数据:")
                    .font(.subheadline)

                Text("\(testData.count) 字节")
                    .font(.caption)
                    .foregroundColor(.secondary)
                    .padding()
                    .background(Color(NSColor.controlBackgroundColor))
                    .cornerRadius(6)
            }

            Spacer()

            HStack {
                Button("取消") {
                    onDismiss()
                }
                .buttonStyle(.bordered)

                Button("开始分析") {
                    onAnalyze(testData)
                }
                .buttonStyle(.borderedProminent)
            }
        }
        .padding()
        .frame(width: 400, height: 200)
    }
}

// 辅助函数
private func formatDuration(_ duration: TimeInterval) -> String {
    let formatter = DateComponentsFormatter()
    let components = formatter.date(from: Date())
    components.units = [.hour, .minute, .second]
    components.allowedUnits = [.hour, .minute, .second]
    return formatter.string(from: Date(timeIntervalSinceNow: duration))
}

private func formatBytes(_ bytes: Int) -> String {
    let formatter = ByteCountFormatter()
    return formatter.string(fromByteCount: Int64(bytes))
}

private func formatTestType(_ type: PerformanceTestType) -> String {
    switch type {
    case .latency:
        return "延迟测试"
    case .throughput:
        return "吞吐量测试"
    case .stress:
        return "压力测试"
    case .concurrent:
        return "并发测试"
    case .reliability:
        return "可靠性测试"
    }
}

private func formatSecurityCheckType(_ type: SecurityCheckType) -> String {
    switch type {
    case .encryptionValidity:
        return "加密有效性"
    case .messageIntegrity:
        return "消息完整性"
    case .mitmDetection:
        return "中间人攻击检测"
    case .replayAttack:
        return "重放攻击检测"
    case .certificateValidity:
        return "证书有效性"
    }
}

private func getSignalStrength(_ strength: Int) -> Color {
    switch strength {
    case 90...100:
        return .green
    case 70..<90:
        return .yellow
    case 50..<70:
        return .orange
    default:
        return .red
    }
}

extension PerformanceTestType: Identifiable {
    var id: String {
        UUID().uuidString
    }
}

// 预览数据
extension DebugManager {
    static var preview: DebugManager {
        let manager = DebugManager()
        manager.config.write().blocking_write(DebugConfig(
            debug_mode_enabled: true,
            verbose_logging: true,
            network_monitoring: true,
            performance_profiling: true,
            security_analysis: true
        ))
        return manager
    }
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | 初始故事创建，添加调试与验证工具 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写