# 故事 4.2: 用户引导体验

## 基本信息
- **故事编号**: 4.2
- **Epic**: Epic 4 - 用户体验与界面优化
- **故事名称**: 用户引导体验
- **优先级**: 高
- **预计工期**: 5 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 新用户，
**我希望** 有清晰友好的引导流程帮助我快速了解和应用功能，
**以便** 我能够轻松上手使用应用，快速实现跨设备粘贴板同步。

## 验收标准

### AC 1: 欢迎与介绍流程
- **欢迎界面**: 美观的欢迎界面，展示应用品牌和核心价值
- **功能介绍**: 通过图文并茂的方式介绍主要功能特性
- **价值主张**: 清晰传达应用如何解决用户痛点
- **用户激励**: 激励用户开始使用的关键信息和行动号召
- **跳过选项**: 允许有经验的用户跳过引导流程

### AC 2: 权限申请引导
- **权限说明**: 清晰解释每个权限的用途和必要性
- **分步申请**: 按需分步申请权限，避免一次性过多请求
- **视觉引导**: 通过动画和视觉元素引导用户完成权限设置
- **权限状态**: 实时显示权限授予状态和缺失权限的影响
- **备用方案**: 为拒绝权限的用户提供替代使用方案

### AC 3: 设备配对引导
- **分步指导**: 详细的设备配对步骤说明和可视化指导
- **实时反馈**: 配对过程中的实时状态反馈和错误处理
- **动画演示**: 通过动画演示配对操作流程
- **故障排除**: 常见配对问题的快速解决方案
- **成功确认**: 配对成功后的明确确认和下一步指导

### AC 4: 首次使用引导
- **功能演示**: 引导用户完成第一次粘贴板同步操作
- **界面探索**: 交互式界面导览，介绍主要功能区域
- **快捷操作**: 教授常用快捷操作和使用技巧
- **个性化设置**: 引导用户完成基本个性化设置
- **使用提示**: 提供实用的使用建议和最佳实践

### AC 5: 渐进式功能发现
- **功能解锁**: 根据用户使用情况逐步解锁高级功能
- **情境提示**: 在合适时机提供相关功能的使用提示
- **使用统计**: 显示用户的使用进度和成就
- **技巧推荐**: 基于使用模式推荐相关功能和技巧
- **帮助资源**: 提供随时可访问的帮助文档和教程

## 技术实现要点

### 1. 引导流程管理器
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/onboarding/OnboardingManager.kt
import androidx.compose.runtime.*
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

data class OnboardingState(
    val currentStep: OnboardingStep = OnboardingStep.WELCOME,
    val isCompleted: Boolean = false,
    val skippedSteps: Set<OnboardingStep> = emptySet(),
    val progress: Float = 0f,
    val canGoBack: Boolean = false,
    val canGoNext: Boolean = true,
)

enum class OnboardingStep {
    WELCOME,
    PERMISSIONS,
    DEVICE_PAIRING,
    FIRST_SYNC,
    INTERFACE_TOUR,
    SETTINGS_INTRO,
    COMPLETED
}

class OnboardingManager : ViewModel() {
    private val _state = MutableStateFlow(OnboardingState())
    val state: StateFlow<OnboardingState> = _state.asStateFlow()

    private val stepHistory = mutableListOf<OnboardingStep>()
    private val stepData = mutableMapOf<OnboardingStep, Any>()

    init {
        loadOnboardingState()
    }

    fun startOnboarding() {
        _state.value = OnboardingState(
            currentStep = OnboardingStep.WELCOME,
            progress = 0f,
            canGoBack = false,
            canGoNext = true
        )
    }

    fun nextStep() {
        val currentState = _state.value
        val nextStep = getNextStep(currentState.currentStep)

        if (nextStep != null) {
            stepHistory.add(currentState.currentStep)
            updateStateForStep(nextStep)
        } else {
            completeOnboarding()
        }
    }

    fun previousStep() {
        val currentState = _state.value
        if (stepHistory.isNotEmpty()) {
            val previousStep = stepHistory.removeLastAt(stepHistory.size - 1)
            updateStateForStep(previousStep)
        }
    }

    fun skipToStep(step: OnboardingStep) {
        val currentState = _state.value
        val stepsToSkip = getStepsBetween(currentState.currentStep, step)

        _state.value = currentState.copy(
            skippedSteps = currentState.skippedSteps + stepsToSkip.toSet()
        )

        updateStateForStep(step)
    }

    fun skipOnboarding() {
        completeOnboarding()
    }

    private fun getNextStep(currentStep: OnboardingStep): OnboardingStep? {
        return when (currentStep) {
            OnboardingStep.WELCOME -> OnboardingStep.PERMISSIONS
            OnboardingStep.PERMISSIONS -> {
                if (areAllPermissionsGranted()) {
                    OnboardingStep.DEVICE_PAIRING
                } else {
                    OnboardingStep.PERMISSIONS // Stay until permissions granted
                }
            }
            OnboardingStep.DEVICE_PAIRING -> {
                if (hasPairedDevices()) {
                    OnboardingStep.FIRST_SYNC
                } else {
                    OnboardingStep.DEVICE_PAIRING // Stay until device paired
                }
            }
            OnboardingStep.FIRST_SYNC -> OnboardingStep.INTERFACE_TOUR
            OnboardingStep.INTERFACE_TOUR -> OnboardingStep.SETTINGS_INTRO
            OnboardingStep.SETTINGS_INTRO -> OnboardingStep.COMPLETED
            OnboardingStep.COMPLETED -> null
        }
    }

    private fun updateStateForStep(step: OnboardingStep) {
        val allSteps = OnboardingStep.values().size
        val currentStepIndex = OnboardingStep.values().indexOf(step)
        val progress = (currentStepIndex.toFloat() / (allSteps - 1)).coerceIn(0f, 1f)

        _state.value = _state.value.copy(
            currentStep = step,
            progress = progress,
            canGoBack = stepHistory.isNotEmpty(),
            canGoNext = canProceedToNext(step)
        )
    }

    private fun completeOnboarding() {
        _state.value = _state.value.copy(
            currentStep = OnboardingStep.COMPLETED,
            isCompleted = true,
            progress = 1f
        )

        saveOnboardingState()

        // 发送完成事件
        viewModelScope.launch {
            onboardingRepository.markOnboardingCompleted()
        }
    }

    private fun canProceedToNext(step: OnboardingStep): Boolean {
        return when (step) {
            OnboardingStep.PERMISSIONS -> areAllPermissionsGranted()
            OnboardingStep.DEVICE_PAIRING -> hasPairedDevices()
            OnboardingStep.FIRST_SYNC -> true // Can retry
            else -> true
        }
    }

    private fun areAllPermissionsGranted(): Boolean {
        return permissionChecker.areAllRequiredPermissionsGranted()
    }

    private fun hasPairedDevices(): Boolean {
        return deviceManager.hasPairedDevices()
    }

    private fun loadOnboardingState() {
        viewModelScope.launch {
            val isCompleted = onboardingRepository.isOnboardingCompleted()
            if (isCompleted) {
                _state.value = _state.value.copy(
                    isCompleted = true,
                    currentStep = OnboardingStep.COMPLETED,
                    progress = 1f
                )
            }
        }
    }

    private fun saveOnboardingState() {
        viewModelScope.launch {
            onboardingRepository.saveOnboardingState(_state.value)
        }
    }

    fun updateStepData(step: OnboardingStep, data: Any) {
        stepData[step] = data
    }

    fun getStepData(step: OnboardingStep): Any? {
        return stepData[step]
    }
}
```

### 2. 欢迎界面组件
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/onboarding/screens/WelcomeScreen.kt
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.painter.Painter
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel

@Composable
fun WelcomeScreen(
    onNext: () -> Unit,
    onSkip: () -> Unit,
    modifier: Modifier = Modifier,
    viewModel: OnboardingManager = hiltViewModel()
) {
    val scrollState = rememberScrollState()

    Column(
        modifier = modifier
            .fillMaxSize()
            .verticalScroll(scrollState)
            .padding(24.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.SpaceBetween
    ) {
        // Top section with logo and title
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier.padding(top = 48.dp)
        ) {
            // Logo
            Image(
                painter = painterResource(id = R.drawable.ic_nearclip_logo_large),
                contentDescription = "NearClip Logo",
                modifier = Modifier.size(120.dp)
            )

            Spacer(modifier = Modifier.height(24.dp))

            // Title
            Text(
                text = "欢迎使用 NearClip",
                style = MaterialTheme.typography.headlineLarge,
                fontWeight = FontWeight.Bold,
                color = MaterialTheme.colorScheme.primary,
                textAlign = TextAlign.Center
            )

            Spacer(modifier = Modifier.height(8.dp))

            // Subtitle
            Text(
                text = "跨设备粘贴板同步工具",
                style = MaterialTheme.typography.titleMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                textAlign = TextAlign.Center
            )
        }

        // Middle section with features
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier.padding(vertical = 32.dp)
        ) {
            FeatureCard(
                icon = painterResource(id = R.drawable.ic_sync),
                title = "即时同步",
                description = "在Android和macOS设备之间实时同步粘贴板内容"
            )

            Spacer(modifier = Modifier.height(16.dp))

            FeatureCard(
                icon = painterResource(id = R.drawable.ic_security),
                title = "安全加密",
                description = "采用端到端加密技术，保护您的数据隐私"
            )

            Spacer(modifier = Modifier.height(16.dp))

            FeatureCard(
                icon = painterResource(id = R.drawable.ic_auto),
                title = "智能自动化",
                description = "自动检测粘贴板变化，无需手动操作"
            )
        }

        // Bottom section with buttons
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            modifier = Modifier.padding(bottom = 32.dp)
        ) {
            NearClipButton(
                text = "开始使用",
                onClick = onNext,
                modifier = Modifier.fillMaxWidth(),
                size = NearClipButtonSize.Large
            )

            Spacer(modifier = Modifier.height(12.dp))

            TextButton(
                onClick = onSkip,
                modifier = Modifier.fillMaxWidth()
            ) {
                Text(
                    text = "跳过引导",
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )
            }
        }
    }
}

@Composable
private fun FeatureCard(
    icon: Painter,
    title: String,
    description: String,
    modifier: Modifier = Modifier
) {
    NearClipCard(
        modifier = modifier.fillMaxWidth(),
        elevation = 0,
        backgroundColor = MaterialTheme.colorScheme.surfaceVariant
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            Icon(
                painter = icon,
                contentDescription = null,
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(32.dp)
            )

            Spacer(modifier = Modifier.width(16.dp))

            Column {
                Text(
                    text = title,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                Spacer(modifier = Modifier.height(4.dp))

                Text(
                    text = description,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant.copy(alpha = 0.7f)
                )
            }
        }
    }
}
```

### 3. 权限引导组件
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/onboarding/screens/PermissionScreen.kt
import androidx.compose.animation.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch

data class PermissionItem(
    val id: String,
    val title: String,
    val description: String,
    val icon: ImageVector,
    val isRequired: Boolean,
    val checkPermission: () -> Boolean,
    val requestPermission: () -> Unit
)

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PermissionScreen(
    onNext: () -> Unit,
    onBack: () -> Unit,
    modifier: Modifier = Modifier,
    viewModel: OnboardingManager = hiltViewModel()
) {
    val scope = rememberCoroutineScope()
    var refreshing by remember { mutableStateOf(false) }

    val permissions = listOf(
        PermissionItem(
            id = "bluetooth",
            title = "蓝牙权限",
            description = "用于发现和连接附近的设备，实现跨设备通信",
            icon = Icons.Default.Bluetooth,
            isRequired = true,
            checkPermission = { permissionChecker.isBluetoothGranted() },
            requestPermission = { permissionChecker.requestBluetoothPermission() }
        ),
        PermissionItem(
            id = "bluetooth_scan",
            title = "蓝牙扫描权限",
            description = "用于扫描和发现附近的NearClip设备",
            icon = Icons.Default.Search,
            isRequired = true,
            checkPermission = { permissionChecker.isBluetoothScanGranted() },
            requestPermission = { permissionChecker.requestBluetoothScanPermission() }
        ),
        PermissionItem(
            id = "bluetooth_connect",
            title = "蓝牙连接权限",
            description = "用于与已发现的设备建立连接",
            icon = Icons.Default.BluetoothConnected,
            isRequired = true,
            checkPermission = { permissionChecker.isBluetoothConnectGranted() },
            requestPermission = { permissionChecker.requestBluetoothConnectPermission() }
        ),
        PermissionItem(
            id = "clipboard",
            title = "粘贴板访问权限",
            description = "用于读取和写入系统粘贴板内容",
            icon = Icons.Default.ContentPaste,
            isRequired = true,
            checkPermission = { permissionChecker.isClipboardAccessGranted() },
            requestPermission = { permissionChecker.requestClipboardAccessPermission() }
        ),
        PermissionItem(
            id = "notification",
            title = "通知权限",
            description = "用于显示接收内容和传输状态通知",
            icon = Icons.Default.Notifications,
            isRequired = false,
            checkPermission = { permissionChecker.isNotificationGranted() },
            requestPermission = { permissionChecker.requestNotificationPermission() }
        ),
        PermissionItem(
            id = "location",
            title = "位置权限",
            description = "Android系统要求蓝牙扫描需要位置权限",
            icon = Icons.Default.LocationOn,
            isRequired = true,
            checkPermission = { permissionChecker.isLocationGranted() },
            requestPermission = { permissionChecker.requestLocationPermission() }
        )
    )

    val scrollState = rememberScrollState()
    val snackbarHostState = remember { SnackbarHostState() }

    LaunchedEffect(Unit) {
        refreshPermissionStatus()
    }

    suspend fun refreshPermissionStatus() {
        refreshing = true
        // Permission status is checked automatically in PermissionItem
        refreshing = false
    }

    val allRequiredGranted = permissions
        .filter { it.isRequired }
        .all { it.checkPermission() }

    LaunchedEffect(allRequiredGranted) {
        if (allRequiredGranted) {
            delay(1000) // Brief pause for visual feedback
            onNext()
        }
    }

    Scaffold(
        snackbarHost = { SnackbarHost(snackbarHostState) },
        topBar = {
            TopAppBar(
                title = { Text("权限设置") },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "返回")
                    }
                },
                actions = {
                    IconButton(onClick = {
                        scope.launch {
                            refreshPermissionStatus()
                        }
                    }) {
                        Icon(Icons.Default.Refresh, contentDescription = "刷新")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp)
                .verticalScroll(scrollState),
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            // Description
            Text(
                text = "NearClip需要以下权限才能正常运行。我们只在必要时申请权限，并严格保护您的隐私。",
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurface,
                modifier = Modifier.padding(bottom = 8.dp)
            )

            // Permission items
            permissions.forEach { permission ->
                PermissionItemCard(
                    permission = permission,
                    onStatusChanged = { granted ->
                        scope.launch {
                            if (granted) {
                                snackbarHostState.showSnackbar(
                                    message = "${permission.title} 已授予",
                                    duration = SnackbarDuration.Short
                                )
                            }
                        }
                    }
                )
            }

            // Action button
            Spacer(modifier = Modifier.weight(1f))

            NearClipButton(
                text = if (allRequiredGranted) "继续" else "请授予必需权限",
                onClick = onNext,
                modifier = Modifier.fillMaxWidth(),
                enabled = allRequiredGranted
            )

            if (!allRequiredGranted) {
                Text(
                    text = "必需权限授予完成后才能继续使用",
                    style = MaterialTheme.typography.bodySmall,
                    color = MaterialTheme.colorScheme.error,
                    textAlign = TextAlign.Center,
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(top = 8.dp)
                )
            }
        }
    }
}

@Composable
private fun PermissionItemCard(
    permission: PermissionItem,
    onStatusChanged: (Boolean) -> Unit,
    modifier: Modifier = Modifier
) {
    val isGranted by remember { derivedStateOf { permission.checkPermission() } }
    var isRequesting by remember { mutableStateOf(false) }

    LaunchedEffect(isGranted) {
        onStatusChanged(isGranted)
    }

    Card(
        modifier = modifier.fillMaxWidth(),
        colors = CardDefaults.cardColors(
            containerColor = if (isGranted) {
                MaterialTheme.colorScheme.primaryContainer
            } else {
                MaterialTheme.colorScheme.surface
            }
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.SpaceBetween,
                verticalAlignment = Alignment.CenterVertically
            ) {
                // Icon and text
                Row(
                    verticalAlignment = Alignment.CenterVertically,
                    modifier = Modifier.weight(1f)
                ) {
                    Icon(
                        imageVector = permission.icon,
                        contentDescription = null,
                        tint = if (isGranted) {
                            MaterialTheme.colorScheme.primary
                        } else {
                            MaterialTheme.colorScheme.onSurfaceVariant
                        },
                        modifier = Modifier.size(24.dp)
                    )

                    Spacer(modifier = Modifier.width(12.dp))

                    Column(modifier = Modifier.weight(1f)) {
                        Row(
                            verticalAlignment = Alignment.CenterVertically
                        ) {
                            Text(
                                text = permission.title,
                                style = MaterialTheme.typography.titleMedium,
                                fontWeight = FontWeight.Medium,
                                color = if (isGranted) {
                                    MaterialTheme.colorScheme.onPrimaryContainer
                                } else {
                                    MaterialTheme.colorScheme.onSurface
                                }
                            )

                            if (permission.isRequired) {
                                Spacer(modifier = Modifier.width(8.dp))
                                Text(
                                    text = "*必需",
                                    style = MaterialTheme.typography.bodySmall,
                                    color = MaterialTheme.colorScheme.error,
                                    fontWeight = FontWeight.Bold
                                )
                            }
                        }

                        Spacer(modifier = Modifier.height(4.dp))

                        Text(
                            text = permission.description,
                            style = MaterialTheme.typography.bodyMedium,
                            color = if (isGranted) {
                                MaterialTheme.colorScheme.onPrimaryContainer.copy(alpha = 0.7f)
                            } else {
                                MaterialTheme.colorScheme.onSurfaceVariant
                            },
                            lineHeight = 1.4f
                        )
                    }
                }

                // Status icon and button
                if (isGranted) {
                    Icon(
                        imageVector = Icons.Default.CheckCircle,
                        contentDescription = "已授予",
                        tint = MaterialTheme.colorScheme.primary,
                        modifier = Modifier.size(24.dp)
                    )
                } else {
                    Button(
                        onClick = {
                            isRequesting = true
                            permission.requestPermission()
                            // Note: Permission result will be handled by the checkPermission callback
                            isRequesting = false
                        },
                        enabled = !isRequesting,
                        modifier = Modifier.height(36.dp)
                    ) {
                        if (isRequesting) {
                            CircularProgressIndicator(
                                modifier = Modifier.size(16.dp),
                                strokeWidth = 2.dp,
                                color = MaterialTheme.colorScheme.onPrimary
                            )
                        } else {
                            Text("授予", style = MaterialTheme.typography.labelSmall)
                        }
                    }
                }
            }
        }
    }
}
```

### 4. 设备配对引导组件
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/onboarding/screens/DevicePairingScreen.kt
import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.rememberScrollState
import androidx.compose.foundation.verticalScroll
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Brush
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.vector.ImageVector
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.delay
import kotlinx.coroutines.launch

enum class PairingStep {
    SEARCHING,
    FOUND_DEVICES,
    CONNECTING,
    PAIRING,
    COMPLETED,
    FAILED
}

@Composable
fun DevicePairingScreen(
    onNext: () -> Unit,
    onBack: () -> Unit,
    modifier: Modifier = Modifier,
    viewModel: OnboardingManager = hiltViewModel()
) {
    val scope = rememberCoroutineScope()
    var currentStep by remember { mutableStateOf(PairingStep.SEARCHING) }
    var discoveredDevices by remember { mutableStateOf<List<DiscoveredDevice>>(emptyList()) }
    var selectedDevice by remember { mutableStateOf<DiscoveredDevice?>(null) }
    var errorMessage by remember { mutableStateOf<String?>(null) }

    // Start device discovery
    LaunchedEffect(Unit) {
        scope.launch {
            currentStep = PairingStep.SEARCHING
            startDeviceDiscovery()
        }
    }

    // Handle device discovery
    LaunchedEffect(currentStep) {
        when (currentStep) {
            PairingStep.SEARCHING -> {
                delay(2000) // Simulate searching
                discoveredDevices = getMockDevices()
                if (discoveredDevices.isNotEmpty()) {
                    currentStep = PairingStep.FOUND_DEVICES
                } else {
                    currentStep = PairingStep.FAILED
                    errorMessage = "未发现附近设备，请确保设备已开启NearClip"
                }
            }
            PairingStep.CONNECTING -> {
                delay(1500) // Simulate connection
                currentStep = PairingStep.PAIRING
            }
            PairingStep.PAIRING -> {
                delay(2000) // Simulate pairing
                currentStep = PairingStep.COMPLETED
                delay(1000)
                onNext()
            }
            else -> {}
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("设备配对") },
                navigationIcon = {
                    IconButton(onClick = onBack) {
                        Icon(Icons.Default.ArrowBack, contentDescription = "返回")
                    }
                }
            )
        }
    ) { paddingValues ->
        Column(
            modifier = modifier
                .fillMaxSize()
                .padding(paddingValues)
                .padding(16.dp),
            horizontalAlignment = Alignment.CenterHorizontally
        ) {
            when (currentStep) {
                PairingStep.SEARCHING -> SearchingAnimation()
                PairingStep.FOUND_DEVICES -> DeviceList(
                    devices = discoveredDevices,
                    onDeviceSelected = { device ->
                        selectedDevice = device
                        scope.launch {
                            currentStep = PairingStep.CONNECTING
                            connectToDevice(device)
                        }
                    }
                )
                PairingStep.CONNECTING, PairingStep.PAIRING -> PairingAnimation(
                    step = currentStep,
                    deviceName = selectedDevice?.name ?: "未知设备"
                )
                PairingStep.COMPLETED -> PairingCompletedAnimation()
                PairingStep.FAILED -> PairingFailedView(
                    errorMessage = errorMessage ?: "未知错误",
                    onRetry = {
                        scope.launch {
                            currentStep = PairingStep.SEARCHING
                            startDeviceDiscovery()
                        }
                    }
                )
            }
        }
    }
}

@Composable
private fun SearchingAnimation() {
    val infiniteTransition = rememberInfiniteTransition()
    val rotation by infiniteTransition.animateFloat(
        initialValue = 0f,
        targetValue = 360f,
        animationSpec = infiniteRepeatable(
            animation = tween(2000, easing = LinearEasing),
            repeatMode = RepeatMode.Restart
        )
    )

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier.fillMaxSize()
    ) {
        // Animated Bluetooth icon
        Box(
            modifier = Modifier.size(120.dp),
            contentAlignment = Alignment.Center
        ) {
            Icon(
                imageVector = Icons.Default.BluetoothSearching,
                contentDescription = "正在搜索",
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier
                    .size(64.dp)
                    .graphicsLayer { rotationZ = rotation }
            )
        }

        Spacer(modifier = Modifier.height(24.dp))

        Text(
            text = "正在搜索附近设备...",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Medium,
            color = MaterialTheme.colorScheme.onSurface
        )

        Spacer(modifier = Modifier.height(8.dp))

        Text(
            text = "请确保另一台设备已开启NearClip并处于可发现状态",
            style = MaterialTheme.typography.bodyMedium,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            textAlign = TextAlign.Center
        )
    }
}

@Composable
private fun DeviceList(
    devices: List<DiscoveredDevice>,
    onDeviceSelected: (DiscoveredDevice) -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Spacer(modifier = Modifier.height(24.dp))

        Text(
            text = "发现设备",
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Medium,
            color = MaterialTheme.colorScheme.onSurface
        )

        Spacer(modifier = Modifier.height(16.dp))

        LazyColumn(
            modifier = Modifier.weight(1f),
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            items(devices) { device ->
                DeviceCard(
                    device = device,
                    onClick = { onDeviceSelected(device) }
                )
            }
        }

        Text(
            text = "没有找到您的设备？\n请确保两台设备距离较近且蓝牙已开启",
            style = MaterialTheme.typography.bodySmall,
            color = MaterialTheme.colorScheme.onSurfaceVariant,
            textAlign = TextAlign.Center,
            modifier = Modifier.padding(vertical = 16.dp)
        )
    }
}

@Composable
private fun DeviceCard(
    device: DiscoveredDevice,
    onClick: () -> Unit
) {
    NearClipCard(
        modifier = Modifier.fillMaxWidth(),
        onClick = onClick,
        elevation = 2
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Device icon
            Box(
                modifier = Modifier
                    .size(48.dp)
                    .background(
                        MaterialTheme.colorScheme.primaryContainer,
                        RoundedCornerShape(12.dp)
                    ),
                contentAlignment = Alignment.Center
            ) {
                Icon(
                    imageVector = getDeviceIcon(device.type),
                    contentDescription = null,
                    tint = MaterialTheme.colorScheme.primary,
                    modifier = Modifier.size(24.dp)
                )
            }

            Spacer(modifier = Modifier.width(16.dp))

            // Device info
            Column(
                modifier = Modifier.weight(1f)
            ) {
                Text(
                    text = device.name,
                    style = MaterialTheme.typography.titleMedium,
                    fontWeight = FontWeight.Medium,
                    color = MaterialTheme.colorScheme.onSurface
                )

                Spacer(modifier = Modifier.height(4.dp))

                Text(
                    text = device.type.displayName,
                    style = MaterialTheme.typography.bodyMedium,
                    color = MaterialTheme.colorScheme.onSurfaceVariant
                )

                if (device.signalStrength > 0) {
                    Spacer(modifier = Modifier.height(4.dp))
                    Row(
                        verticalAlignment = Alignment.CenterVertically
                    ) {
                        SignalStrengthIndicator(strength = device.signalStrength)
                        Spacer(modifier = Modifier.width(8.dp))
                        Text(
                            text = "信号强度: ${device.signalStrength}%",
                            style = MaterialTheme.typography.bodySmall,
                            color = MaterialTheme.colorScheme.onSurfaceVariant
                        )
                    }
                }
            }

            // Arrow icon
            Icon(
                imageVector = Icons.Default.ArrowForward,
                contentDescription = "配对",
                tint = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
private fun PairingAnimation(
    step: PairingStep,
    deviceName: String
) {
    val infiniteTransition = rememberInfiniteTransition()
    val pulse by infiniteTransition.animateFloat(
        initialValue = 0.8f,
        targetValue = 1.2f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = EaseInOutCubic),
            repeatMode = RepeatMode.Reverse
        )
    )

    Column(
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.Center,
        modifier = Modifier.fillMaxSize()
    ) {
        // Connection animation
        Box(
            modifier = Modifier.size(120.dp),
            contentAlignment = Alignment.Center
        ) {
            // Source device
            Icon(
                imageVector = Icons.Default.Smartphone,
                contentDescription = "当前设备",
                tint = MaterialTheme.colorScheme.primary,
                modifier = Modifier.size(48.dp)
            )

            // Connection lines animation
            if (step == PairingStep.CONNECTING) {
                Canvas(
                    modifier = Modifier.size(120.dp)
                ) {
                    val strokeWidth = 2.dp.toPx()
                    val center = Offset(size.width / 2, size.height / 2)

                    drawCircle(
                        color = MaterialTheme.colorScheme.primary,
                        radius = center.x * pulse,
                        style = Stroke(width = strokeWidth)
                    )
                }
            }

            // Target device
            Icon(
                imageVector = getDeviceIcon(DeviceType.MAC),
                contentDescription = "目标设备",
                tint = MaterialTheme.colorScheme.secondary,
                modifier = Modifier
                    .size(48.dp)
                    .offset(y = 80.dp)
            )
        }

        Spacer(modifier = Modifier.height(24.dp))

        Text(
            text = when (step) {
                PairingStep.CONNECTING -> "正在连接到 $deviceName"
                PairingStep.PAIRING -> "正在与 $deviceName 配对"
                else -> "处理中..."
            },
            style = MaterialTheme.typography.headlineSmall,
            fontWeight = FontWeight.Medium,
            color = MaterialTheme.colorScheme.onSurface,
            textAlign = TextAlign.Center
        )

        Spacer(modifier = Modifier.height(16.dp))

        LinearProgressIndicator(
            modifier = Modifier.width(200.dp),
            color = MaterialTheme.colorScheme.primary
        )
    }
}

// Data classes and helper functions
data class DiscoveredDevice(
    val id: String,
    val name: String,
    val type: DeviceType,
    val signalStrength: Int
)

enum class DeviceType(val displayName: String) {
    ANDROID("Android 设备"),
    MAC("Mac 设备"),
    WINDOWS("Windows 设备"),
    IOS("iOS 设备")
}

private fun getDeviceIcon(type: DeviceType): ImageVector {
    return when (type) {
        DeviceType.ANDROID -> Icons.Default.Android
        DeviceType.MAC -> Icons.Default.LaptopMac
        DeviceType.WINDOWS -> Icons.Default.LaptopWindows
        DeviceType.IOS -> Icons.Default.PhoneIphone
    }
}

private fun getMockDevices(): List<DiscoveredDevice> {
    return listOf(
        DiscoveredDevice(
            id = "mac_001",
            name = "MacBook Pro",
            type = DeviceType.MAC,
            signalStrength = 85
        ),
        DiscoveredDevice(
            id = "win_001",
            name = "Surface Laptop",
            type = DeviceType.WINDOWS,
            signalStrength = 60
        )
    )
}

private suspend fun startDeviceDiscovery() {
    // Implement actual device discovery logic
}

private suspend fun connectToDevice(device: DiscoveredDevice) {
    // Implement actual device connection logic
}
```

### 5. macOS SwiftUI 实现
```swift
// src/platform/mac/NearClip/Onboarding/WelcomeView.swift
import SwiftUI

struct WelcomeView: View {
    let onNext: () -> Void
    let onSkip: () -> Void

    @State private var animateLogo = false
    @State private var animateFeatures = false

    var body: some View {
        VStack(spacing: 0) {
            // Top section
            VStack(spacing: 24) {
                Spacer()
                    .frame(height: 48)

                // Logo
                Image("NearClipLogo")
                    .resizable()
                    .aspectRatio(contentMode: .fit)
                    .frame(width: 120, height: 120)
                    .scaleEffect(animateLogo ? 1.0 : 0.8)
                    .animation(.spring(response: 0.8, dampingFraction: 0.6), value: animateLogo)

                // Title
                VStack(spacing: 8) {
                    Text("欢迎使用 NearClip")
                        .font(.nearclipHeadlineLarge)
                        .fontWeight(.bold)
                        .foregroundColor(Color.nearclipPrimary)

                    Text("跨设备粘贴板同步工具")
                        .font(.nearclipTitleMedium)
                        .foregroundColor(Color.neutral600)
                }
                .opacity(animateLogo ? 1.0 : 0.0)
                .animation(.easeInOut(duration: 0.6).delay(0.3), value: animateLogo)
            }

            Spacer()

            // Features section
            VStack(spacing: 16) {
                FeatureCard(
                    icon: "ic_sync",
                    title: "即时同步",
                    description: "在Android和macOS设备之间实时同步粘贴板内容",
                    animate: animateFeatures
                )

                FeatureCard(
                    icon: "ic_security",
                    title: "安全加密",
                    description: "采用端到端加密技术，保护您的数据隐私",
                    animate: animateFeatures
                )

                FeatureCard(
                    icon: "ic_auto",
                    title: "智能自动化",
                    description: "自动检测粘贴板变化，无需手动操作",
                    animate: animateFeatures
                )
            }
            .opacity(animateFeatures ? 1.0 : 0.0)
            .offset(y: animateFeatures ? 0 : 20)
            .animation(.easeInOut(duration: 0.6).delay(0.6), value: animateFeatures)

            Spacer()

            // Bottom section
            VStack(spacing: 12) {
                NearClipButton(
                    title: "开始使用",
                    action: onNext,
                    size: .large
                )

                Button("跳过引导") {
                    onSkip()
                }
                .font(.nearclipBodyMedium)
                .foregroundColor(Color.neutral600)
            }
            .padding(.bottom, 32)
        }
        .padding(.horizontal, 24)
        .onAppear {
            withAnimation {
                animateLogo = true
            }

            DispatchQueue.main.asyncAfter(deadline: .now() + 0.6) {
                withAnimation {
                    animateFeatures = true
                }
            }
        }
    }
}

struct FeatureCard: View {
    let icon: String
    let title: String
    let description: String
    let animate: Bool

    var body: some View {
        HStack(spacing: 16) {
            Image(icon)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 32, height: 32)
                .foregroundColor(Color.nearclipPrimary)

            VStack(alignment: .leading, spacing: 4) {
                Text(title)
                    .font(.nearclipTitleMedium)
                    .fontWeight(.medium)
                    .foregroundColor(Color.neutral900)

                Text(description)
                    .font(.nearclipBodyMedium)
                    .foregroundColor(Color.neutral600)
                    .lineLimit(2)
            }

            Spacer()
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.neutral50)
        )
        .scaleEffect(animate ? 1.0 : 0.95)
        .opacity(animate ? 1.0 : 0.0)
        .animation(.spring(response: 0.6, dampingFraction: 0.8).delay(Double.random(in: 0...0.3)), value: animate)
    }
}

// src/platform/mac/NearClip/Onboarding/PermissionView.swift
import SwiftUI

struct PermissionView: View {
    let onNext: () -> Void
    let onBack: () -> Void

    @StateObject private var permissionManager = PermissionManager()
    @State private var showingAlert = false
    @State private var alertMessage = ""

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Button("返回") {
                    onBack()
                }
                .font(.nearclipBodyMedium)
                .foregroundColor(Color.nearclipPrimary)

                Spacer()

                Text("权限设置")
                    .font(.nearclipHeadlineSmall)
                    .fontWeight(.semibold)

                Spacer()

                Button("刷新") {
                    permissionManager.refreshPermissionStatus()
                }
                .font(.nearclipBodyMedium)
                .foregroundColor(Color.nearclipPrimary)
            }
            .padding(.horizontal, 24)
            .padding(.top, 16)

            // Content
            ScrollView {
                VStack(spacing: 24) {
                    // Description
                    VStack(spacing: 8) {
                        Text("NearClip需要以下权限才能正常运行")
                            .font(.nearclipBodyLarge)
                            .foregroundColor(Color.neutral900)

                        Text("我们只在必要时申请权限，并严格保护您的隐私")
                            .font(.nearclipBodyMedium)
                            .foregroundColor(Color.neutral600)
                            .multilineTextAlignment(.center)
                    }
                    .padding(.horizontal, 24)
                    .padding(.top, 24)

                    // Permission items
                    LazyVStack(spacing: 12) {
                        ForEach(permissionManager.permissions, id: \.id) { permission in
                            PermissionItemCard(
                                permission: permission,
                                onRequestPermission: {
                                    requestPermission(permission)
                                }
                            )
                        }
                    }
                    .padding(.horizontal, 24)

                    // Action button
                    VStack(spacing: 8) {
                        NearClipButton(
                            title: permissionManager.allRequiredGranted ? "继续" : "请授予必需权限",
                            action: onNext,
                            enabled: permissionManager.allRequiredGranted
                        )

                        if !permissionManager.allRequiredGranted {
                            Text("必需权限授予完成后才能继续使用")
                                .font(.nearclipBodySmall)
                                .foregroundColor(Color.error)
                        }
                    }
                    .padding(.horizontal, 24)
                    .padding(.bottom, 32)
                }
            }
        }
        .alert("权限错误", isPresented: $showingAlert) {
            Button("确定", role: .cancel) { }
        } message: {
            Text(alertMessage)
        }
    }

    private func requestPermission(_ permission: PermissionItem) {
        Task {
            do {
                try await permissionManager.requestPermission(permission.id)
            } catch {
                alertMessage = error.localizedDescription
                showingAlert = true
            }
        }
    }
}

struct PermissionItemCard: View {
    let permission: PermissionItem
    let onRequestPermission: () -> Void

    var body: some View {
        HStack(spacing: 16) {
            // Icon
            Image(systemName: permission.systemImage)
                .font(.system(size: 24))
                .foregroundColor(permission.isGranted ? Color.nearclipPrimary : Color.neutral600)
                .frame(width: 32, height: 32)

            // Content
            VStack(alignment: .leading, spacing: 4) {
                HStack {
                    Text(permission.title)
                        .font(.nearclipTitleMedium)
                        .fontWeight(.medium)
                        .foregroundColor(Color.neutral900)

                    if permission.isRequired {
                        Text("*必需")
                            .font(.nearclipBodySmall)
                            .fontWeight(.bold)
                            .foregroundColor(Color.error)
                    }
                }

                Text(permission.description)
                    .font(.nearclipBodyMedium)
                    .foregroundColor(Color.neutral600)
                    .lineLimit(2)
            }

            Spacer()

            // Status or button
            if permission.isGranted {
                Image(systemName: "checkmark.circle.fill")
                    .font(.system(size: 24))
                    .foregroundColor(Color.nearclipPrimary)
            } else {
                Button("授予") {
                    onRequestPermission()
                }
                .buttonStyle(.bordered)
                .controlSize(.small)
            }
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(permission.isGranted ? Color.nearclipPrimary.opacity(0.1) : Color.white)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(permission.isGranted ? Color.nearclipPrimary : Color.neutral300, lineWidth: 1)
        )
    }
}

// src/platform/mac/NearClip/Onboarding/DevicePairingView.swift
import SwiftUI

struct DevicePairingView: View {
    let onNext: () -> Void
    let onBack: () -> Void

    @StateObject private var pairingManager = DevicePairingManager()
    @State private var selectedDevice: DiscoveredDevice?

    var body: some View {
        VStack(spacing: 0) {
            // Header
            HStack {
                Button("返回") {
                    onBack()
                }
                .font(.nearclipBodyMedium)
                .foregroundColor(Color.nearclipPrimary)

                Spacer()

                Text("设备配对")
                    .font(.nearclipHeadlineSmall)
                    .fontWeight(.semibold)
            }
            .padding(.horizontal, 24)
            .padding(.top, 16)

            // Content
            Group {
                switch pairingManager.state {
                case .searching:
                    SearchingView()
                case .foundDevices:
                    DeviceListView(
                        devices: pairingManager.discoveredDevices,
                        onDeviceSelected: { device in
                            selectedDevice = device
                            pairingManager.connectToDevice(device)
                        }
                    )
                case .connecting, .pairing:
                    PairingAnimationView(
                        state: pairingManager.state,
                        deviceName: selectedDevice?.name ?? "未知设备"
                    )
                case .completed:
                    PairingCompletedView()
                case .failed:
                    PairingFailedView(
                        errorMessage: pairingManager.errorMessage ?? "未知错误",
                        onRetry: {
                            pairingManager.startDiscovery()
                        }
                    )
                }
            }
            .frame(maxWidth: .infinity, maxHeight: .infinity)
        }
        .onAppear {
            pairingManager.startDiscovery()
        }
    }
}

struct SearchingView: View {
    @State private var rotation = 0.0

    var body: some View {
        VStack(spacing: 24) {
            Spacer()

            // Animated Bluetooth icon
            ZStack {
                Circle()
                    .stroke(Color.nearclipPrimary.opacity(0.2), lineWidth: 2)
                    .frame(width: 120, height: 120)

                Image(systemName: "bluetooth")
                    .font(.system(size: 64))
                    .foregroundColor(Color.nearclipPrimary)
                    .rotationEffect(.degrees(rotation))
                    .onAppear {
                        withAnimation(.linear(duration: 2.0).repeatForever(autoreverses: false)) {
                            rotation = 360.0
                        }
                    }
            }

            VStack(spacing: 8) {
                Text("正在搜索附近设备...")
                    .font(.nearclipHeadlineSmall)
                    .fontWeight(.medium)
                    .foregroundColor(Color.neutral900)

                Text("请确保另一台设备已开启NearClip并处于可发现状态")
                    .font(.nearclipBodyMedium)
                    .foregroundColor(Color.neutral600)
                    .multilineTextAlignment(.center)
            }

            Spacer()
        }
        .padding(.horizontal, 24)
    }
}

struct DeviceListView: View {
    let devices: [DiscoveredDevice]
    let onDeviceSelected: (DiscoveredDevice) -> Void

    var body: some View {
        VStack(spacing: 16) {
            Text("发现设备")
                .font(.nearclipHeadlineSmall)
                .fontWeight(.medium)
                .foregroundColor(Color.neutral900)
                .padding(.top, 24)

            LazyVStack(spacing: 12) {
                ForEach(devices, id: \.id) { device in
                    DeviceCard(device: device) {
                        onDeviceSelected(device)
                    }
                }
            }

            Text("没有找到您的设备？\n请确保两台设备距离较近且蓝牙已开启")
                .font(.nearclipBodySmall)
                .foregroundColor(Color.neutral600)
                .multilineTextAlignment(.center)
                .padding(.bottom, 32)
        }
        .padding(.horizontal, 24)
    }
}

struct DeviceCard: View {
    let device: DiscoveredDevice
    let onTap: () -> Void

    var body: some View {
        HStack(spacing: 16) {
            // Device icon
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.nearclipPrimary.opacity(0.1))
                .frame(width: 48, height: 48)
                .overlay {
                    Image(systemName: device.systemImage)
                        .font(.system(size: 24))
                        .foregroundColor(Color.nearclipPrimary)
                }

            // Device info
            VStack(alignment: .leading, spacing: 4) {
                Text(device.name)
                    .font(.nearclipTitleMedium)
                    .fontWeight(.medium)
                    .foregroundColor(Color.neutral900)

                Text(device.type.displayName)
                    .font(.nearclipBodyMedium)
                    .foregroundColor(Color.neutral600)

                if device.signalStrength > 0 {
                    HStack {
                        SignalStrengthIndicator(strength: device.signalStrength)
                        Text("信号强度: \(device.signalStrength)%")
                            .font(.nearclipBodySmall)
                            .foregroundColor(Color.neutral600)
                    }
                }
            }

            Spacer()

            Image(systemName: "chevron.right")
                .font(.system(size: 16))
                .foregroundColor(Color.neutral400)
        }
        .padding(16)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.white)
        )
        .overlay(
            RoundedRectangle(cornerRadius: 12)
                .stroke(Color.neutral200, lineWidth: 1)
        )
        .onTapGesture {
            onTap()
        }
        .buttonStyle(PlainButtonStyle())
    }
}
```

## 测试用例

### 引导流程测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/onboarding/OnboardingManagerTest.kt
import org.junit.Test
import org.junit.Assert.*

class OnboardingManagerTest {

    @Test
    fun `start onboarding should set initial state`() {
        val manager = OnboardingManager()

        manager.startOnboarding()

        val state = manager.state.value
        assertEquals(OnboardingStep.WELCOME, state.currentStep)
        assertEquals(0f, state.progress)
        assertFalse(state.canGoBack)
        assertTrue(state.canGoNext)
    }

    @Test
    fun `next step should progress correctly`() {
        val manager = OnboardingManager()
        manager.startOnboarding()

        manager.nextStep()

        assertEquals(OnboardingStep.PERMISSIONS, manager.state.value.currentStep)
    }

    @Test
    fun `skip onboarding should complete flow`() {
        val manager = OnboardingManager()
        manager.startOnboarding()

        manager.skipOnboarding()

        assertTrue(manager.state.value.isCompleted)
        assertEquals(1f, manager.state.value.progress)
    }
}
```

## 部署要求

### 开发依赖
```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.compose.animation:animation:$compose_version"
    implementation "androidx.compose.animation:animation-graphics:$compose_version"
    implementation "androidx.hilt:hilt-navigation-compose:1.0.0"
}
```

### 资源文件
- 动画资源: Lottie files for complex animations
- 图标资源: SVG icons for better scalability
- 字体资源: Custom fonts for brand consistency
- 本地化资源: String resources for multiple languages

## 验收测试计划

### 功能测试
1. **引导流程**: 完整引导流程的端到端测试
2. **权限申请**: 各种权限申请场景的测试
3. **设备配对**: 设备发现和配对流程测试
4. **状态管理**: 引导状态正确性测试

### 用户体验测试
1. **新用户测试**: 邀请新用户进行实际使用测试
2. **易用性评估**: 评估引导流程的易用性和有效性
3. **完成率统计**: 统计用户引导完成率
4. **时间分析**: 分析用户完成引导所需时间

### 兼容性测试
1. **设备兼容**: 不同Android版本的兼容性测试
2. **权限兼容**: 不同设备和厂商的权限行为测试
3. **场景测试**: 各种使用场景下的引导流程测试

## 风险与缓解

### 用户体验风险
- **引导过长**: 过长的引导流程可能让用户失去耐心
  - 缓解: 提供跳过选项，分步骤引导，进度指示
- **权限拒绝**: 用户可能拒绝关键权限导致功能受限
  - 缓解: 清晰说明权限用途，提供替代方案，权限状态检查

### 技术风险
- **权限API变化**: Android权限API可能发生变化
  - 缓解: 使用兼容性库，版本检查，适配最新API
- **设备发现失败**: 蓝牙设备发现可能不稳定
  - 缓解: 重试机制，错误处理，用户指导

### 维护风险
- **内容维护**: 引导内容需要持续更新
  - 缓解: 内容外部化，动态加载，版本管理
- **多语言支持**: 引导内容的多语言支持
  - 缓解: 国际化框架，专业翻译，本地化测试

## 完成标准
- [ ] 完整的欢迎与介绍流程实现
- [ ] 分步骤权限申请引导功能
- [ ] 设备配对流程的可视化指导
- [ ] 首次使用的交互式引导
- [ ] 渐进式功能发现机制
- [ ] Android和macOS平台功能完整
- [ ] 动画效果流畅且自然
- [ ] 用户引导完成率达到预期
- [ ] 所有测试用例通过
- [ ] 用户反馈积极且改进有效