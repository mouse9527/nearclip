# 故事 4.3: 响应式设计与适配

## 基本信息
- **故事编号**: 4.3
- **Epic**: Epic 4 - 用户体验与界面优化
- **故事名称**: 响应式设计与适配
- **优先级**: 高
- **预计工期**: 4 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 应用能够在不同设备和屏幕尺寸上都有良好的显示效果，
**以便** 我能够在我拥有的任何设备上都能获得一致且优质的用户体验。

## 验收标准

### AC 1: 多屏幕尺寸适配
- **Android手机**: 适配不同Android手机屏幕尺寸（4.7" - 6.9"）
- **Android平板**: 支持Android平板的横竖屏切换和布局调整
- **macOS笔记本**: 适配MacBook、MacBook Air等不同尺寸笔记本
- **macOS桌面**: 支持iMac、Mac Studio等桌面显示器
- **外接显示器**: 支持外接多显示器的场景和分辨率

### AC 2: 自适应布局系统
- **弹性网格**: 基于网格系统的弹性布局，支持不同屏幕密度
- **动态尺寸**: UI元素根据屏幕尺寸动态调整大小和间距
- **内容优先级**: 小屏幕上优先显示核心功能，次要功能可折叠
- **导航适配**: 根据屏幕尺寸调整导航模式（汉堡菜单、底部导航等）
- **字体缩放**: 支持系统字体大小设置，保持可读性

### AC 3: 横竖屏适配
- **Android横竖屏**: 自动检测屏幕方向并调整布局
- **macOS窗口**: 支持窗口大小调整和动态布局
- **状态保持**: 屏幕旋转或窗口调整时保持应用状态
- **布局过渡**: 平滑的布局切换动画和过渡效果
- **内容适配**: 横竖屏下内容展示方式的优化

### AC 4: 高分辨率支持
- **密度适配**: 支持不同屏幕密度的像素适配
- **矢量图形**: 优先使用矢量图形，确保高分辨率下的清晰度
- **图片资源**: 提供多种分辨率的图片资源
- **缩放优化**: 在高分辨率设备上的性能优化
- **视觉一致性**: 确保不同分辨率下的视觉体验一致

### AC 5: 可访问性适配
- **字体缩放**: 支持大字体模式和高对比度
- **触摸优化**: 不同屏幕尺寸下的触摸目标大小优化
- **键盘导航**: 完整的键盘导航支持
- **屏幕阅读器**: 优化屏幕阅读器的体验
- **色彩适配**: 支持色盲和色弱用户的色彩方案

## 技术实现要点

### 1. 响应式设计令牌系统
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/responsive/ResponsiveTokens.kt
import androidx.compose.runtime.staticCompositionLocalOf
import androidx.compose.ui.unit.Dp
import androidx.compose.ui.unit.dp

// 屏幕尺寸断点
enum class WindowSize {
    COMPACT,    // 手机竖屏
    MEDIUM,     // 手机横屏/小平板
    EXPANDED    // 大平板/桌面
}

// 响应式间距
data class ResponsiveSpacing(
    val xs: Dp,
    val sm: Dp,
    val md: Dp,
    val lg: Dp,
    val xl: Dp
) {
    companion object {
        val default = ResponsiveSpacing(
            xs = 4.dp,
            sm = 8.dp,
            md = 16.dp,
            lg = 24.dp,
            xl = 32.dp
        )
    }

    fun forWindow(windowSize: WindowSize): Dp {
        return when (windowSize) {
            WindowSize.COMPACT -> sm
            WindowSize.MEDIUM -> md
            WindowSize.EXPANDED -> lg
        }
    }
}

// 响应式字体大小
data class ResponsiveTypography(
    val bodySmall: ResponsiveFontSize,
    val bodyMedium: ResponsiveFontSize,
    val bodyLarge: ResponsiveFontSize,
    val titleSmall: ResponsiveFontSize,
    val titleMedium: ResponsiveFontSize,
    val titleLarge: ResponsiveFontSize,
    val headlineSmall: ResponsiveFontSize,
    val headlineMedium: ResponsiveFontSize,
    val headlineLarge: ResponsiveFontSize
) {
    companion object {
        val default = ResponsiveTypography(
            bodySmall = ResponsiveFontSize(compact = 12.sp, medium = 13.sp, expanded = 14.sp),
            bodyMedium = ResponsiveFontSize(compact = 14.sp, medium = 15.sp, expanded = 16.sp),
            bodyLarge = ResponsiveFontSize(compact = 16.sp, medium = 17.sp, expanded = 18.sp),
            titleSmall = ResponsiveFontSize(compact = 14.sp, medium = 16.sp, expanded = 18.sp),
            titleMedium = ResponsiveFontSize(compact = 16.sp, medium = 18.sp, expanded = 20.sp),
            titleLarge = ResponsiveFontSize(compact = 18.sp, medium = 20.sp, expanded = 24.sp),
            headlineSmall = ResponsiveFontSize(compact = 24.sp, medium = 28.sp, expanded = 32.sp),
            headlineMedium = ResponsiveFontSize(compact = 28.sp, medium = 32.sp, expanded = 36.sp),
            headlineLarge = ResponsiveFontSize(compact = 32.sp, medium = 36.sp, expanded = 44.sp)
        )
    }
}

data class ResponsiveFontSize(
    val compact: TextUnit,
    val medium: TextUnit,
    val expanded: TextUnit
) {
    fun forWindow(windowSize: WindowSize): TextUnit {
        return when (windowSize) {
            WindowSize.COMPACT -> compact
            WindowSize.MEDIUM -> medium
            WindowSize.EXPANDED -> expanded
        }
    }
}

// 响应式组件尺寸
data class ResponsiveComponentSizes(
    val buttonHeight: ResponsiveSize,
    val cardPadding: ResponsivePadding,
    val iconSize: ResponsiveSize,
    val listHeight: ResponsiveSize
) {
    companion object {
        val default = ResponsiveComponentSizes(
            buttonHeight = ResponsiveSize(compact = 40.dp, medium = 44.dp, expanded = 48.dp),
            cardPadding = ResponsivePadding(
                compact = PaddingValues(12.dp),
                medium = PaddingValues(16.dp),
                expanded = PaddingValues(20.dp)
            ),
            iconSize = ResponsiveSize(compact = 20.dp, medium = 24.dp, expanded = 28.dp),
            listHeight = ResponsiveSize(compact = 56.dp, medium = 64.dp, expanded = 72.dp)
        )
    }
}

data class ResponsiveSize(
    val compact: Dp,
    val medium: Dp,
    val expanded: Dp
) {
    fun forWindow(windowSize: WindowSize): Dp {
        return when (windowSize) {
            WindowSize.COMPACT -> compact
            WindowSize.MEDIUM -> medium
            WindowSize.EXPANDED -> expanded
        }
    }
}

data class ResponsivePadding(
    val compact: PaddingValues,
    val medium: PaddingValues,
    val expanded: PaddingValues
) {
    fun forWindow(windowSize: WindowSize): PaddingValues {
        return when (windowSize) {
            WindowSize.COMPACT -> compact
            WindowSize.MEDIUM -> medium
            WindowSize.EXPANDED -> expanded
        }
    }
}

// Composition Local for responsive tokens
val LocalResponsiveTokens = staticCompositionLocalOf {
    ResponsiveTokens(
        spacing = ResponsiveSpacing.default,
        typography = ResponsiveTypography.default,
        componentSizes = ResponsiveComponentSizes.default
    )
}

data class ResponsiveTokens(
    val spacing: ResponsiveSpacing,
    val typography: ResponsiveTypography,
    val componentSizes: ResponsiveComponentSizes
)
```

### 2. 窗口尺寸检测系统
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/responsive/WindowSizeClassifier.kt
import androidx.compose.material3.windowsizeclass.WindowSizeClass
import androidx.compose.material3.windowsizeclass.WindowWidthSizeClass
import androidx.compose.runtime.*
import androidx.compose.ui.platform.LocalConfiguration

@Stable
class WindowSizeClassifier(
    val widthSizeClass: WindowWidthSizeClass,
    val configuration: Configuration
) {
    val windowSize: WindowSize
        get() = when {
            widthSizeClass == WindowWidthSizeClass.Compact -> WindowSize.COMPACT
            widthSizeClass == WindowWidthSizeClass.Medium -> WindowSize.MEDIUM
            else -> WindowSize.EXPANDED
        }

    val isPortrait: Boolean
        get() = configuration.orientation == Configuration.ORIENTATION_PORTRAIT

    val screenWidth: Dp
        get() = configuration.screenWidthDp.dp

    val screenHeight: Dp
        get() = configuration.screenHeightDp.dp

    val screenWidthDp: Int
        get() = configuration.screenWidthDp

    val screenHeightDp: Int
        get() = configuration.screenHeightDp

    fun isTablet(): Boolean {
        val smallestWidthDp = configuration.smallestScreenWidthDp
        return smallestWidthDp >= 600
    }

    fun getGridLayoutColumns(): Int {
        return when (windowSize) {
            WindowSize.COMPACT -> 1
            WindowSize.MEDIUM -> if (isPortrait) 1 else 2
            WindowSize.EXPANDED -> if (isPortrait) 2 else 3
        }
    }

    fun getMaxContentWidth(): Dp {
        return when (windowSize) {
            WindowSize.COMPACT -> Dp.Infinity
            WindowSize.MEDIUM -> 600.dp
            WindowSize.EXPANDED -> 840.dp
        }
    }
}

@Composable
fun rememberWindowSizeClassifier(
    windowSizeClass: WindowSizeClass
): WindowSizeClassifier {
    val configuration = LocalConfiguration.current

    return remember(windowSizeClass, configuration) {
        WindowSizeClassifier(
            widthSizeClass = windowSizeClass.widthSizeClass,
            configuration = configuration
        )
    }
}

// 扩展函数用于简化使用
@Composable
fun rememberWindowSize(): WindowSize {
    val windowSizeClass = calculateWindowSizeClass(LocalConfiguration.current)
    val classifier = rememberWindowSizeClassifier(windowSizeClass)
    return classifier.windowSize
}

@Composable
fun rememberIsTablet(): Boolean {
    val configuration = LocalConfiguration.current
    return remember(configuration) {
        configuration.smallestScreenWidthDp >= 600
    }
}

@Composable
fun rememberGridColumns(): Int {
    val windowSizeClass = calculateWindowSizeClass(LocalConfiguration.current)
    val classifier = rememberWindowSizeClassifier(windowSizeClass)
    return classifier.getGridLayoutColumns()
}
```

### 3. 响应式组件库
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/responsive/ResponsiveComponents.kt
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.grid.GridCells
import androidx.compose.foundation.lazy.grid.LazyVerticalGrid
import androidx.compose.foundation.lazy.grid.items
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.unit.dp

// 响应式容器
@Composable
fun ResponsiveContainer(
    modifier: Modifier = Modifier,
    contentAlignment: Alignment = Alignment.TopStart,
    content: @Composable ColumnScope.() -> Unit
) {
    val windowSize = rememberWindowSize()
    val maxWidth = when (windowSize) {
        WindowSize.COMPACT -> Dp.Infinity
        WindowSize.MEDIUM -> 600.dp
        WindowSize.EXPANDED -> 840.dp
    }

    Column(
        modifier = modifier
            .fillMaxWidth()
            .windowInsetsPadding(WindowInsets.safeDrawing)
            .then(
                if (maxWidth != Dp.Infinity) {
                    Modifier.widthIn(max = maxWidth)
                } else {
                    Modifier
                }
            ),
        horizontalAlignment = Alignment.CenterHorizontally,
        content = content
    ) {
        Box(
            modifier = Modifier.fillMaxWidth(),
            contentAlignment = contentAlignment
        ) {
            content()
        }
    }
}

// 响应式网格布局
@Composable
fun <T> ResponsiveGrid(
    items: List<T>,
    modifier: Modifier = Modifier,
    contentPadding: PaddingValues = PaddingValues(),
    horizontalArrangement: Arrangement.Horizontal = Arrangement.spacedBy(16.dp),
    verticalArrangement: Arrangement.Vertical = Arrangement.spacedBy(16.dp),
    itemContent: @Composable (T) -> Unit
) {
    val columns = rememberGridColumns()

    LazyVerticalGrid(
        columns = GridCells.Fixed(columns),
        modifier = modifier.fillMaxWidth(),
        contentPadding = contentPadding,
        horizontalArrangement = horizontalArrangement,
        verticalArrangement = verticalArrangement
    ) {
        items(items) { item ->
            itemContent(item)
        }
    }
}

// 响应式导航布局
@Composable
fun ResponsiveNavigationLayout(
    navigationContent: @Composable () -> Unit,
    content: @Composable (PaddingValues) -> Unit
) {
    val windowSize = rememberWindowSize()
    val configuration = LocalConfiguration.current
    val isLandscape = configuration.orientation == Configuration.ORIENTATION_LANDSCAPE

    when {
        windowSize == WindowSize.EXPANDED || (windowSize == WindowSize.MEDIUM && isLandscape) -> {
            // 桌面/平板布局：侧边导航
            Row(modifier = Modifier.fillMaxSize()) {
                // 永久性导航抽屉
                PermanentNavigationDrawer(
                    drawerContent = {
                        Column(
                            modifier = Modifier
                                .fillMaxHeight()
                                .width(280.dp)
                                .padding(16.dp)
                        ) {
                            navigationContent()
                        }
                    }
                ) { paddingValues ->
                    content(paddingValues)
                }
            }
        }
        else -> {
            // 手机布局：底部导航
            Scaffold(
                bottomBar = {
                    BottomAppBar {
                        navigationContent()
                    }
                }
            ) { paddingValues ->
                content(paddingValues)
            }
        }
    }
}

// 响应式卡片布局
@Composable
fun ResponsiveCard(
    modifier: Modifier = Modifier,
    onClick: (() -> Unit)? = null,
    content: @Composable ColumnScope.() -> Unit
) {
    val windowSize = rememberWindowSize()
    val responsiveTokens = LocalResponsiveTokens.current
    val padding = responsiveTokens.componentSizes.cardPadding.forWindow(windowSize)

    NearClipCard(
        modifier = modifier,
        onClick = onClick
    ) {
        Column(
            modifier = Modifier.padding(padding),
            content = content
        )
    }
}

// 响应式列表项
@Composable
fun <T> ResponsiveListItem(
    item: T,
    modifier: Modifier = Modifier,
    onClick: (T) -> Unit,
    leadingContent: @Composable (T) -> Unit,
    overlineContent: @Composable (T) -> Unit? = { null },
    headlineContent: @Composable (T) -> Unit,
    supportingContent: @Composable (T) -> Unit? = { null },
    trailingContent: @Composable (T) -> Unit? = { null }
) {
    val windowSize = rememberWindowSize()
    val responsiveTokens = LocalResponsiveTokens.current
    val minHeight = responsiveTokens.componentSizes.listHeight.forWindow(windowSize)

    NearClipCard(
        modifier = modifier.fillMaxWidth(),
        onClick = { onClick(item) }
    ) {
        Row(
            modifier = Modifier
                .fillMaxWidth()
                .heightIn(min = minHeight)
                .padding(16.dp),
            verticalAlignment = Alignment.CenterVertically
        ) {
            // Leading content
            Box(
                modifier = Modifier.size(40.dp),
                contentAlignment = Alignment.Center
            ) {
                leadingContent(item)
            }

            Spacer(modifier = Modifier.width(16.dp))

            // Text content
            Column(
                modifier = Modifier.weight(1f)
            ) {
                overlineContent(item)?.let { overline ->
                    Text(
                        text = overline,
                        style = MaterialTheme.typography.labelSmall,
                        color = MaterialTheme.colorScheme.primary
                    )
                    Spacer(modifier = Modifier.height(2.dp))
                }

                headlineContent(item)

                supportingContent(item)?.let { supporting ->
                    Spacer(modifier = Modifier.height(4.dp))
                    Text(
                        text = supporting,
                        style = MaterialTheme.typography.bodyMedium,
                        color = MaterialTheme.colorScheme.onSurfaceVariant
                    )
                }
            }

            // Trailing content
            trailingContent(item)?.let { trailing ->
                Spacer(modifier = Modifier.width(16.dp))
                trailing
            }
        }
    }
}

// 响应式按钮
@Composable
fun ResponsiveButton(
    text: String,
    onClick: () -> Unit,
    modifier: Modifier = Modifier,
    variant: NearClipButtonVariant = NearClipButtonVariant.Primary,
    size: NearClipButtonSize? = null,
    leadingIcon: @Composable (() -> Unit)? = null,
    trailingIcon: @Composable (() -> Unit)? = null
) {
    val windowSize = rememberWindowSize()
    val responsiveTokens = LocalResponsiveTokens.current

    // 根据窗口大小自动选择按钮尺寸
    val buttonSize = size ?: when (windowSize) {
        WindowSize.COMPACT -> NearClipButtonSize.Medium
        WindowSize.MEDIUM -> NearClipButtonSize.Medium
        WindowSize.EXPANDED -> NearClipButtonSize.Large
    }

    NearClipButton(
        text = text,
        onClick = onClick,
        modifier = modifier,
        variant = variant,
        size = buttonSize,
        leadingIcon = leadingIcon,
        trailingIcon = trailingIcon
    )
}
```

### 4. SwiftUI macOS 响应式实现
```swift
// src/platform/mac/NearClip/Responsive/ResponsiveView.swift
import SwiftUI

// 响应式尺寸分类
enum ResponsiveSize {
    case compact    // 窄窗口
    case medium     // 中等窗口
    case expanded   // 宽窗口
}

// 响应式配置
struct ResponsiveConfig {
    let minCompactWidth: CGFloat = 600
    let minMediumWidth: CGFloat = 800
    let minExpandedWidth: CGFloat = 1200

    let compactSpacing: CGFloat = 12
    let mediumSpacing: CGFloat = 16
    let expandedSpacing: CGFloat = 24

    let compactPadding: EdgeInsets = EdgeInsets(top: 16, leading: 16, bottom: 16, trailing: 16)
    let mediumPadding: EdgeInsets = EdgeInsets(top: 24, leading: 24, bottom: 24, trailing: 24)
    let expandedPadding: EdgeInsets = EdgeInsets(top: 32, leading: 32, bottom: 32, trailing: 32)

    static let shared = ResponsiveConfig()
}

// 响应式视图协议
protocol ResponsiveView: View {
    associatedtype ResponsiveBody: View

    @ViewBuilder
    func responsiveBody(size: ResponsiveSize) -> ResponsiveBody
}

// 响应式容器视图
struct ResponsiveContainer<Content: View>: View {
    let content: Content
    @State private var currentSize: ResponsiveSize = .medium

    init(@ViewBuilder content: () -> Content) {
        self.content = content()
    }

    var body: some View {
        GeometryReader { geometry in
            content
                .frame(maxWidth: .infinity, maxHeight: .infinity)
                .onAppear {
                    updateSize(for: geometry.size.width)
                }
                .onChange(of: geometry.size.width) { newWidth in
                    updateSize(for: newWidth)
                }
        }
        .environment(\.responsiveSize, currentSize)
    }

    private func updateSize(for width: CGFloat) {
        let config = ResponsiveConfig.shared

        if width < config.minCompactWidth {
            currentSize = .compact
        } else if width < config.minMediumWidth {
            currentSize = .medium
        } else if width < config.minExpandedWidth {
            currentSize = .expanded
        } else {
            currentSize = .expanded
        }
    }
}

// 响应式网格布局
struct ResponsiveGrid<Item: Identifiable, Content: View>: View {
    let items: [Item]
    let content: (Item) -> Content

    @Environment(\.responsiveSize) private var responsiveSize

    private var columns: Int {
        switch responsiveSize {
        case .compact:
            return 1
        case .medium:
            return 2
        case .expanded:
            return 3
        }
    }

    private var spacing: CGFloat {
        let config = ResponsiveConfig.shared
        switch responsiveSize {
        case .compact:
            return config.compactSpacing
        case .medium:
            return config.mediumSpacing
        case .expanded:
            return config.expandedSpacing
        }
    }

    private var padding: EdgeInsets {
        let config = ResponsiveConfig.shared
        switch responsiveSize {
        case .compact:
            return config.compactPadding
        case .medium:
            return config.mediumPadding
        case .expanded:
            return config.expandedPadding
        }
    }

    var body: some View {
        ScrollView {
            LazyVGrid(
                columns: Array(repeating: GridItem(.flexible(), spacing: spacing), count: columns),
                spacing: spacing,
                padding: padding
            ) {
                ForEach(items) { item in
                    content(item)
                }
            }
        }
    }
}

// 响应式导航布局
struct ResponsiveNavigation<Sidebar: View, Content: View>: View {
    let sidebar: Sidebar
    let content: Content

    @State private var sidebarVisible: Bool = false
    @Environment(\.responsiveSize) private var responsiveSize

    var body: some View {
        Group {
            if responsiveSize == .compact {
                // 紧凑模式：使用工具栏
                NavigationSplitView {
                    EmptyView()
                } detail: {
                    content
                        .toolbar {
                            ToolbarItem(placement: .navigation) {
                                Button("侧边栏") {
                                    sidebarVisible.toggle()
                                }
                            }
                        }
                        .sheet(isPresented: $sidebarVisible) {
                            NavigationStack {
                                sidebar
                                    .navigationTitle("NearClip")
                                    .navigationBarTitleDisplayMode(.inline)
                                    .toolbar {
                                        ToolbarItem(placement: .navigationBarTrailing) {
                                            Button("完成") {
                                                sidebarVisible = false
                                            }
                                        }
                                    }
                            }
                        }
                }
            } else {
                // 中等和展开模式：使用侧边栏
                NavigationSplitView {
                    sidebar
                        .navigationSplitViewColumnWidth(
                            min: 250, ideal: 300, max: 400
                        )
                } detail: {
                    content
                }
            }
        }
    }
}

// 响应式卡片
struct ResponsiveCard<Content: View>: View {
    let content: Content
    let action: (() -> Void)?

    @Environment(\.responsiveSize) private var responsiveSize

    private var padding: EdgeInsets {
        let config = ResponsiveConfig.shared
        switch responsiveSize {
        case .compact:
            return EdgeInsets(top: 12, leading: 12, bottom: 12, trailing: 12)
        case .medium:
            return EdgeInsets(top: 16, leading: 16, bottom: 16, trailing: 16)
        case .expanded:
            return EdgeInsets(top: 20, leading: 20, bottom: 20, trailing: 20)
        }
    }

    init(action: (() -> Void)? = nil, @ViewBuilder content: () -> Content) {
        self.action = action
        self.content = content()
    }

    var body: some View {
        Group {
            if let action = action {
                Button(action: action) {
                    cardContent
                }
                .buttonStyle(PlainButtonStyle())
            } else {
                cardContent
            }
        }
    }

    private var cardContent: some View {
        VStack(spacing: 0) {
            content
        }
        .padding(padding)
        .background(
            RoundedRectangle(cornerRadius: 12)
                .fill(Color.white)
                .shadow(
                    color: Color.black.opacity(0.1),
                    radius: 4,
                    x: 0,
                    y: 2
                )
        )
    }
}

// 环境键值
struct ResponsiveSizeKey: EnvironmentKey {
    static let defaultValue: ResponsiveSize = .medium
}

extension EnvironmentValues {
    var responsiveSize: ResponsiveSize {
        get { self[ResponsiveSizeKey.self] }
        set { self[ResponsiveSizeKey.self] = newValue }
    }
}
```

### 5. 响应式布局示例
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/responsive/ResponsiveHomeScreen.kt
@Composable
fun ResponsiveHomeScreen(
    onNavigateToDeviceList: () -> Unit,
    onNavigateToHistory: () -> Unit,
    onNavigateToSettings: () -> Unit,
    modifier: Modifier = Modifier
) {
    val windowSize = rememberWindowSize()

    ResponsiveContainer(modifier = modifier) {
        when (windowSize) {
            WindowSize.COMPACT -> CompactHomeLayout(
                onNavigateToDeviceList = onNavigateToDeviceList,
                onNavigateToHistory = onNavigateToHistory,
                onNavigateToSettings = onNavigateToSettings
            )
            WindowSize.MEDIUM -> MediumHomeLayout(
                onNavigateToDeviceList = onNavigateToDeviceList,
                onNavigateToHistory = onNavigateToHistory,
                onNavigateToSettings = onNavigateToSettings
            )
            WindowSize.EXPANDED -> ExpandedHomeLayout(
                onNavigateToDeviceList = onNavigateToDeviceList,
                onNavigateToHistory = onNavigateToHistory,
                onNavigateToSettings = onNavigateToSettings
            )
        }
    }
}

@Composable
private fun CompactHomeLayout(
    onNavigateToDeviceList: () -> Unit,
    onNavigateToHistory: () -> Unit,
    onNavigateToSettings: () -> Unit
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        item {
            // 状态卡片
            ConnectionStatusCard(
                modifier = Modifier.fillMaxWidth()
            )
        }

        item {
            // 快速操作
            QuickActionsSection(
                onNavigateToDeviceList = onNavigateToDeviceList,
                onNavigateToHistory = onNavigateToHistory,
                modifier = Modifier.fillMaxWidth()
            )
        }

        item {
            // 最近同步内容
            RecentSyncSection(
                onNavigateToHistory = onNavigateToHistory,
                modifier = Modifier.fillMaxWidth()
            )
        }

        item {
            // 设备列表预览
            DeviceListPreview(
                onNavigateToDeviceList = onNavigateToDeviceList,
                modifier = Modifier.fillMaxWidth()
            )
        }
    }
}

@Composable
private fun MediumHomeLayout(
    onNavigateToDeviceList: () -> Unit,
    onNavigateToHistory: () -> Unit,
    onNavigateToSettings: () -> Unit
) {
    LazyColumn(
        modifier = Modifier.fillMaxSize(),
        contentPadding = PaddingValues(24.dp),
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        item {
            // 顶部状态和快速操作
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(24.dp)
            ) {
                ConnectionStatusCard(
                    modifier = Modifier.weight(1f)
                )
                QuickActionsSection(
                    onNavigateToDeviceList = onNavigateToDeviceList,
                    onNavigateToHistory = onNavigateToHistory,
                    modifier = Modifier.weight(1f)
                )
            }
        }

        item {
            // 主要内容区域
            Row(
                modifier = Modifier.fillMaxWidth(),
                horizontalArrangement = Arrangement.spacedBy(24.dp)
            ) {
                RecentSyncSection(
                    onNavigateToHistory = onNavigateToHistory,
                    modifier = Modifier.weight(2f)
                )
                DeviceListPreview(
                    onNavigateToDeviceList = onNavigateToDeviceList,
                    modifier = Modifier.weight(1f)
                )
            }
        }
    }
}

@Composable
private fun ExpandedHomeLayout(
    onNavigateToDeviceList: () -> Unit,
    onNavigateToHistory: () -> Unit,
    onNavigateToSettings: () -> Unit
) {
    Column(
        modifier = Modifier.fillMaxSize(),
        verticalArrangement = Arrangement.spacedBy(32.dp)
    ) {
        // 顶部状态栏
        ConnectionStatusCard(
            modifier = Modifier.fillMaxWidth()
        )

        // 主要内容网格
        ResponsiveGrid(
            items = listOf(
                HomeGridItem.QuickActions,
                HomeGridItem.RecentSync,
                HomeGridItem.DeviceList,
                HomeGridItem.Settings
            ),
            modifier = Modifier.weight(1f)
        ) { item ->
            when (item) {
                HomeGridItem.QuickActions -> QuickActionsSection(
                    onNavigateToDeviceList = onNavigateToDeviceList,
                    onNavigateToHistory = onNavigateToHistory
                )
                HomeGridItem.RecentSync -> RecentSyncSection(
                    onNavigateToHistory = onNavigateToHistory
                )
                HomeGridItem.DeviceList -> DeviceListPreview(
                    onNavigateToDeviceList = onNavigateToDeviceList
                )
                HomeGridItem.Settings -> SettingsQuickAccess(
                    onNavigateToSettings = onNavigateToSettings
                )
            }
        }
    }
}

enum class HomeGridItem {
    QuickActions,
    RecentSync,
    DeviceList,
    Settings
}
```

### 6. 性能优化和资源管理
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/responsive/ResponsiveResourceLoader.kt
import androidx.compose.runtime.*
import androidx.compose.ui.platform.LocalConfiguration
import androidx.compose.ui.res.stringResource

class ResponsiveResourceLoader(
    private val configuration: Configuration
) {
    fun getStringArray(resId: Int): Array<String> {
        // 根据屏幕尺寸选择不同的资源
        val qualifier = when {
            configuration.screenWidthDp >= 600 -> {
                if (configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) {
                    "sw600dp-land"
                } else {
                    "sw600dp-port"
                }
            }
            configuration.screenWidthDp >= 480 -> "sw480dp"
            else -> "default"
        }

        // 实现资源加载逻辑
        return loadResourceWithQualifier(resId, qualifier)
    }

    private fun loadResourceWithQualifier(resId: Int, qualifier: String): Array<String> {
        // 实现根据限定符加载资源的逻辑
        // 这里需要结合Android的资源系统
        return emptyArray() // 占位实现
    }
}

@Composable
fun rememberResponsiveResourceLoader(): ResponsiveResourceLoader {
    val configuration = LocalConfiguration.current
    return remember(configuration) {
        ResponsiveResourceLoader(configuration)
    }
}

// 响应式图片加载
@Composable
fun ResponsiveImage(
    resId: Int,
    contentDescription: String?,
    modifier: Modifier = Modifier
) {
    val windowSize = rememberWindowSize()
    val configuration = LocalConfiguration.current

    // 根据屏幕密度和尺寸选择合适的图片资源
    val imageResId = when {
        configuration.densityDpi >= DisplayMetrics.DENSITY_XXHIGH &&
        windowSize == WindowSize.EXPANDED -> {
            // 高密度 + 大屏幕：使用超高清图片
            getHighResImageResource(resId)
        }
        configuration.densityDpi >= DisplayMetrics.DENSITY_XHIGH -> {
            // 高密度屏幕
            getHighResImageResource(resId)
        }
        else -> {
            // 普通密度屏幕
            resId
        }
    }

    AsyncImage(
        model = ImageRequest.Builder(LocalContext.current)
            .data(imageResId)
            .crossfade(true)
            .build(),
        contentDescription = contentDescription,
        modifier = modifier,
        contentScale = ContentScale.Fit
    )
}

private fun getHighResImageResource(baseResId: Int): Int {
    // 实现高分辨率图片资源ID的映射逻辑
    return baseResId // 占位实现
}
```

## 测试用例

### 响应式布局测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/ui/responsive/ResponsiveLayoutTest.kt
import androidx.compose.ui.test.*
import androidx.compose.ui.test.junit4.createComposeRule
import org.junit.Rule
import org.junit.Test

class ResponsiveLayoutTest {

    @get:Rule
    val composeTestRule = createComposeRule()

    @Test
    fun responsiveContainer_adaptsToWindowSize() {
        composeTestRule.setContent {
            ResponsiveContainer {
                Text("Test Content")
            }
        }

        // 验证在不同窗口大小下的布局
        composeTestRule.onNodeWithText("Test Content")
            .assertIsDisplayed()
    }

    @Test
    fun responsiveGrid_adjustsColumns() {
        val items = listOf("Item 1", "Item 2", "Item 3", "Item 4")

        composeTestRule.setContent {
            ResponsiveGrid(items = items) { item ->
                Text(item)
            }
        }

        // 验证网格布局
        composeTestRule.onAllNodesWithText("Item").assertCountEquals(4)
    }
}
```

### SwiftUI响应式测试
```swift
// src/platform/mac/NearClip/Responsive/Tests/ResponsiveViewTests.swift
import XCTest
import SwiftUI
import ViewInspector

final class ResponsiveViewTests: XCTestCase {

    func testResponsiveContainerAdaptsToSize() throws {
        var container = ResponsiveContainer {
            Text("Test Content")
        }

        // 模拟不同的窗口尺寸
        let testSize = CGSize(width: 800, height: 600)
        let text = try container.inspect().text().string()
        XCTAssertEqual(text, "Test Content")
    }

    func testResponsiveGridColumns() throws {
        let items = ["Item 1", "Item 2", "Item 3"]

        var grid = ResponsiveGrid(items: items) { item in
            Text(item)
        }

        // 验证网格列数
        let itemCount = try grid.inspect().forEachCount()
        XCTAssertEqual(itemCount, 3)
    }
}
```

## 部署要求

### 开发依赖
```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.compose.material3:material3-window-size-class:$material3_version"
    implementation "androidx.compose.material:material-icons-extended:$compose_version"
    implementation "io.coil-kt:coil-compose:2.4.0" // 图片加载
}
```

### 资源配置
```xml
<!-- res/values/dimens.xml -->
<resources>
    <dimen name="spacing_compact">8dp</dimen>
    <dimen name="spacing_medium">16dp</dimen>
    <dimen name="spacing_expanded">24dp</dimen>
</resources>

<!-- res/values-sw600dp/dimens.xml -->
<resources>
    <dimen name="spacing_compact">12dp</dimen>
    <dimen name="spacing_medium">20dp</dimen>
    <dimen name="spacing_expanded">32dp</dimen>
</resources>
```

## 验收测试计划

### 屏幕适配测试
1. **设备测试**: 在不同尺寸的Android设备上测试
2. **分辨率测试**: 测试不同屏幕分辨率的适配
3. **方向测试**: 测试横竖屏切换的布局变化
4. **多窗口测试**: 测试Android多窗口模式的适配

### 用户体验测试
1. **可用性测试**: 不同屏幕尺寸下的可用性评估
2. **视觉一致性**: 确保不同尺寸下的视觉体验一致
3. **交互测试**: 验证触摸和交互在不同尺寸下的适配
4. **性能测试**: 测试不同设备上的性能表现

### 兼容性测试
1. **Android版本兼容**: 测试不同Android版本的兼容性
2. **设备厂商兼容**: 测试不同厂商设备的兼容性
3. **外接显示器**: 测试外接显示器的适配效果

## 风险与缓解

### 技术风险
- **布局复杂性**: 响应式布局增加了复杂性
  - 缓解: 使用组件化设计，完善的测试覆盖
- **性能影响**: 复杂的布局计算可能影响性能
  - 缓解: 优化布局算法，缓存计算结果
- **资源管理**: 多尺寸资源可能增加包大小
  - 缓解: 动态资源加载，资源分包策略

### 维护风险
- **测试复杂度**: 需要测试多种设备和尺寸
  - 缓解: 自动化测试，模拟器测试矩阵
- **兼容性问题**: 新设备可能出现兼容性问题
  - 缓解: 持续监控，快速修复机制

## 完成标准
- [ ] 支持主流Android和macOS设备的屏幕尺寸
- [ ] 自适应布局系统正确实现
- [ ] 横竖屏切换流畅且无状态丢失
- [ ] 高分辨率设备显示清晰
- [ ] 可访问性功能完善
- [ ] 性能优化达到预期目标
- [ ] 所有平台功能测试通过
- [ ] 用户体验测试获得积极反馈
- [ ] 响应式设计文档完整
- [ ] 资源管理和加载优化完成