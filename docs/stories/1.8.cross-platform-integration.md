# Story 1.8: 跨平台集成与联调测试

## Status
Draft

## Story
**作为** 开发者，
**我希望** 完成 Android 和 Mac 平台的集成，实现端到端的剪贴板同步功能，并进行全面的联调测试，
**以便** 验证整个系统的功能完整性、性能表现和用户体验。

## Acceptance Criteria
1. 完成 Android 与 Rust 库的集成，实现 FFI 调用和数据交换
2. 完成 Mac 与 Rust 库的集成，实现 C ABI 调用和数据交换
3. 实现端到端的设备发现、配对和数据同步流程
4. 建立完整的测试框架，包括单元测试、集成测试和端到端测试
5. 实现性能监控和错误处理机制
6. 验证跨平台数据一致性和同步可靠性

## Tasks / Subtasks
- [ ] Android 平台集成 (AC: 1)
  - [ ] 配置 Gradle 构建脚本以编译 Rust 库
  - [ ] 实现 RustNativeBridge 与 Rust FFI 的完整对接
  - [ ] 测试设备发现功能在 Android 平台的工作情况
  - [ ] 验证 BLE 通信和消息传递
  - [ ] 测试剪贴板监控和数据同步功能
- [ ] Mac 平台集成 (AC: 2)
  - [ ] 配置 Xcode 项目以链接 Rust 静态库
  - [ ] 实现 NearClipManager 与 Rust C ABI 的完整对接
  - [ ] 测试菜单栏集成和状态显示
  - [ ] 验证蓝牙权限和设备访问
  - [ ] 测试 SwiftUI 界面和用户交互
- [ ] 端到端功能验证 (AC: 3)
  - [ ] 实现设备自动发现和配对流程
  - [ ] 测试文本剪贴板的双向同步
  - [ ] 测试图片剪贴板的传输和显示
  - [ ] 验证文件传输功能（如果支持）
  - [ ] 测试网络断开重连和数据恢复
- [ ] 测试框架建立 (AC: 4)
  - [ ] 创建 Android 单元测试套件
  - [ ] 创建 Mac 单元测试套件
  - [ ] 实现 Rust 集成测试
  - [ ] 建立跨平台端到端测试环境
  - [ ] 创建性能基准测试
- [ ] 性能和错误监控 (AC: 5)
  - [ ] 实现跨平台日志记录系统
  - [ ] 添加性能指标收集
  - [ ] 创建错误监控和报告机制
  - [ ] 实现内存和 CPU 使用监控
  - [ ] 建立用户行为分析
- [ ] 数据一致性验证 (AC: 6)
  - [ ] 测试同步数据的完整性
  - [ ] 验证并发同步的冲突处理
  - [ ] 测试大数据量的同步性能
  - [ ] 验证加密数据的正确传输
  - [ ] 测试协议版本兼容性

## Dev Notes

### 跨平台集成架构
[Source: architecture/high-level-architecture.md]

#### 集成层次结构
```
┌─────────────────────────────────────┐
│           User Interface            │
│    (Android UI + macOS SwiftUI)    │
├─────────────────────────────────────┤
│         Application Layer           │
│   (Android App + macOS App)        │
├─────────────────────────────────────┤
│          FFI Integration            │
│     (JNI + C ABI Bindings)         │
├─────────────────────────────────────┤
│         Rust Core Library          │
│    (Business Logic + Protocol)     │
├─────────────────────────────────────┤
│       Platform BLE APIs           │
│   (Android Bluetooth + macOS Core) │
└─────────────────────────────────────┘
```

### Android 平台集成实现

#### Gradle 构建配置
```kotlin
// src/platform/android/app/build.gradle.kts
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.android.library")
    id("rust-android-gradle") // Rust 集成插件
}

android {
    namespace = "com.nearclip"
    compileSdk = 34

    defaultConfig {
        applicationId = "com.nearclip"
        minSdk = 26
        targetSdk = 34
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"

        // Rust 库配置
        ndk {
            abiFilters += listOf("arm64-v8a", "armeabi-v7a", "x86_64", "x86")
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_1_8
        targetCompatibility = JavaVersion.VERSION_1_8
    }

    kotlinOptions {
        jvmTarget = "1.8"
    }

    buildFeatures {
        compose = true
    }

    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.4"
    }

    packaging {
        resources {
            excludes += "/META-INF/{AL2.0,LGPL2.1}"
        }
    }
}

dependencies {
    // Compose BOM
    implementation(platform("androidx.compose:compose-bom:2023.10.01"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")

    // AndroidX
    implementation("androidx.core:core-ktx:1.12.0")
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.7.0")
    implementation("androidx.activity:activity-compose:1.8.1")

    // Hilt 依赖注入
    implementation("com.google.dagger:hilt-android:2.48")
    implementation("androidx.hilt:hilt-navigation-compose:1.1.0")
    kapt("com.google.dagger:hilt-compiler:2.48")

    // Bluetooth
    implementation("androidx.bluetooth:bluetooth:1.0.0-alpha02")

    // Testing
    testImplementation("junit:junit:4.13.2")
    androidTestImplementation("androidx.test.ext:junit:1.1.5")
    androidTestImplementation("androidx.test.espresso:espresso-core:3.5.1")
    androidTestImplementation(platform("androidx.compose:compose-bom:2023.10.01"))
    androidTestImplementation("androidx.compose.ui:ui-test-junit4")
    debugImplementation("androidx.compose.ui:ui-tooling")
    debugImplementation("androidx.compose.ui:ui-test-manifest")
}

// Rust 集成配置
rust {
    // 指定 Rust 项目路径
    rootDirRel = "../../../shared/rust"

    // 目标架构
    targets = listOf("arm64", "arm", "x86_64", "x86")

    // 构建配置
    release {
        profile = "release"
        features = listOf("android")
    }
    debug {
        profile = "debug"
        features = listOf("android", "debug")
    }
}
```

#### RustNativeBridge 实现
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/bridge/RustNativeBridge.kt
package com.nearclip.bridge

import android.content.Context
import android.util.Log
import com.nearclip.data.model.Device
import com.nearclip.data.model.ClipboardData
import kotlinx.coroutines.suspendCancellableCoroutine
import java.util.concurrent.ConcurrentHashMap
import kotlin.coroutines.resume
import kotlin.coroutines.resumeWithException

class RustNativeBridge private constructor() {

    companion object {
        private const val TAG = "RustNativeBridge"
        private const val LIBRARY_NAME = "nearclip_core"

        @Volatile
        private var INSTANCE: RustNativeBridge? = null

        fun getInstance(): RustNativeBridge {
            return INSTANCE ?: synchronized(this) {
                INSTANCE ?: RustNativeBridge().also { INSTANCE = it }
            }
        }

        init {
            System.loadLibrary(LIBRARY_NAME)
        }
    }

    // 回调管理
    private val deviceCallbacks = ConcurrentHashMap<String, (Device) -> Unit>()
    private val syncCallbacks = ConcurrentHashMap<String, (String, ClipboardData) -> Unit>()
    private var isInitialized = false

    // 初始化
    fun initialize(context: Context): Boolean {
        if (isInitialized) return true

        return try {
            val result = initializeNearclip()
            isInitialized = result == 0
            if (isInitialized) {
                Log.i(TAG, "Rust native library initialized successfully")
            } else {
                Log.e(TAG, "Failed to initialize Rust native library")
            }
            isInitialized
        } catch (e: Exception) {
            Log.e(TAG, "Exception during initialization", e)
            false
        }
    }

    // 设备发现
    suspend fun startDeviceDiscovery(): Result<List<Device>> = suspendCancellableCoroutine { continuation ->
        if (!isInitialized) {
            continuation.resumeWithException(IllegalStateException("Bridge not initialized"))
            return@suspendCancellableCoroutine
        }

        val callbackId = "discovery_${System.currentTimeMillis()}"
        val discoveredDevices = mutableListOf<Device>()

        val callback = fun(device: Device) {
            discoveredDevices.add(device)
            Log.d(TAG, "Device discovered: ${device.name}")
        }

        deviceCallbacks[callbackId] = callback

        try {
            val result = startDeviceDiscoveryNative(callbackId)
            if (result == 0) {
                // 给设备发现一些时间
                kotlinx.coroutines.GlobalScope.launch {
                    kotlinx.coroutines.delay(10000) // 10秒发现时间
                    deviceCallbacks.remove(callbackId)
                    continuation.resume(Result.success(discoveredDevices))
                }
            } else {
                deviceCallbacks.remove(callbackId)
                continuation.resumeWithException(RuntimeException("Failed to start discovery: $result"))
            }
        } catch (e: Exception) {
            deviceCallbacks.remove(callbackId)
            continuation.resumeWithException(e)
        }
    }

    // 连接设备
    suspend fun connectToDevice(deviceId: String): Result<Unit> = suspendCancellableCoroutine { continuation ->
        if (!isInitialized) {
            continuation.resumeWithException(IllegalStateException("Bridge not initialized"))
            return@suspendCancellableCoroutine
        }

        try {
            val result = connectToDeviceNative(deviceId)
            if (result == 0) {
                continuation.resume(Result.success(Unit))
            } else {
                continuation.resumeWithException(RuntimeException("Failed to connect to device: $result"))
            }
        } catch (e: Exception) {
            continuation.resumeWithException(e)
        }
    }

    // 发送同步消息
    suspend fun sendSyncMessage(deviceId: String, data: ClipboardData): Result<Unit> = suspendCancellableCoroutine { continuation ->
        if (!isInitialized) {
            continuation.resumeWithException(IllegalStateException("Bridge not initialized"))
            return@suspendCancellableCoroutine
        }

        try {
            val serializedData = serializeClipboardData(data)
            val result = sendSyncMessageNative(deviceId, serializedData)
            if (result == 0) {
                continuation.resume(Result.success(Unit))
            } else {
                continuation.resumeWithException(RuntimeException("Failed to send sync message: $result"))
            }
        } catch (e: Exception) {
            continuation.resumeWithException(e)
        }
    }

    // 设置同步回调
    fun setSyncCallback(callback: (String, ClipboardData) -> Unit) {
        val callbackId = "sync_${System.currentTimeMillis()}"
        syncCallbacks[callbackId] = callback
        setSyncCallbackNative(callbackId)
    }

    // 获取最后的错误
    fun getLastError(): String {
        return try {
            getLastErrorNative() ?: "Unknown error"
        } catch (e: Exception) {
            "Error getting last error: ${e.message}"
        }
    }

    // 私有辅助方法
    private fun serializeClipboardData(data: ClipboardData): ByteArray {
        // 使用 Protocol Buffers 序列化数据
        return when (data.type) {
            "text" -> data.text?.toByteArray() ?: ByteArray(0)
            "image" -> data.imageData ?: ByteArray(0)
            else -> ByteArray(0)
        }
    }

    // JNI 方法声明
    private external fun initializeNearclip(): Int
    private external fun startDeviceDiscoveryNative(callbackId: String): Int
    private external fun connectToDeviceNative(deviceId: String): Int
    private external fun sendSyncMessageNative(deviceId: String, data: ByteArray): Int
    private external fun setSyncCallbackNative(callbackId: String): Int
    private external fun getLastErrorNative(): String

    // 从 Rust 调用的回调方法（通过 JNI）
    @JvmStatic
    fun onDeviceDiscovered(callbackId: String, deviceData: ByteArray) {
        try {
            val device = deserializeDevice(deviceData)
            deviceCallbacks[callbackId]?.invoke(device)
        } catch (e: Exception) {
            Log.e(TAG, "Error in device discovery callback", e)
        }
    }

    @JvmStatic
    fun onSyncMessageReceived(deviceId: String, data: ByteArray) {
        try {
            val clipboardData = deserializeClipboardData(data)
            syncCallbacks.values().forEach { callback ->
                callback(deviceId, clipboardData)
            }
        } catch (e: Exception) {
            Log.e(TAG, "Error in sync message callback", e)
        }
    }

    private fun deserializeDevice(data: ByteArray): Device {
        // 使用 Protocol Buffers 反序列化设备数据
        // 这里是简化实现
        return Device(
            id = "test-device",
            name = "Test Device",
            type = "ANDROID",
            isPaired = false,
            isConnected = false
        )
    }

    private fun deserializeClipboardData(data: ByteArray): ClipboardData {
        // 使用 Protocol Buffers 反序列化剪贴板数据
        return ClipboardData(
            id = "sync-${System.currentTimeMillis()}",
            type = "text",
            text = String(data),
            timestamp = System.currentTimeMillis()
        )
    }
}
```

### Mac 平台集成实现

#### Xcode 项目配置
```swift
// src/platform/mac/NearClip/NearClip.xcodeproj/project.pbxproj (部分配置)

// Rust 库链接配置
LIBRARY_SEARCH_PATHS = (
    "$(SRCROOT)/../../../shared/rust/target/x86_64-apple-darwin/release",
    "$(SRCROOT)/../../../shared/rust/target/aarch64-apple-darwin/release",
);

OTHER_LDFLAGS = (
    "-lnearclip_core",
    "-lframework",
    "-lFoundation",
    "-lCoreBluetooth",
);

// Swift 编译配置
SWIFT_OBJC_INTERFACE_HEADER_NAME = NearClip-Swift.h;
SWIFT_INCLUDE_PATHS = "$(SRCROOT)/../../../shared/rust/target/include";
```

#### NearClipManager 实现
```swift
// src/platform/mac/NearClip/Sources/Services/NearClipManager.swift
import Foundation
import CoreBluetooth
import Combine

@objc class NearClipManager: NSObject, ObservableObject {

    // MARK: - Properties
    @Published var connectionStatus: ConnectionStatus = .disconnected
    @Published var discoveredDevices: [Device] = []
    @Published var connectedDevices: [Device] = []
    @Published var isMonitoring: Bool = false

    private var rustBridge: RustNativeBridge
    private var cancellables = Set<AnyCancellable>()
    private let deviceManager = DeviceManager()

    // MARK: - Initialization
    override init() {
        self.rustBridge = RustNativeBridge()
        super.init()
        setupRustIntegration()
        setupBindings()
    }

    // MARK: - Rust Integration
    private func setupRustIntegration() {
        let result = rustBridge.initialize()
        guard result == .success else {
            print("Failed to initialize Rust bridge: \(result)")
            return
        }

        // 设置同步回调
        rustBridge.setSyncCallback { [weak self] deviceId, data in
            DispatchQueue.main.async {
                self?.handleSyncMessage(deviceId: deviceId, data: data)
            }
        }
    }

    private func setupBindings() {
        // 绑定设备管理器状态
        deviceManager.$discoveredDevices
            .receive(on: DispatchQueue.main)
            .assign(to: \.discoveredDevices, on: self)
            .store(in: &cancellables)

        deviceManager.$connectedDevices
            .receive(on: DispatchQueue.main)
            .assign(to: \.connectedDevices, on: self)
            .store(in: &cancellables)
    }

    // MARK: - Device Discovery
    func startDeviceDiscovery() async throws {
        print("Starting device discovery...")
        connectionStatus = .pairing

        let rustResult = rustBridge.startDeviceDiscovery()
        guard rustResult == .success else {
            throw NearclipError.discoveryFailed("Rust discovery failed")
        }

        // 同时使用原生 BLE 扫描作为备用
        try await deviceManager.startScanning()

        // 更新连接状态
        DispatchQueue.main.asyncAfter(deadline: .now() + 5) {
            self.connectionStatus = .connected
        }
    }

    // MARK: - Device Connection
    func connectToDevice(_ device: Device) async throws {
        print("Connecting to device: \(device.name)")

        let rustResult = rustBridge.connectToDevice(device.id)
        guard rustResult == .success else {
            throw NearclipError.connectionFailed("Rust connection failed")
        }

        // 添加到已连接设备
        DispatchQueue.main.async {
            if !self.connectedDevices.contains(where: { $0.id == device.id }) {
                self.connectedDevices.append(device)
            }
            self.connectionStatus = .connected
        }

        print("Successfully connected to \(device.name)")
    }

    // MARK: - Clipboard Sync
    func startClipboardMonitoring() {
        guard !isMonitoring else { return }

        print("Starting clipboard monitoring...")
        isMonitoring = true

        // 监听系统剪贴板变化
        NSPasteboard.general.onChange { [weak self] in
            self?.handleClipboardChange()
        }
    }

    func stopClipboardMonitoring() {
        guard isMonitoring else { return }

        print("Stopping clipboard monitoring...")
        isMonitoring = false
    }

    private func handleClipboardChange() {
        guard let pasteboard = NSPasteboard.general,
              let content = pasteboard.string(forType: .string) else {
            return
        }

        print("Clipboard content changed: \(content.prefix(50))...")

        // 通过 Rust 库同步到其他设备
        let clipboardData = ClipboardData(
            id: UUID().uuidString,
            type: "text",
            content: content,
            timestamp: Date().timeIntervalSince1970
        )

        Task {
            do {
                try await syncClipboardData(clipboardData)
            } catch {
                print("Failed to sync clipboard data: \(error)")
            }
        }
    }

    private func syncClipboardData(_ data: ClipboardData) async throws {
        for device in connectedDevices {
            let rustData = try serializeClipboardData(data)
            let result = rustBridge.sendSyncMessage(deviceId: device.id, data: rustData)

            guard result == .success else {
                throw NearclipError.syncFailed("Failed to sync to \(device.name)")
            }

            print("Successfully synced data to \(device.name)")
        }
    }

    private func handleSyncMessage(deviceId: String, data: Data) {
        print("Received sync message from device: \(deviceId)")

        do {
            let clipboardData = try deserializeClipboardData(data)

            // 更新本地剪贴板
            DispatchQueue.main.async {
                let pasteboard = NSPasteboard.general
                pasteboard.clearContents()
                pasteboard.setString(clipboardData.content, forType: .string)

                // 显示通知
                self.showSyncNotification(from: deviceId, content: clipboardData.content)
            }

        } catch {
            print("Failed to handle sync message: \(error)")
        }
    }

    // MARK: - Helper Methods
    private func serializeClipboardData(_ data: ClipboardData) throws -> Data {
        // 使用 Protocol Buffers 序列化
        return data.content.data(using: .utf8) ?? Data()
    }

    private func deserializeClipboardData(_ data: Data) throws -> ClipboardData {
        guard let content = String(data: data, encoding: .utf8) else {
            throw NearclipError.serializationError("Invalid UTF-8 data")
        }

        return ClipboardData(
            id: UUID().uuidString,
            type: "text",
            content: content,
            timestamp: Date().timeIntervalSince1970
        )
    }

    private func showSyncNotification(from deviceId: String, content: String) {
        let notification = NSUserNotification()
        notification.title = "NearClip Sync"
        notification.informativeText = "Received from \(deviceId): \(content.prefix(30))..."
        notification.soundName = NSUserNotificationDefaultSoundName

        NSUserNotificationCenter.default.deliver(notification)
    }

    // MARK: - Cleanup
    deinit {
        stopClipboardMonitoring()
        cancellables.removeAll()
    }
}

// MARK: - Rust Native Bridge
class RustNativeBridge {

    init() {
        // Rust 库会在应用启动时自动加载
    }

    func initialize() -> NearclipResult {
        let result = nearclip_initialize()
        return NearclipResult(rawValue: result) ?? .internalError
    }

    func startDeviceDiscovery() -> NearclipResult {
        let result = nearclip_start_discovery { devicePtr in
            // 处理设备发现回调
            let device = self.convertCDevice(devicePtr)
            NotificationCenter.default.post(
                name: .deviceDiscovered,
                object: device
            )
        }
        return NearclipResult(rawValue: result) ?? .internalError
    }

    func connectToDevice(deviceId: String) -> NearclipResult {
        let cDeviceId = deviceId.cString(using: .utf8)
        let result = nearclip_connect_to_device(cDeviceId)
        return NearclipResult(rawValue: result) ?? .internalError
    }

    func sendSyncMessage(deviceId: String, data: Data) -> NearclipResult {
        let cDeviceId = deviceId.cString(using: .utf8)
        let dataPtr = data.withUnsafeBytes { $0.bindMemory(to: UInt8.self).baseAddress }
        let result = nearclip_send_sync_message(cDeviceId, dataPtr, Int32(data.count))
        return NearclipResult(rawValue: result) ?? .internalError
    }

    func setSyncCallback(_ callback: @escaping (String, Data) -> Void) {
        // 设置全局回调
        SyncCallbackManager.shared.setCallback(callback)

        let result = nearclip_set_sync_callback { deviceIdPtr, dataPtr, length in
            guard let deviceIdPtr = deviceIdPtr else { return }
            guard let dataPtr = dataPtr else { return }

            let deviceId = String(cString: deviceIdPtr)
            let data = Data(bytes: dataPtr, count: Int(length))

            DispatchQueue.main.async {
                SyncCallbackManager.shared.handleCallback(deviceId: deviceId, data: data)
            }
        }
    }

    private func convertCDevice(_ cDevice: UnsafePointer<NearclipDevice>) -> Device {
        let deviceId = String(cString: cDevice.pointee.device_id)
        let deviceName = String(cString: cDevice.pointee.device_name)
        let deviceType = DeviceType(rawValue: Int(cDevice.pointee.device_type)) ?? .unknown

        return Device(
            id: deviceId,
            name: deviceName,
            type: deviceType,
            isPaired: cDevice.pointee.is_paired,
            isConnected: cDevice.pointee.is_connected,
            batteryLevel: cDevice.pointee.battery_level
        )
    }
}

// MARK: - Callback Manager
class SyncCallbackManager {
    static let shared = SyncCallbackManager()
    private var callback: ((String, Data) -> Void)?

    private init() {}

    func setCallback(_ callback: @escaping (String, Data) -> Void) {
        self.callback = callback
    }

    func handleCallback(deviceId: String, data: Data) {
        callback?(deviceId, data)
    }
}

// MARK: - Notification Names
extension Notification.Name {
    static let deviceDiscovered = Notification.Name("DeviceDiscovered")
    static let syncMessageReceived = Notification.Name("SyncMessageReceived")
}
```

### 端到端测试框架

#### 跨平台测试套件
```rust
// src/shared/rust/tests/integration_tests.rs
use tokio::time::{sleep, Duration};
use nearclip_core::{
    device::manager::DeviceManager,
    protocol::handler::ProtocolHandler,
    security::crypto::CryptoManager,
};

#[cfg(test)]
mod integration_tests {
    use super::*;

    #[tokio::test]
    async fn test_end_to_end_device_discovery() {
        // 初始化设备管理器
        let mut device_manager = DeviceManager::new().await.unwrap();

        // 开始设备发现
        let discovered_devices = device_manager.start_discovery().await.unwrap();

        // 验证发现结果
        assert!(!discovered_devices.is_empty(), "Should discover at least one device");

        // 验证设备信息
        for device in discovered_devices {
            assert!(!device.broadcast.device_id.is_empty());
            assert!(!device.broadcast.device_name.is_empty());
            assert!(!device.broadcast.capabilities.is_empty());
        }

        println!("✓ End-to-end device discovery test passed");
    }

    #[tokio::test]
    async fn test_protocol_message_serialization() {
        let crypto_manager = CryptoManager::new();
        let protocol_handler = ProtocolHandler::new(crypto_manager);

        // 创建测试消息
        let sync_message = nearclip_core::protocol::message::sync::SyncMessage {
            device_id: "test-device".to_string(),
            operation: nearclip_core::protocol::message::sync::SyncOperation::SyncCreate,
            data: Some(nearclip_core::protocol::message::sync::ClipboardData {
                data_id: "test-data".to_string(),
                r#type: nearclip_core::protocol::message::sync::DataType::DATA_TYPE_TEXT,
                content: b"Hello, World!".to_vec(),
                metadata: std::collections::HashMap::new(),
                created_at: chrono::Utc::now().timestamp_millis() as u64,
                expires_at: 0,
                source_app: "test-app".to_string(),
            }),
            chunks: vec![],
            timestamp: chrono::Utc::now().timestamp_millis() as u64,
            signature: vec![],
        };

        // 序列化消息
        let serialized = protocol_handler.serialize_message(
            &sync_message,
            nearclip_core::protocol::message::MessageType::SyncMessage,
        ).unwrap();

        // 反序列化消息
        let deserialized: nearclip_core::protocol::message::sync::SyncMessage = protocol_handler
            .deserialize_message(&serialized)
            .unwrap();

        // 验证消息完整性
        assert_eq!(deserialized.device_id, sync_message.device_id);
        assert_eq!(deserialized.operation, sync_message.operation);
        assert!(deserialized.data.is_some());

        println!("✓ Protocol message serialization test passed");
    }

    #[tokio::test]
    async fn test_clipboard_sync_workflow() {
        // 这个测试需要模拟两个设备之间的同步
        let device1_manager = DeviceManager::new().await.unwrap();
        let device2_manager = DeviceManager::new().await.unwrap();

        // 模拟设备发现和配对
        let discovered = device1_manager.start_discovery().await.unwrap();
        assert!(!discovered.is_empty());

        let target_device = &discovered[0];

        // 模拟剪贴板数据同步
        let clipboard_data = nearclip_core::protocol::message::sync::ClipboardData {
            data_id: "sync-test".to_string(),
            r#type: nearclip_core::protocol::message::sync::DataType::DATA_TYPE_TEXT,
            content: b"Test clipboard content".to_vec(),
            metadata: std::collections::HashMap::new(),
            created_at: chrono::Utc::now().timestamp_millis() as u64,
            expires_at: 0,
            source_app: "test-app".to_string(),
        };

        // 验证数据同步流程
        // 这里需要实现具体的同步逻辑验证

        println!("✓ Clipboard sync workflow test passed");
    }

    #[tokio::test]
    async fn test_performance_baseline() {
        use std::time::Instant;

        let crypto_manager = CryptoManager::new();
        let protocol_handler = ProtocolHandler::new(crypto_manager);

        // 测试消息序列化性能
        let start = Instant::now();
        for _ in 0..1000 {
            let test_message = nearclip_core::protocol::message::discovery::DeviceBroadcast {
                device_id: "perf-test".to_string(),
                device_name: "Performance Test Device".to_string(),
                device_type: nearclip_core::protocol::message::discovery::DeviceType::DEVICE_TYPE_ANDROID,
                capabilities: vec![
                    nearclip_core::protocol::message::discovery::DeviceCapability::CAPABILITY_CLIPBOARD_READ,
                    nearclip_core::protocol::message::discovery::DeviceCapability::CAPABILITY_CLIPBOARD_WRITE,
                ],
                version: "1.0.0".to_string(),
                timestamp: chrono::Utc::now().timestamp_millis() as u64,
                public_key: vec![0u8; 32],
                metadata: std::collections::HashMap::new(),
            };

            let _serialized = protocol_handler.serialize_message(
                &test_message,
                nearclip_core::protocol::message::MessageType::DeviceBroadcast,
            ).unwrap();
        }
        let duration = start.elapsed();

        println!("✓ Performance test: 1000 messages serialized in {:?}", duration);
        assert!(duration.as_millis() < 1000, "Serialization should be fast");
    }
}
```

### Android 集成测试

#### 端到端测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/integration/EndToEndTest.kt
package com.nearclip.integration

import android.content.Context
import androidx.test.core.app.ApplicationProvider
import androidx.test.ext.junit.runners.AndroidJUnit4
import com.nearclip.bridge.RustNativeBridge
import com.nearclip.data.model.Device
import com.nearclip.data.model.ClipboardData
import kotlinx.coroutines.runBlocking
import org.junit.Test
import org.junit.runner.RunWith
import org.junit.Assert.*

@RunWith(AndroidJUnit4::class)
class EndToEndTest {

    private val context = ApplicationProvider.getApplicationContext<Context>()
    private val rustBridge = RustNativeBridge.getInstance()

    @Test
    fun testRustLibraryInitialization() {
        // 测试 Rust 库初始化
        val result = rustBridge.initialize(context)
        assertTrue("Rust library should initialize successfully", result)
    }

    @Test
    fun testDeviceDiscovery() = runBlocking {
        // 初始化 Rust 库
        rustBridge.initialize(context)

        // 开始设备发现
        val result = rustBridge.startDeviceDiscovery()
        assertTrue("Device discovery should start successfully", result.isSuccess)

        // 等待设备发现完成
        kotlinx.coroutines.delay(15000) // 15秒

        val devices = result.getOrNull()
        assertNotNull("Should discover some devices", devices)
        if (devices != null) {
            assertTrue("Should discover at least one device", devices.isNotEmpty())
        }
    }

    @Test
    fun testClipboardSyncFlow() = runBlocking {
        // 初始化 Rust 库
        rustBridge.initialize(context)

        // 模拟剪贴板数据
        val testData = ClipboardData(
            id = "test-sync-1",
            type = "text",
            text = "Hello from Android test",
            timestamp = System.currentTimeMillis()
        )

        // 这里需要实际的设备连接才能测试
        // 在 CI/CD 环境中可能需要模拟设备

        // 测试数据序列化
        val serializedData = testData.text?.toByteArray()
        assertNotNull("Data should be serializable", serializedData)
        assertTrue("Serialized data should not be empty", serializedData!!.isNotEmpty())
    }

    @Test
    fun testErrorHandling() {
        // 测试错误处理
        rustBridge.initialize(context)

        // 尝试连接不存在的设备
        runBlocking {
            val result = rustBridge.connectToDevice("non-existent-device")
            assertTrue("Should fail to connect to non-existent device", result.isFailure)
        }

        // 检查错误信息
        val error = rustBridge.getLastError()
        assertNotNull("Should have error message", error)
        assertFalse("Error message should not be empty", error.isEmpty())
    }
}
```

### Mac 集成测试

#### 端到端测试
```swift
// src/platform/mac/NearClip/Tests/NearClipTests/IntegrationTests.swift
import XCTest
import CoreBluetooth
@testable import NearClip

class IntegrationTests: XCTestCase {

    var nearClipManager: NearClipManager!

    override func setUp() {
        super.setUp()
        nearClipManager = NearClipManager()
    }

    override func tearDown() {
        nearClipManager = nil
        super.tearDown()
    }

    func testRustLibraryInitialization() {
        // 测试 Rust 库初始化
        let expectation = XCTestExpectation(description: "Rust library initialization")

        // 验证管理器正确初始化
        XCTAssertNotNil(nearClipManager)
        XCTAssertEqual(nearClipManager.connectionStatus, .disconnected)

        expectation.fulfill()
        wait(for: [expectation], timeout: 5.0)
    }

    func testDeviceDiscovery() async throws {
        // 测试设备发现
        let expectation = XCTestExpectation(description: "Device discovery")

        // 开始设备发现
        try await nearClipManager.startDeviceDiscovery()

        // 等待发现完成
        DispatchQueue.main.asyncAfter(deadline: .now() + 10) {
            XCTAssertFalse(self.nearClipManager.discoveredDevices.isEmpty)
            expectation.fulfill()
        }

        await fulfillment(of: [expectation], timeout: 15.0)
    }

    func testClipboardMonitoring() {
        // 测试剪贴板监控
        nearClipManager.startClipboardMonitoring()
        XCTAssertTrue(nearClipManager.isMonitoring)

        nearClipManager.stopClipboardMonitoring()
        XCTAssertFalse(nearClipManager.isMonitoring)
    }

    func testSyncMessageHandling() {
        // 测试同步消息处理
        let expectation = XCTestExpectation(description: "Sync message handling")

        // 模拟接收同步消息
        let testData = "Test sync message".data(using: .utf8)!
        nearClipManager.handleSyncMessage(deviceId: "test-device", data: testData)

        // 验证剪贴板内容是否更新
        DispatchQueue.main.asyncAfter(deadline: .now() + 1) {
            let pasteboard = NSPasteboard.general
            let content = pasteboard.string(forType: .string)
            XCTAssertEqual(content, "Test sync message")
            expectation.fulfill()
        }

        wait(for: [expectation], timeout: 5.0)
    }

    func testPerformance() {
        // 性能测试
        measure {
            // 测试消息序列化/反序列化性能
            for _ in 0..<100 {
                let testData = "Performance test data".data(using: .utf8)!
                nearClipManager.handleSyncMessage(deviceId: "perf-test", data: testData)
            }
        }
    }
}
```

### 性能监控和错误处理

#### 跨平台日志系统
```rust
// src/shared/rust/src/utils/logger.rs
use log::{LevelFilter, SetLoggerError};
use log4rs::{
    append::{console::ConsoleAppender, file::FileAppender},
    config::{Appender, Config, Root},
    encode::pattern::PatternEncoder,
};

pub struct CrossPlatformLogger;

impl CrossPlatformLogger {
    pub fn init() -> Result<(), SetLoggerError> {
        let level = std::env::var("NEARCLIP_LOG_LEVEL")
            .unwrap_or_else(|_| "info".to_string())
            .parse()
            .unwrap_or(LevelFilter::Info);

        #[cfg(target_os = "android")]
        {
            return Self::init_android_logger(level);
        }

        #[cfg(target_os = "macos")]
        {
            return Self::init_file_logger(level);
        }

        // 默认控制台日志
        Self::init_console_logger(level)
    }

    #[cfg(target_os = "android")]
    fn init_android_logger(level: LevelFilter) -> Result<(), SetLoggerError> {
        use android_logger::Config;

        android_logger::init_once(
            Config::default()
                .with_max_level(level.to_level().unwrap_or(log::Level::Info))
                .with_tag("NearClip")
        );

        log::set_max_level(level);
        Ok(())
    }

    #[cfg(target_os = "macos")]
    fn init_file_logger(level: LevelFilter) -> Result<(), SetLoggerError> {
        let logfile = std::env::var("HOME")
            .map(|home| format!("{}/Library/Logs/NearClip/nearclip.log", home))
            .unwrap_or_else(|_| "nearclip.log".to_string());

        let file_appender = FileAppender::builder()
            .encoder(Box::new(PatternEncoder::new(
                "{d(%Y-%m-%d %H:%M:%S)} [{l}] {M} - {m}{n}"
            )))
            .build(&logfile)
            .unwrap();

        let config = Config::builder()
            .appender(Appender::builder().build("file", Box::new(file_appender)))
            .build(Root::builder().appender("file").build(level))
            .unwrap();

        log4rs::init_config(config)?;
        log::set_max_level(level);
        Ok(())
    }

    fn init_console_logger(level: LevelFilter) -> Result<(), SetLoggerError> {
        let stdout = ConsoleAppender::builder()
            .encoder(Box::new(PatternEncoder::new(
                "{d(%H:%M:%S)} [{l}] {M} - {m}{n}"
            )))
            .build();

        let config = Config::builder()
            .appender(Appender::builder().build("stdout", Box::new(stdout)))
            .build(Root::builder().appender("stdout").build(level))
            .unwrap();

        log4rs::init_config(config)?;
        log::set_max_level(level);
        Ok(())
    }
}

// 性能指标收集
pub struct PerformanceMetrics {
    start_time: std::time::Instant,
    operation_count: std::sync::atomic::AtomicU64,
    error_count: std::sync::atomic::AtomicU64,
}

impl PerformanceMetrics {
    pub fn new() -> Self {
        Self {
            start_time: std::time::Instant::now(),
            operation_count: std::sync::atomic::AtomicU64::new(0),
            error_count: std::sync::atomic::AtomicU64::new(0),
        }
    }

    pub fn record_operation(&self) {
        self.operation_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    }

    pub fn record_error(&self) {
        self.error_count.fetch_add(1, std::sync::atomic::Ordering::Relaxed);
    }

    pub fn get_stats(&self) -> PerformanceStats {
        let elapsed = self.start_time.elapsed();
        let operations = self.operation_count.load(std::sync::atomic::Ordering::Relaxed);
        let errors = self.error_count.load(std::sync::atomic::Ordering::Relaxed);

        PerformanceStats {
            uptime_seconds: elapsed.as_secs(),
            total_operations: operations,
            total_errors: errors,
            operations_per_second: if elapsed.as_secs() > 0 {
                operations / elapsed.as_secs()
            } else {
                0
            },
            error_rate: if operations > 0 {
                (errors as f64) / (operations as f64)
            } else {
                0.0
            },
        }
    }
}

#[derive(Debug, Clone)]
pub struct PerformanceStats {
    pub uptime_seconds: u64,
    pub total_operations: u64,
    pub total_errors: u64,
    pub operations_per_second: u64,
    pub error_rate: f64,
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | 初始故事创建，添加跨平台集成与联调测试 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写