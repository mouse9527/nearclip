# Story 2.3: 设备授权配对机制

## Status
Draft

## Story
**作为** 用户，
**我希望** 设备配对过程安全可靠，需要双方确认才能建立连接，
**以便** 确保只有授权的设备才能访问我的粘贴板内容。

## Acceptance Criteria
1. 实现配对请求的双向确认机制
2. 建立设备身份验证和密钥交换流程
3. 存储已配对设备的安全凭证
4. 提供配对状态指示和进度反馈
5. 实现配对超时和错误处理机制

## Tasks / Subtasks
- [ ] 设计双向确认协议 (AC: 1)
  - [ ] 定义配对请求/响应消息格式
  - [ ] 实现确认码生成和验证
  - [ ] 创建用户确认界面流程
  - [ ] 设计配对状态机
  - [ ] 实现配对超时和重试逻辑
- [ ] 实现设备身份验证 (AC: 2)
  - [ ] 创建设备证书管理系统
  - [ ] 实现基于 ECDH 的密钥交换
  - [ ] 建立设备身份验证流程
  - [ ] 添加设备指纹验证
  - [ ] 实现会话密钥生成和分发
- [ ] 实现安全凭证存储 (AC: 3)
  - [ ] 创建安全的本地存储机制
  - [ ] 实现设备配对记录管理
  - [ ] 添加凭证加密和保护
  - [ ] 创建凭证更新和撤销机制
  - [ ] 实现跨平台凭证同步
- [ ] 实现配对状态管理 (AC: 4)
  - [ ] 创建配对状态监控器
  - [ ] 实现进度反馈界面
  - [ ] 添加配对成功/失败通知
  - [ ] 创建状态变更日志
  - [ ] 实现实时状态同步
- [ ] 实现错误处理机制 (AC: 5)
  - [ ] 创建配对错误分类系统
  - [ ] 实现错误恢复策略
  - [ ] 添加用户友好的错误提示
  - [ ] 创建错误诊断工具
  - [ ] 实现配对失败重试机制
- [ ] 实现安全性验证
  - [ ] 添加中间人攻击防护
  - [ ] 实现重放攻击防护
  - [ ] 创建配对审计日志
  - [ ] 实现异常行为检测
  - [ ] 添加安全策略配置

## Dev Notes

### 双向确认协议设计
[Source: architecture/api-specification.md]

#### 配对协议定义
```protobuf
// src/shared/protocol/pairing.proto
syntax = "proto3";

package nearclip.pairing;

// 配对请求
message PairingRequest {
  string request_id = 1;                // 请求唯一标识
  string initiator_id = 2;              // 发起设备ID
  string target_id = 3;                 // 目标设备ID
  DeviceInfo initiator_info = 4;        // 发起设备信息
  bytes public_key = 5;                 // 发起设备公钥
  bytes nonce = 6;                      // 随机数
  int64 timestamp = 7;                  // 时间戳
  bytes signature = 8;                  // 签名
  PairingType pairing_type = 9;         // 配对类型
  map<string, string> metadata = 10;    // 扩展元数据
}

// 配对响应
message PairingResponse {
  string request_id = 1;                // 对应的请求ID
  string responder_id = 2;              // 响应设备ID
  bool accepted = 3;                    // 是否接受配对
  string confirmation_code = 4;         // 确认码
  bytes public_key = 5;                 // 响应设备公钥
  bytes signed_nonce = 6;               // 签名的随机数
  bytes session_key = 7;                // 会话密钥（加密）
  int64 timestamp = 8;                  // 时间戳
  bytes signature = 9;                  // 签名
  string rejection_reason = 10;         // 拒绝原因（如果拒绝）
}

// 配对确认
message PairingConfirmation {
  string request_id = 1;                // 请求ID
  string confirmation_code = 4;         // 确认码
  bytes encrypted_session_key = 5;      // 加密的会话密钥
  int64 timestamp = 6;                  // 时间戳
  bytes signature = 7;                  // 签名
}

// 设备信息
message DeviceInfo {
  string device_id = 1;
  string device_name = 2;
  DeviceType device_type = 3;
  string device_model = 4;
  string manufacturer = 5;
  string platform_version = 6;
  bytes device_certificate = 7;         // 设备证书
  bytes device_fingerprint = 8;         // 设备指纹
  int64 certificate_expires = 9;        // 证书过期时间
}

// 配对类型
enum PairingType {
  PAIRING_UNKNOWN = 0;
  PAIRING_QR_CODE = 1;                  // QR码配对
  PAIRING_MANUAL = 2;                   // 手动配对
  PAIRING_NFC = 3;                      // NFC配对
}

// 配对状态
enum PairingStatus {
  PAIRING_UNKNOWN = 0;
  PAIRING_INITIATED = 1;                // 已发起
  PAIRING_SENT = 2;                     // 已发送
  PAIRING_RECEIVED = 3;                 // 已接收
  PAIRING_PENDING_CONFIRMATION = 4;    // 等待确认
  PAIRING_CONFIRMED = 5;                // 已确认
  PAIRING_COMPLETED = 6;                // 已完成
  PAIRING_FAILED = 7;                   // 失败
  PAIRING_CANCELLED = 8;                // 已取消
  PAIRING_TIMEOUT = 9;                  // 超时
}
```

#### Rust 配对管理器
```rust
// src/shared/rust/src/pairing/manager.rs
use chrono::{DateTime, Utc, Duration};
use ring::signature::{self, Ed25519};
use ring::agreement::{EphemeralPrivateKey, UnparsedPublicKey, agree_ephemeral, ECDH_P256, agree_ephemeral_psk};
use sha2::{Sha256, Digest};
use rand::Rng;
use serde::{Deserialize, Serialize};
use thiserror::Error;
use std::collections::HashMap;
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Error, Debug)]
pub enum PairingError {
    #[error("Invalid pairing request: {0}")]
    InvalidRequest(String),
    #[error("Device authentication failed: {0}")]
    AuthenticationFailed(String),
    #[error("Key exchange failed: {0}")]
    KeyExchangeFailed(String),
    #[error("Pairing timeout")]
    Timeout,
    #[error("Pairing cancelled")]
    Cancelled,
    #[error("Invalid confirmation code")]
    InvalidConfirmationCode,
    #[error("Cryptographic error: {0}")]
    CryptoError(String),
}

#[derive(Debug, Clone)]
pub struct PairingSession {
    pub request_id: String,
    pub initiator_id: String,
    pub target_id: String,
    pub status: PairingStatus,
    pub created_at: DateTime<Utc>,
    pub expires_at: DateTime<Utc>,
    pub confirmation_code: Option<String>,
    pub session_key: Option<Vec<u8>>,
    pub metadata: HashMap<String, String>,
}

#[derive(Debug, Clone)]
pub struct DeviceCredentials {
    pub device_id: String,
    pub device_certificate: Vec<u8>,
    pub private_key: Ed25519::KeyPair,
    pub peer_certificates: HashMap<String, Vec<u8>>,
    pub session_keys: HashMap<String, Vec<u8>>,
}

pub struct PairingManager {
    private_key: Ed25519::KeyPair,
    device_id: String,
    credentials: Arc<RwLock<DeviceCredentials>>,
    active_sessions: Arc<RwLock<HashMap<String, PairingSession>>>,
    pairing_timeout: Duration,
}

impl PairingManager {
    pub fn new(
        device_id: String,
        private_key: Ed25519::KeyPair,
        device_certificate: Vec<u8>,
    ) -> Self {
        let credentials = DeviceCredentials {
            device_id: device_id.clone(),
            device_certificate,
            private_key: private_key.clone(),
            peer_certificates: HashMap::new(),
            session_keys: HashMap::new(),
        };

        Self {
            private_key,
            device_id,
            credentials: Arc::new(RwLock::new(credentials)),
            active_sessions: Arc::new(RwLock::new(HashMap::new())),
            pairing_timeout: Duration::minutes(5),
        }
    }

    /// 发起配对请求
    pub async fn initiate_pairing(
        &self,
        target_id: String,
        device_info: DeviceInfo,
        pairing_type: PairingType,
    ) -> Result<String, PairingError> {
        let request_id = self.generate_request_id();
        let nonce = self.generate_nonce();
        let timestamp = Utc::now();

        // 创建配对请求
        let pairing_request = PairingRequest {
            request_id: request_id.clone(),
            initiator_id: self.device_id.clone(),
            target_id,
            initiator_info: Some(device_info),
            public_key: self.private_key.public_key().as_ref().to_vec(),
            nonce: nonce.clone(),
            timestamp: timestamp.timestamp_millis() as u64,
            signature: Vec::new(), // 将在签名后填充
            pairing_type: pairing_type as i32,
            metadata: HashMap::new(),
        };

        // 签名请求
        let signed_request = self.sign_pairing_request(pairing_request)?;

        // 创建会话
        let session = PairingSession {
            request_id: request_id.clone(),
            initiator_id: self.device_id.clone(),
            target_id: signed_request.target_id.clone(),
            status: PairingStatus::PAIRING_SENT,
            created_at: timestamp,
            expires_at: timestamp + self.pairing_timeout,
            confirmation_code: None,
            session_key: None,
            metadata: HashMap::new(),
        };

        // 存储会话
        {
            let mut sessions = self.active_sessions.write().await;
            sessions.insert(request_id.clone(), session);
        }

        Ok(request_id)
    }

    /// 处理配对请求
    pub async fn handle_pairing_request(
        &self,
        request: PairingRequest,
    ) -> Result<PairingResponse, PairingError> {
        // 验证请求
        self.validate_pairing_request(&request).await?;

        // 生成确认码
        let confirmation_code = self.generate_confirmation_code();

        // 执行 ECDH 密钥交换
        let session_key = self.perform_key_exchange(&request.public_key).await?;

        // 创建响应
        let response = PairingResponse {
            request_id: request.request_id.clone(),
            responder_id: self.device_id.clone(),
            accepted: true,
            confirmation_code: confirmation_code.clone(),
            public_key: self.private_key.public_key().as_ref().to_vec(),
            signed_nonce: self.sign_nonce(&request.nonce)?,
            session_key: self.encrypt_session_key(&session_key, &request.public_key)?,
            timestamp: Utc::now().timestamp_millis() as u64,
            signature: Vec::new(), // 将在签名后填充
            rejection_reason: String::new(),
        };

        // 签名响应
        let signed_response = self.sign_pairing_response(response)?;

        // 存储会话
        let session = PairingSession {
            request_id: request.request_id.clone(),
            initiator_id: request.initiator_id.clone(),
            target_id: self.device_id.clone(),
            status: PairingStatus::PAIRING_RECEIVED,
            created_at: Utc::now(),
            expires_at: Utc::now() + self.pairing_timeout,
            confirmation_code: Some(confirmation_code),
            session_key: Some(session_key),
            metadata: HashMap::new(),
        };

        {
            let mut sessions = self.active_sessions.write().await;
            sessions.insert(request.request_id.clone(), session);
        }

        Ok(signed_response)
    }

    /// 确认配对
    pub async fn confirm_pairing(
        &self,
        request_id: &str,
        confirmation_code: &str,
    ) -> Result<PairingConfirmation, PairingError> {
        let mut sessions = self.active_sessions.write().await;
        let session = sessions.get_mut(request_id)
            .ok_or(PairingError::InvalidRequest("Session not found".to_string()))?;

        // 验证确认码
        if session.confirmation_code.as_ref() != Some(&confirmation_code.to_string()) {
            return Err(PairingError::InvalidConfirmationCode);
        }

        // 验证会话是否过期
        if Utc::now() > session.expires_at {
            return Err(PairingError::Timeout);
        }

        // 生成最终确认消息
        let confirmation = PairingConfirmation {
            request_id: request_id.to_string(),
            confirmation_code: confirmation_code.to_string(),
            encrypted_session_key: self.encrypt_session_key(
                session.session_key.as_ref().unwrap(),
                &session.target_id.as_bytes().to_vec(),
            )?,
            timestamp: Utc::now().timestamp_millis() as u64,
            signature: Vec::new(),
        };

        // 签名确认
        let signed_confirmation = self.sign_pairing_confirmation(confirmation)?;

        // 更新会话状态
        session.status = PairingStatus::PAIRING_CONFIRMED;

        // 存储配对凭证
        self.store_pairing_credentials(&session).await?;

        Ok(signed_confirmation)
    }

    /// 完成配对
    pub async fn complete_pairing(
        &self,
        request_id: &str,
        confirmation: PairingConfirmation,
    ) -> Result<(), PairingError> {
        let mut sessions = self.active_sessions.write().await;
        let session = sessions.get_mut(request_id)
            .ok_or(PairingError::InvalidRequest("Session not found".to_string()))?;

        // 验证确认
        self.validate_pairing_confirmation(&session, &confirmation).await?;

        // 解密会话密钥
        let decrypted_key = self.decrypt_session_key(
            &confirmation.encrypted_session_key,
            &confirmation.confirmation_code.as_bytes(),
        )?;

        // 更新会话
        session.session_key = Some(decrypted_key);
        session.status = PairingStatus::PAIRING_COMPLETED;

        // 存储配对凭证
        self.store_pairing_credentials(&session).await?;

        Ok(())
    }

    /// 获取活动会话
    pub async fn get_active_session(&self, request_id: &str) -> Option<PairingSession> {
        let sessions = self.active_sessions.read().await;
        sessions.get(request_id).cloned()
    }

    /// 获取所有活动会话
    pub async fn get_active_sessions(&self) -> Vec<PairingSession> {
        let sessions = self.active_sessions.read().await;
        sessions.values().cloned().collect()
    }

    /// 取消配对
    pub async fn cancel_pairing(&self, request_id: &str) -> Result<(), PairingError> {
        let mut sessions = self.active_sessions.write().await;
        if let Some(session) sessions.get_mut(request_id) {
            session.status = PairingStatus::PAIRING_CANCELLED;
            Ok(())
        } else {
            Err(PairingError::InvalidRequest("Session not found".to_string()))
        }
    }

    /// 清理过期会话
    pub async fn cleanup_expired_sessions(&self) {
        let mut sessions = self.active_sessions.write().await;
        let now = Utc::now();

        sessions.retain(|_, session| {
            if now > session.expires_at {
                session.status = PairingStatus::PAIRING_TIMEOUT;
                false
            } else {
                true
            }
        });
    }

    // 私有方法实现
    fn generate_request_id(&self) -> String {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let id: u64 = rng.gen();
        format!("pairing_{}_{}", id, Utc::now().timestamp_millis())
    }

    fn generate_nonce(&self) -> Vec<u8> {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        let mut nonce = vec![0u8; 32];
        rng.fill(&mut nonce[..]);
        nonce
    }

    fn generate_confirmation_code(&self) -> String {
        use rand::Rng;
        let mut rng = rand::thread_rng();
        (0..6).map(|_| rng.gen_range(0..10).to_string()).collect()
    }

    async fn perform_key_exchange(
        &self,
        peer_public_key: &[u8],
    ) -> Result<Vec<u8>, PairingError> {
        let private_key = EphemeralPrivateKey::generate(&ECDH_P256)
            .map_err(|e| PairingError::KeyExchangeFailed(e.to_string()))?;

        let peer_public_key = UnparsedPublicKey::new(&ECDH_P256, peer_public_key);

        let shared_secret = agree_ephemeral(
            private_key,
            &peer_public_key,
            |shared_secret| {
                let mut hasher = Sha256::new();
                hasher.update(shared_secret);
                hasher.finalize().to_vec()
            },
        ).map_err(|e| PairingError::KeyExchangeFailed(e.to_string()))?;

        Ok(shared_secret)
    }

    async fn validate_pairing_request(&self, request: &PairingRequest) -> Result<(), PairingError> {
        // 验证时间戳
        let request_time = DateTime::from_timestamp(request.timestamp as i64 / 1000, 0)
            .ok_or(PairingError::InvalidRequest("Invalid timestamp".to_string()))?;

        if Utc::now().signed_duration_since(request_time) > chrono::Duration::minutes(5) {
            return Err(PairingError::Timeout);
        }

        // 验证签名
        let public_key = ring::signature::UnparsedPublicKey::new(
            &ring::signature::ED25519,
            &request.public_key,
        );

        // 重新序列化请求（不包含签名）
        let mut request_copy = request.clone();
        request_copy.signature.clear();
        let serialized = serde_json::to_string(&request_copy)
            .map_err(|e| PairingError::InvalidRequest(e.to_string()))?;

        let signature = base64::decode(&request.signature)
            .map_err(|_| PairingError::AuthenticationFailed("Invalid signature".to_string()))?;

        public_key.verify(serialized.as_bytes(), &signature)
            .map_err(|_| PairingError::AuthenticationFailed("Signature verification failed".to_string()))?;

        Ok(())
    }

    async fn store_pairing_credentials(&self, session: &PairingSession) -> Result<(), PairingError> {
        let mut credentials = self.credentials.write().await;

        if let Some(session_key) = &session.session_key {
            credentials.session_keys.insert(session.target_id.clone(), session_key.clone());
        }

        Ok(())
    }

    fn sign_pairing_request(&self, mut request: PairingRequest) -> Result<PairingRequest, PairingError> {
        let serialized = serde_json::to_string(&request)
            .map_err(|e| PairingError::CryptoError(e.to_string()))?;

        let signature = self.private_key.sign(serialized.as_bytes());
        request.signature = base64::encode(signature.as_ref());

        Ok(request)
    }

    fn sign_pairing_response(&self, mut response: PairingResponse) -> Result<PairingResponse, PairingError> {
        let serialized = serde_json::to_string(&response)
            .map_err(|e| PairingError::CryptoError(e.to_string()))?;

        let signature = self.private_key.sign(serialized.as_bytes());
        response.signature = base64::encode(signature.as_ref());

        Ok(response)
    }

    fn sign_pairing_confirmation(&self, mut confirmation: PairingConfirmation) -> Result<PairingConfirmation, PairingError> {
        let serialized = serde_json::to_string(&confirmation)
            .map_err(|e| PairingError::CryptoError(e.to_string()))?;

        let signature = self.private_key.sign(serialized.as_bytes());
        confirmation.signature = base64::encode(signature.as_ref());

        Ok(confirmation)
    }

    fn sign_nonce(&self, nonce: &[u8]) -> Result<Vec<u8>, PairingError> {
        let signature = self.private_key.sign(nonce);
        Ok(signature.as_ref().to_vec())
    }

    fn encrypt_session_key(&self, session_key: &[u8], peer_key: &[u8]) -> Result<Vec<u8>, PairingError> {
        // 简化实现：实际应该使用 AES-GCM 或其他加密方案
        let mut encrypted = session_key.to_vec();
        for i in 0..encrypted.len().min(peer_key.len()) {
            encrypted[i] ^= peer_key[i];
        }
        Ok(encrypted)
    }

    fn decrypt_session_key(&self, encrypted_key: &[u8], key_material: &[u8]) -> Result<Vec<u8>, PairingError> {
        // 简化实现：与加密过程相对应
        let mut decrypted = encrypted_key.to_vec();
        for i in 0..decrypted.len().min(key_material.len()) {
            decrypted[i] ^= key_material[i];
        }
        Ok(decrypted)
    }

    async fn validate_pairing_confirmation(
        &self,
        session: &PairingSession,
        confirmation: &PairingConfirmation,
    ) -> Result<(), PairingError> {
        // 验证确认码
        if confirmation.confirmation_code != session.confirmation_code.as_ref().unwrap() {
            return Err(PairingError::InvalidConfirmationCode);
        }

        // 验证时间戳
        let confirmation_time = DateTime::from_timestamp(confirmation.timestamp as i64 / 1000, 0)
            .ok_or(PairingError::InvalidRequest("Invalid timestamp".to_string()))?;

        if Utc::now().signed_duration_since(confirmation_time) > chrono::Duration::minutes(5) {
            return Err(PairingError::Timeout);
        }

        // 验证签名
        let public_key = ring::signature::UnparsedPublicKey::new(
            &ring::signature::ED25519,
            &session.target_id.as_bytes(), // 简化：实际应该使用真实的公钥
        );

        let mut confirmation_copy = confirmation.clone();
        confirmation_copy.signature.clear();
        let serialized = serde_json::to_string(&confirmation_copy)
            .map_err(|e| PairingError::InvalidRequest(e.to_string()))?;

        let signature = base64::decode(&confirmation.signature)
            .map_err(|_| PairingError::AuthenticationFailed("Invalid signature".to_string()))?;

        public_key.verify(serialized.as_bytes(), &signature)
            .map_err(|_| PairingError::AuthenticationFailed("Signature verification failed".to_string()))?;

        Ok(())
    }
}
```

### Android 配对确认界面

#### PairingConfirmationScreen
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/ui/screens/PairingConfirmationScreen.kt
package com.nearclip.ui.screens

import androidx.compose.animation.*
import androidx.compose.animation.core.*
import androidx.compose.foundation.background
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.*
import androidx.compose.material3.*
import androidx.compose.runtime.*
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.draw.clip
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.text.style.TextAlign
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.nearclip.ui.viewmodel.PairingConfirmationViewModel

@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun PairingConfirmationScreen(
    pairingRequestId: String,
    onAccept: () -> Unit,
    onReject: () -> Unit,
    onClose: () -> Unit,
    viewModel: PairingConfirmationViewModel = hiltViewModel()
) {
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    LaunchedEffect(pairingRequestId) {
        viewModel.loadPairingRequest(pairingRequestId)
    }

    LaunchedEffect(uiState.pairingResult) {
        when (uiState.pairingResult) {
            is PairingResult.ACCEPTED -> onAccept()
            is PairingResult.REJECTED -> onReject()
            else -> { /* No action needed */ }
        }
    }

    Scaffold(
        topBar = {
            TopAppBar(
                title = { Text("配对请求") },
                navigationIcon = {
                    IconButton(onClick = onClose) {
                        Icon(Icons.Default.Close, contentDescription = "关闭")
                    }
                }
            )
        }
    ) { paddingValues ->
        if (uiState.isLoading) {
            LoadingState()
        } else if (uiState.pairingRequest != null) {
            PairingRequestContent(
                pairingRequest = uiState.pairingRequest!!,
                confirmationCode = uiState.confirmationCode,
                onAccept = { viewModel.acceptPairing() },
                onReject = { viewModel.rejectPairing() },
                modifier = Modifier
                    .fillMaxSize()
                    .padding(paddingValues)
            )
        } else {
            ErrorState(
                error = uiState.error ?: "未知错误",
                onRetry = { viewModel.loadPairingRequest(pairingRequestId) }
            )
        }
    }
}

@Composable
private fun PairingRequestContent(
    pairingRequest: PairingRequest,
    confirmationCode: String,
    onAccept: () -> Unit,
    onReject: () -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier
            .fillMaxSize()
            .padding(24.dp),
        horizontalAlignment = Alignment.CenterHorizontally,
        verticalArrangement = Arrangement.spacedBy(24.dp)
    ) {
        // 设备图标和动画
        DeviceIconAnimation()

        // 配对请求信息
        PairingRequestInfo(
            deviceInfo = pairingRequest.deviceInfo,
            modifier = Modifier.fillMaxWidth()
        )

        // 确认码显示
        ConfirmationCodeDisplay(
            code = confirmationCode,
            modifier = Modifier.fillMaxWidth()
        )

        // 安全提示
        SecurityHint()

        Spacer(modifier = Modifier.weight(1f))

        // 操作按钮
        ActionButtons(
            onAccept = onAccept,
            onReject = onReject,
            modifier = Modifier.fillMaxWidth()
        )
    }
}

@Composable
private fun DeviceIconAnimation(
    modifier: Modifier = Modifier
) {
    val infiniteTransition = rememberInfiniteTransition(label = "pulse")
    val scale by infiniteTransition.animateFloat(
        initialValue = 1f,
        targetValue = 1.1f,
        animationSpec = infiniteRepeatable(
            animation = tween(1000, easing = EaseInOutCubic),
            repeatMode = RepeatMode.Reverse
        ),
        label = "scale"
    )

    Box(
        modifier = modifier
            .size(120.dp)
            .clip(RoundedCornerShape(60.dp))
            .background(
                MaterialTheme.colorScheme.primaryContainer,
                RoundedCornerShape(60.dp)
            ),
        contentAlignment = Alignment.Center
    ) {
        Icon(
            imageVector = Icons.Default.Devices,
            contentDescription = null,
            modifier = Modifier
                .size(60.dp)
                .scale(scale),
            tint = MaterialTheme.colorScheme.primary
        )
    }
}

@Composable
private fun PairingRequestInfo(
    deviceInfo: DeviceInfo,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        elevation = CardDefaults.cardElevation(defaultElevation = 2.dp)
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(20.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text(
                text = "设备请求配对",
                style = MaterialTheme.typography.titleLarge,
                fontWeight = FontWeight.Medium
            )

            Spacer(modifier = Modifier.height(8.dp))

            DeviceInfoRow(
                icon = Icons.Default.Smartphone,
                label = "设备名称",
                value = deviceInfo.name
            )

            DeviceInfoRow(
                icon = Icons.Default.Computer,
                label = "设备型号",
                value = deviceInfo.model
            )

            DeviceInfoRow(
                icon = Icons.Default.Android,
                label = "平台类型",
                value = deviceInfo.platformType
            )

            DeviceInfoRow(
                icon = Icons.Default.Security,
                label = "设备ID",
                value = deviceInfo.id.takeLast(8)
            )
        }
    }
}

@Composable
private fun DeviceInfoRow(
    icon: androidx.compose.ui.graphics.vector.ImageVector,
    label: String,
    value: String,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier.fillMaxWidth(),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Icon(
            imageVector = icon,
            contentDescription = null,
            tint = MaterialTheme.colorScheme.onSurfaceVariant,
            modifier = Modifier.size(20.dp)
        )

        Column(modifier = Modifier.weight(1f)) {
            Text(
                text = label,
                style = MaterialTheme.typography.bodySmall,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
            Text(
                text = value,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurface
            )
        }
    }
}

@Composable
private fun ConfirmationCodeDisplay(
    code: String,
    modifier: Modifier = Modifier
) {
    Card(
        modifier = modifier,
        colors = CardDefaults.cardColors(
            containerColor = MaterialTheme.colorScheme.secondaryContainer
        )
    ) {
        Column(
            modifier = Modifier
                .fillMaxWidth()
                .padding(20.dp),
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(12.dp)
        ) {
            Text(
                text = "确认配对",
                style = MaterialTheme.typography.titleMedium,
                fontWeight = FontWeight.Medium,
                color = MaterialTheme.colorScheme.onSecondaryContainer
            )

            Text(
                text = "请在另一台设备上输入以下确认码",
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSecondaryContainer,
                textAlign = TextAlign.Center
            )

            // 确认码显示
            Row(
                horizontalArrangement = Arrangement.spacedBy(8.dp)
            ) {
                code.forEachIndexed { index, digit ->
                    ConfirmationCodeDigit(
                        digit = digit,
                        modifier = Modifier.size(48.dp)
                    )
                }
            }
        }
    }
}

@Composable
private fun ConfirmationCodeDigit(
    digit: Char,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier
            .clip(RoundedCornerShape(8.dp))
            .background(MaterialTheme.colorScheme.background),
        contentAlignment = Alignment.Center
    ) {
        Text(
            text = digit.toString(),
            style = MaterialTheme.typography.headlineMedium,
            fontWeight = FontWeight.Bold,
            color = MaterialTheme.colorScheme.primary
        )
    }
}

@Composable
private fun SecurityHint(
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier
            .fillMaxWidth()
            .clip(RoundedCornerShape(8.dp))
            .background(Color(0xFFFFF3E0))
            .padding(16.dp),
        verticalAlignment = Alignment.CenterVertically,
        horizontalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        Icon(
            imageVector = Icons.Default.Security,
            contentDescription = null,
            tint = Color(0xFFFF9800),
            modifier = Modifier.size(24.dp)
        )

        Text(
            text = "请确认这是您信任的设备。配对后将允许访问您的剪贴板内容。",
            style = MaterialTheme.typography.bodySmall,
            color = Color(0xFFE65100),
            modifier = Modifier.weight(1f)
        )
    }
}

@Composable
private fun ActionButtons(
    onAccept: () -> Unit,
    onReject: () -> Unit,
    modifier: Modifier = Modifier
) {
    Row(
        modifier = modifier,
        horizontalArrangement = Arrangement.spacedBy(12.dp)
    ) {
        OutlinedButton(
            onClick = onReject,
            modifier = Modifier.weight(1f)
        ) {
            Icon(
                imageVector = Icons.Default.Close,
                contentDescription = null,
                modifier = Modifier.size(18.dp)
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text("拒绝")
        }

        Button(
            onClick = onAccept,
            modifier = Modifier.weight(1f)
        ) {
            Icon(
                imageVector = Icons.Default.Check,
                contentDescription = null,
                modifier = Modifier.size(18.dp)
            )
            Spacer(modifier = Modifier.width(8.dp))
            Text("接受")
        }
    }
}

@Composable
private fun LoadingState(
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            CircularProgressIndicator(
                modifier = Modifier.size(48.dp),
                strokeWidth = 3.dp
            )
            Text(
                text = "加载配对请求...",
                style = MaterialTheme.typography.bodyLarge,
                color = MaterialTheme.colorScheme.onSurfaceVariant
            )
        }
    }
}

@Composable
private fun ErrorState(
    error: String,
    onRetry: () -> Unit,
    modifier: Modifier = Modifier
) {
    Box(
        modifier = modifier.fillMaxSize(),
        contentAlignment = Alignment.Center
    ) {
        Column(
            horizontalAlignment = Alignment.CenterHorizontally,
            verticalArrangement = Arrangement.spacedBy(16.dp)
        ) {
            Icon(
                imageVector = Icons.Default.Error,
                contentDescription = null,
                modifier = Modifier.size(64.dp),
                tint = MaterialTheme.colorScheme.error
            )

            Text(
                text = "加载失败",
                style = MaterialTheme.typography.headlineSmall,
                color = MaterialTheme.colorScheme.error
            )

            Text(
                text = error,
                style = MaterialTheme.typography.bodyMedium,
                color = MaterialTheme.colorScheme.onSurfaceVariant,
                textAlign = TextAlign.Center
            )

            Button(onClick = onRetry) {
                Icon(
                    imageVector = Icons.Default.Refresh,
                    contentDescription = null
                )
                Spacer(modifier = Modifier.width(8.dp))
                Text("重试")
            }
        }
    }
}
```

### Mac 配对确认界面

#### SwiftUI PairingConfirmationView
```swift
// src/platform/mac/NearClip/Sources/Views/PairingConfirmationView.swift
import SwiftUI

struct PairingConfirmationView: View {
    let pairingRequest: PairingRequest
    let confirmationCode: String
    let onAccept: () -> Void
    let onReject: () -> Void

    @State private var isAnimating = false

    var body: some View {
        VStack(spacing: 24) {
            // Header
            headerView

            // Device Icon
            deviceIconView

            // Device Info
            deviceInfoView

            // Confirmation Code
            confirmationCodeView

            // Security Warning
            securityWarningView

            Spacer()

            // Action Buttons
            actionButtonsView
        }
        .frame(width: 400, height: 600)
        .onAppear {
            withAnimation(.easeInOut(duration: 1.5).repeatForever(autoreverses: true)) {
                isAnimating = true
            }
        }
    }

    private var headerView: some View {
        HStack {
            Text("配对请求")
                .font(.title2)
                .fontWeight(.semibold)

            Spacer()
        }
        .padding(.horizontal, 20)
        .padding(.top, 20)
    }

    private var deviceIconView: some View {
        ZStack {
            Circle()
                .fill(Color.accentColor.opacity(0.1))
                .frame(width: 120, height: 120)

            Image(systemName: deviceIconName)
                .font(.system(size: 50))
                .foregroundColor(.accentColor)
                .scaleEffect(isAnimating ? 1.1 : 1.0)
        }
        .padding(.top, 20)
    }

    private var deviceIconName: String {
        switch pairingRequest.deviceInfo.platformType {
        case "Android":
            return "iphone"
        case "Mac":
            return "laptopcomputer"
        default:
            return "desktopcomputer"
        }
    }

    private var deviceInfoView: some View {
        VStack(spacing: 16) {
            Text("设备请求配对")
                .font(.title3)
                .fontWeight(.semibold)

            VStack(spacing: 12) {
                InfoRow(
                    icon: "smartphone",
                    label: "设备名称",
                    value: pairingRequest.deviceInfo.name
                )

                InfoRow(
                    icon: "info.circle",
                    label: "设备型号",
                    value: pairingRequest.deviceInfo.model
                )

                InfoRow(
                    icon: "gear",
                    label: "平台类型",
                    value: pairingRequest.deviceInfo.platformType
                )

                InfoRow(
                    icon: "number",
                    label: "设备ID",
                    value: String(pairingRequest.deviceInfo.id.suffix(8))
                )
            }
        }
        .padding()
        .background(Color(NSColor.controlBackgroundColor))
        .cornerRadius(12)
        .padding(.horizontal, 20)
    }

    private var confirmationCodeView: some View {
        VStack(spacing: 16) {
            Text("确认配对")
                .font(.title3)
                .fontWeight(.semibold)

            Text("请在另一台设备上输入以下确认码")
                .font(.body)
                .multilineTextAlignment(.center)
                .foregroundColor(.secondary)

            HStack(spacing: 12) {
                ForEach(Array(confirmationCode.enumerated()), id: \.offset) { index, digit in
                    ConfirmationDigitView(
                        digit: String(digit),
                        index: index
                    )
                }
            }
        }
        .padding()
        .background(Color.accentColor.opacity(0.1))
        .cornerRadius(12)
        .padding(.horizontal, 20)
    }

    private var securityWarningView: some View {
        HStack(spacing: 16) {
            Image(systemName: "exclamationmark.triangle.fill")
                .foregroundColor(.orange)
                .font(.title2)

            VStack(alignment: .leading, spacing: 4) {
                Text("安全提示")
                    .font(.subheadline)
                    .fontWeight(.semibold)

                Text("请确认这是您信任的设备。配对后将允许访问您的剪贴板内容。")
                    .font(.caption)
                    .foregroundColor(.secondary)
            }

            Spacer()
        }
        .padding()
        .background(Color.orange.opacity(0.1))
        .cornerRadius(8)
        .padding(.horizontal, 20)
    }

    private var actionButtonsView: some View {
        HStack(spacing: 16) {
            Button("拒绝") {
                onReject()
            }
            .buttonStyle(.bordered)
            .controlSize(.large)

            Button("接受") {
                onAccept()
            }
            .buttonStyle(.borderedProminent)
            .controlSize(.large)
        }
        .padding(.horizontal, 20)
        .padding(.bottom, 20)
    }
}

struct InfoRow: View {
    let icon: String
    let label: String
    let value: String

    var body: some View {
        HStack(spacing: 12) {
            Image(systemName: icon)
                .foregroundColor(.accentColor)
                .frame(width: 20)

            Text(label)
                .font(.subheadline)
                .foregroundColor(.secondary)
                .frame(width: 80, alignment: .leading)

            Text(value)
                .font(.body)
                .fontWeight(.medium)

            Spacer()
        }
    }
}

struct ConfirmationDigitView: View {
    let digit: String
    let index: Int
    @State private var isVisible = false

    var body: some View {
        Text(digit)
            .font(.system(size: 32, weight: .bold, design: .rounded))
            .foregroundColor(.accentColor)
            .frame(width: 50, height: 60)
            .background(Color.white)
            .cornerRadius(8)
            .shadow(radius: 2)
            .opacity(isVisible ? 1.0 : 0.3)
            .scaleEffect(isVisible ? 1.0 : 0.8)
            .onAppear {
                withAnimation(.spring(response: 0.5, dampingFraction: 0.6).delay(Double(index) * 0.1)) {
                    isVisible = true
                }
            }
    }
}

#Preview {
    PairingConfirmationView(
        pairingRequest: PairingRequest.preview,
        confirmationCode: "123456",
        onAccept: {},
        onReject: {}
    )
}

// Preview Data
extension PairingRequest {
    static var preview: PairingRequest {
        PairingRequest(
            id: "pairing-123",
            deviceInfo: DeviceInfo(
                id: "android-device-123",
                name: "我的手机",
                model: "Pixel 6",
                platformType: "Android",
                certificate: Data()
            ),
            timestamp: Date()
        )
    }
}
```

### 安全凭证存储管理

#### Android SecureStorage
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/security/SecureStorage.kt
package com.nearclip.security

import android.content.Context
import android.content.SharedPreferences
import android.security.keystore.KeyGenParameterSpec
import android.security.keystore.KeyProperties
import androidx.security.crypto.EncryptedSharedPreferences
import androidx.security.crypto.MasterKey
import java.security.KeyStore
import javax.crypto.KeyGenerator
import javax.crypto.SecretKey
import javax.inject.Inject
import javax.inject.Singleton

@Singleton
class SecureStorage @Inject constructor(
    private val context: Context
) {
    private val sharedPreferences: SharedPreferences by lazy {
        createEncryptedSharedPreferences()
    }

    companion object {
        private const val PREFS_NAME = "nearclip_secure_prefs"
        private const val ANDROID_KEYSTORE = "AndroidKeyStore"
        private const val KEY_ALIAS = "nearclip_master_key"
    }

    // 存储设备配对凭证
    fun storePairedDevice(deviceId: String, credentials: DeviceCredentials) {
        val json = Json.encodeToString(credentials)
        sharedPreferences.edit()
            .putString("paired_device_$deviceId", json)
            .apply()
    }

    // 获取设备配对凭证
    fun getPairedDevice(deviceId: String): DeviceCredentials? {
        val json = sharedPreferences.getString("paired_device_$deviceId", null)
        return json?.let { Json.decodeFromString<DeviceCredentials>(it) }
    }

    // 获取所有已配对设备
    fun getAllPairedDevices(): Map<String, DeviceCredentials> {
        val devices = mutableMapOf<String, DeviceCredentials>()
        val allPrefs = sharedPreferences.all

        for ((key, value) in allPrefs) {
            if (key.startsWith("paired_device_") && value is String) {
                val deviceId = key.removePrefix("paired_device_")
                try {
                    val credentials = Json.decodeFromString<DeviceCredentials>(value)
                    devices[deviceId] = credentials
                } catch (e: Exception) {
                    // 忽略损坏的数据
                }
            }
        }

        return devices
    }

    // 移除已配对设备
    fun removePairedDevice(deviceId: String) {
        sharedPreferences.edit()
            .remove("paired_device_$deviceId")
            .apply()
    }

    // 存储会话密钥
    fun storeSessionKey(deviceId: String, sessionKey: ByteArray) {
        val encodedKey = android.util.Base64.encodeToString(sessionKey, android.util.Base64.NO_WRAP)
        sharedPreferences.edit()
            .putString("session_key_$deviceId", encodedKey)
            .apply()
    }

    // 获取会话密钥
    fun getSessionKey(deviceId: String): ByteArray? {
        val encodedKey = sharedPreferences.getString("session_key_$deviceId", null)
        return encodedKey?.let {
            android.util.Base64.decode(it, android.util.Base64.NO_WRAP)
        }
    }

    // 存储设备证书
    fun storeDeviceCertificate(deviceId: String, certificate: ByteArray) {
        val encodedCert = android.util.Base64.encodeToString(certificate, android.util.Base64.NO_WRAP)
        sharedPreferences.edit()
            .putString("certificate_$deviceId", encodedCert)
            .apply()
    }

    // 获取设备证书
    fun getDeviceCertificate(deviceId: String): ByteArray? {
        val encodedCert = sharedPreferences.getString("certificate_$deviceId", null)
        return encodedCert?.let {
            android.util.Base64.decode(it, android.util.Base64.NO_WRAP)
        }
    }

    // 清空所有存储
    fun clearAll() {
        sharedPreferences.edit().clear().apply()
    }

    private fun createEncryptedSharedPreferences(): SharedPreferences {
        val masterKey = MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .setKeyGenParameterSpec(
                KeyGenParameterSpec.Builder(
                    KEY_ALIAS,
                    KeyProperties.PURPOSE_ENCRYPT or KeyProperties.PURPOSE_DECRYPT
                )
                .setBlockModes(KeyProperties.BLOCK_MODE_GCM)
                .setEncryptionPaddings(KeyProperties.ENCRYPTION_PADDING_NONE)
                .setKeySize(256)
                .build()
            )
            .build()

        return EncryptedSharedPreferences.create(
            context,
            PREFS_NAME,
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }
}

// 数据类定义
data class DeviceCredentials(
    val deviceId: String,
    val deviceName: String,
    val certificate: String,
    val publicKey: String,
    val pairedAt: Long,
    val lastUsedAt: Long
)
```

#### Mac KeychainStorage
```swift
// src/platform/mac/NearClip/Sources/Services/KeychainStorage.swift
import Foundation
import Security

class KeychainStorage {
    static let shared = KeychainStorage()

    private let service = "com.nearclip.keychain"

    private init() {}

    // 存储设备配对凭证
    func storePairedDevice(deviceId: String, credentials: DeviceCredentials) throws {
        let data = try JSONEncoder().encode(credentials)

        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: "paired_device_\(deviceId)",
            kSecValueData as String: data,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]

        // 先删除现有条目
        SecItemDelete(query as CFDictionary)

        // 添加新条目
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw KeychainError.storageError(status)
        }
    }

    // 获取设备配对凭证
    func getPairedDevice(deviceId: String) throws -> DeviceCredentials? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: "paired_device_\(deviceId)",
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess, let data = result as? Data else {
            return nil
        }

        return try JSONDecoder().decode(DeviceCredentials.self, from: data)
    }

    // 获取所有已配对设备
    func getAllPairedDevices() throws -> [String: DeviceCredentials] {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: "paired_device_*",
            kSecReturnAttributes as String: true,
            kSecMatchLimit as String: kSecMatchLimitAll
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess,
              let items = result as? [[String: Any]] else {
            return [:]
        }

        var devices: [String: DeviceCredentials] = [:]

        for item in items {
            guard let account = item[kSecAttrAccount as String] as? String,
                  account.hasPrefix("paired_device_"),
                  let data = item[kSecValueData as String] as? Data else {
                continue
            }

            do {
                let credentials = try JSONDecoder().decode(DeviceCredentials.self, from: data)
                let deviceId = String(account.dropFirst("paired_device_".count))
                devices[deviceId] = credentials
            } catch {
                // 忽略损坏的数据
                continue
            }
        }

        return devices
    }

    // 移除已配对设备
    func removePairedDevice(deviceId: String) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: "paired_device_\(deviceId)"
        ]

        let status = SecItemDelete(query as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.deletionError(status)
        }
    }

    // 存储会话密钥
    func storeSessionKey(deviceId: String, sessionKey: Data) throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: "session_key_\(deviceId)",
            kSecValueData as String: sessionKey,
            kSecAttrAccessible as String: kSecAttrAccessibleWhenUnlockedThisDeviceOnly
        ]

        // 先删除现有条目
        SecItemDelete(query as CFDictionary)

        // 添加新条目
        let status = SecItemAdd(query as CFDictionary, nil)
        guard status == errSecSuccess else {
            throw KeychainError.storageError(status)
        }
    }

    // 获取会话密钥
    func getSessionKey(deviceId: String) throws -> Data? {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service,
            kSecAttrAccount as String: "session_key_\(deviceId)",
            kSecReturnData as String: true,
            kSecMatchLimit as String: kSecMatchLimitOne
        ]

        var result: AnyObject?
        let status = SecItemCopyMatching(query as CFDictionary, &result)

        guard status == errSecSuccess, let data = result as? Data else {
            return nil
        }

        return data
    }

    // 清空所有存储
    func clearAll() throws {
        let query: [String: Any] = [
            kSecClass as String: kSecClassGenericPassword,
            kSecAttrService as String: service
        ]

        let status = SecItemDelete(query as CFDictionary)
        guard status == errSecSuccess || status == errSecItemNotFound else {
            throw KeychainError.deletionError(status)
        }
    }
}

enum KeychainError: Error {
    case storageError(OSStatus)
    case retrievalError(OSStatus)
    case deletionError(OSStatus)
    case encodingError(Error)
    case decodingError(Error)
}

// 数据结构定义
struct DeviceCredentials: Codable {
    let deviceId: String
    let deviceName: String
    let certificate: Data
    let publicKey: Data
    let pairedAt: Date
    let lastUsedAt: Date
}
```

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-17 | 1.0 | 初始故事创建，添加设备授权配对机制 | Sarah (PO) |

## Dev Agent Record

### Agent Model Used
待开发代理填写

### Debug Log References
待开发代理填写

### Completion Notes List
待开发代理填写

### File List
待开发代理填写

## QA Results
待 QA 代理填写