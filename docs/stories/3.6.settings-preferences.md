# 故事 3.6: 设置与偏好

## 基本信息
- **故事编号**: 3.6
- **Epic**: Epic 3 - 跨设备粘贴板同步
- **故事名称**: 设置与偏好
- **优先级**: 中
- **预计工期**: 3 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 能够自定义应用的各种设置和偏好选项，
**以便** 我能够根据个人使用习惯调整应用行为，优化使用体验并保护隐私。

## 验收标准

### AC 1: 基础设置管理
- **设置分类**: 提供分类清晰的设置界面（常规、同步、隐私、通知等）
- **实时保存**: 设置更改后立即保存，无需手动确认
- **设置导入导出**: 支持设置的导入导出功能，便于设备间同步
- **重置功能**: 提供重置到默认设置的选项
- **设置搜索**: 支持设置项的搜索功能，快速定位特定设置

### AC 2: 同步与传输设置
- **设备管理**: 管理已配对设备列表，支持设备重命名和删除
- **自动同步**: 配置自动同步的行为规则（内容类型、大小限制等）
- **传输优化**: 调整传输参数（压缩级别、分片大小、重试次数等）
- **网络偏好**: 设置网络使用偏好（WiFi优先、流量控制等）
- **质量平衡**: 在速度和质量之间找到平衡的设置选项

### AC 3: 隐私与安全设置
- **内容过滤**: 配置敏感内容过滤规则和自定义关键词
- **访问控制**: 设置历史记录和粘贴板的访问权限
- **加密选项**: 配置加密强度和密钥管理选项
- **审计设置**: 启用或禁用操作审计日志记录
- **自动清理**: 设置敏感内容的自动清理策略

### AC 4: 通知与界面设置
- **通知控制**: 详细的通知设置（类型、频率、样式等）
- **界面主题**: 支持浅色、深色和系统跟随主题
- **快捷键**: 自定义快捷键和手势操作
- **语言设置**: 支持多语言界面切换
- **显示选项**: 调整界面元素的显示和隐藏

### AC 5: 高级与调试设置
- **调试模式**: 开发者和高级用户的调试选项
- **日志设置**: 配置日志级别和存储位置
- **性能监控**: 启用性能监控和统计功能
- **实验功能**: 开启或关闭实验性功能
- **系统信息**: 显示应用和系统相关信息

## 技术实现要点

### 1. Rust设置引擎
```rust
// src/shared/rust/src/settings/mod.rs
pub mod manager;
pub mod storage;
pub mod validator;
pub mod defaults;
pub mod sync;

pub use manager::SettingsManager;
pub use storage::SettingsStorage;
pub use validator::SettingsValidator;
pub use defaults::DefaultSettings;
pub use sync::SettingsSync;
```

### 2. 设置管理器
```rust
// src/shared/rust/src/settings/manager.rs
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppSettings {
    pub general: GeneralSettings,
    pub sync: SyncSettings,
    pub privacy: PrivacySettings,
    pub notifications: NotificationSettings,
    pub ui: UISettings,
    pub advanced: AdvancedSettings,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct GeneralSettings {
    pub auto_start: bool,
    pub language: String,
    pub theme: Theme,
    pub check_updates: bool,
    pub telemetry_enabled: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncSettings {
    pub auto_sync: bool,
    pub sync_content_types: Vec<ContentType>,
    pub max_file_size: usize, // bytes
    pub compression_level: u8, // 0-9
    pub sync_over_wifi_only: bool,
    pub device_trust_level: TrustLevel,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PrivacySettings {
    pub content_filtering: bool,
    pub sensitive_keywords: Vec<String>,
    pub history_retention_days: u32,
    pub encrypt_history: bool,
    pub audit_logging: bool,
    pub auto_cleanup_sensitive: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NotificationSettings {
    pub enabled: bool,
    pub show_content_preview: bool,
    pub sound_enabled: bool,
    pub vibration_enabled: bool, // Android only
    pub do_not_disturb: DoNotDisturbSettings,
    pub notification_types: NotificationTypes,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UISettings {
    pub theme: Theme,
    pub font_size: FontSize,
    pub show_status_bar: bool,
    pub minimize_to_tray: bool, // Desktop only
    pub compact_mode: bool,
    pub custom_shortcuts: HashMap<String, String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AdvancedSettings {
    pub debug_mode: bool,
    pub log_level: LogLevel,
    pub performance_monitoring: bool,
    pub experimental_features: HashMap<String, bool>,
    pub network_timeout: u64, // seconds
    pub max_concurrent_transfers: u8,
}

pub struct SettingsManager {
    storage: SettingsStorage,
    validator: SettingsValidator,
    defaults: DefaultSettings,
    sync: SettingsSync,
    change_listeners: Vec<Box<dyn SettingsChangeListener>>,
}

impl SettingsManager {
    pub async fn new() -> Result<Self, SettingsError> {
        let storage = SettingsStorage::new().await?;
        let validator = SettingsValidator::new();
        let defaults = DefaultSettings::new();
        let sync = SettingsSync::new();

        Ok(Self {
            storage,
            validator,
            defaults,
            sync,
            change_listeners: Vec::new(),
        })
    }

    pub async fn load_settings(&self) -> Result<AppSettings, SettingsError> {
        // 尝试从存储加载设置
        match self.storage.load_settings().await {
            Ok(mut settings) => {
                // 验证设置完整性
                self.validator.validate_and_fix(&mut settings).await?;
                Ok(settings)
            },
            Err(_) => {
                // 如果加载失败，返回默认设置
                Ok(self.defaults.get_default_settings())
            }
        }
    }

    pub async fn save_settings(&mut self, settings: AppSettings) -> Result<(), SettingsError> {
        // 1. 验证设置
        self.validator.validate(&settings).await?;

        // 2. 应用更改
        self.storage.save_settings(&settings).await?;

        // 3. 通知监听器
        self.notify_change_listeners(&settings).await;

        // 4. 同步到其他设备（如果启用）
        if settings.sync.auto_sync {
            self.sync.sync_settings(settings).await?;
        }

        Ok(())
    }

    pub async fn update_setting<T, F>(&mut self, update_fn: F) -> Result<(), SettingsError>
    where
        T: Clone + Send + Sync + 'static,
        F: FnOnce(&mut AppSettings) -> &mut T + Send,
    {
        let mut settings = self.load_settings().await?;
        let setting_field = update_fn(&mut settings);
        let old_value = setting_field.clone();

        // 通知监听器设置即将更改
        self.notify_before_change_listeners(&settings, &old_value).await;

        // 保存新设置
        self.save_settings(settings).await?;

        Ok(())
    }

    pub async fn reset_to_defaults(&mut self, category: Option<SettingsCategory>) -> Result<(), SettingsError> {
        let mut settings = self.load_settings().await?;

        match category {
            Some(SettingsCategory::General) => {
                settings.general = self.defaults.get_default_general_settings();
            },
            Some(SettingsCategory::Sync) => {
                settings.sync = self.defaults.get_default_sync_settings();
            },
            Some(SettingsCategory::Privacy) => {
                settings.privacy = self.defaults.get_default_privacy_settings();
            },
            Some(SettingsCategory::Notifications) => {
                settings.notifications = self.defaults.get_default_notification_settings();
            },
            Some(SettingsCategory::UI) => {
                settings.ui = self.defaults.get_default_ui_settings();
            },
            Some(SettingsCategory::Advanced) => {
                settings.advanced = self.defaults.get_default_advanced_settings();
            },
            None => {
                settings = self.defaults.get_default_settings();
            }
        }

        self.save_settings(settings).await
    }

    pub async fn export_settings(&self) -> Result<String, SettingsError> {
        let settings = self.load_settings().await?;
        let json = serde_json::to_string_pretty(&settings)?;
        Ok(json)
    }

    pub async fn import_settings(&mut self, json: &str) -> Result<(), SettingsError> {
        let settings: AppSettings = serde_json::from_str(json)?;
        self.save_settings(settings).await
    }

    pub fn add_change_listener(&mut self, listener: Box<dyn SettingsChangeListener>) {
        self.change_listeners.push(listener);
    }

    async fn notify_change_listeners(&self, settings: &AppSettings) {
        for listener in &self.change_listeners {
            listener.on_settings_changed(settings).await;
        }
    }

    async fn notify_before_change_listeners(&self, settings: &AppSettings, old_value: &dyn std::any::Any) {
        for listener in &self.change_listeners {
            listener.on_settings_changing(settings, old_value).await;
        }
    }
}

#[async_trait]
pub trait SettingsChangeListener: Send + Sync {
    async fn on_settings_changed(&self, settings: &AppSettings);
    async fn on_settings_changing(&self, settings: &AppSettings, old_value: &dyn std::any::Any);
}
```

### 3. 设置验证器
```rust
// src/shared/rust/src/settings/validator.rs
pub struct SettingsValidator {
    validation_rules: HashMap<String, ValidationRule>,
}

impl SettingsValidator {
    pub fn new() -> Self {
        let mut validation_rules = HashMap::new();

        // 添加验证规则
        validation_rules.insert("sync.max_file_size".to_string(), ValidationRule::Range {
            min: 1024,      // 1KB
            max: 1073741824, // 1GB
        });

        validation_rules.insert("sync.compression_level".to_string(), ValidationRule::Range {
            min: 0,
            max: 9,
        });

        validation_rules.insert("privacy.history_retention_days".to_string(), ValidationRule::Range {
            min: 1,
            max: 365,
        });

        validation_rules.insert("advanced.max_concurrent_transfers".to_string(), ValidationRule::Range {
            min: 1,
            max: 10,
        });

        Self {
            validation_rules,
        }
    }

    pub async fn validate(&self, settings: &AppSettings) -> Result<(), ValidationError> {
        // 验证常规设置
        self.validate_general_settings(&settings.general)?;

        // 验证同步设置
        self.validate_sync_settings(&settings.sync)?;

        // 验证隐私设置
        self.validate_privacy_settings(&settings.privacy)?;

        // 验证通知设置
        self.validate_notification_settings(&settings.notifications)?;

        // 验证UI设置
        self.validate_ui_settings(&settings.ui)?;

        // 验证高级设置
        self.validate_advanced_settings(&settings.advanced)?;

        Ok(())
    }

    pub async fn validate_and_fix(&self, settings: &mut AppSettings) -> Result<(), ValidationError> {
        // 验证并修复常规设置
        self.fix_general_settings(&mut settings.general);

        // 验证并修复同步设置
        self.fix_sync_settings(&mut settings.sync);

        // 验证并修复隐私设置
        self.fix_privacy_settings(&mut settings.privacy);

        // 验证并修复通知设置
        self.fix_notification_settings(&mut settings.notifications);

        // 验证并修复UI设置
        self.fix_ui_settings(&mut settings.ui);

        // 验证并修复高级设置
        self.fix_advanced_settings(&mut settings.advanced);

        Ok(())
    }

    fn validate_sync_settings(&self, settings: &SyncSettings) -> Result<(), ValidationError> {
        if settings.max_file_size < 1024 {
            return Err(ValidationError::InvalidValue("max_file_size too small".to_string()));
        }

        if settings.max_file_size > 1073741824 {
            return Err(ValidationError::InvalidValue("max_file_size too large".to_string()));
        }

        if settings.compression_level > 9 {
            return Err(ValidationError::InvalidValue("compression_level out of range".to_string()));
        }

        Ok(())
    }

    fn fix_sync_settings(&self, settings: &mut SyncSettings) {
        if settings.max_file_size < 1024 {
            settings.max_file_size = 1024;
        } else if settings.max_file_size > 1073741824 {
            settings.max_file_size = 1073741824;
        }

        if settings.compression_level > 9 {
            settings.compression_level = 6; // 默认压缩级别
        }
    }

    fn validate_privacy_settings(&self, settings: &PrivacySettings) -> Result<(), ValidationError> {
        if settings.history_retention_days == 0 {
            return Err(ValidationError::InvalidValue("history_retention_days cannot be zero".to_string()));
        }

        if settings.history_retention_days > 365 {
            return Err(ValidationError::InvalidValue("history_retention_days exceeds maximum".to_string()));
        }

        Ok(())
    }

    fn fix_privacy_settings(&self, settings: &mut PrivacySettings) {
        if settings.history_retention_days == 0 {
            settings.history_retention_days = 30; // 默认30天
        } else if settings.history_retention_days > 365 {
            settings.history_retention_days = 365;
        }
    }
}

#[derive(Debug)]
pub enum ValidationError {
    InvalidValue(String),
    MissingField(String),
    IncompatibleSettings(String),
}

pub enum ValidationRule {
    Range { min: u64, max: u64 },
    NotEmpty,
    EmailFormat,
    UrlFormat,
    Custom(Box<dyn Fn(&str) -> bool + Send + Sync>),
}
```

### 4. 设置存储
```rust
// src/shared/rust/src/settings/storage.rs
pub struct SettingsStorage {
    config_path: PathBuf,
    backup_path: PathBuf,
}

impl SettingsStorage {
    pub async fn new() -> Result<Self, StorageError> {
        let config_dir = get_config_directory()?;
        let config_path = config_dir.join("settings.json");
        let backup_path = config_dir.join("settings.backup.json");

        // 确保目录存在
        tokio::fs::create_dir_all(&config_dir).await?;

        Ok(Self {
            config_path,
            backup_path,
        })
    }

    pub async fn load_settings(&self) -> Result<AppSettings, StorageError> {
        let content = tokio::fs::read_to_string(&self.config_path).await?;
        let settings: AppSettings = serde_json::from_str(&content)?;
        Ok(settings)
    }

    pub async fn save_settings(&self, settings: &AppSettings) -> Result<(), StorageError> {
        // 创建备份
        self.create_backup().await?;

        // 保存新设置
        let json = serde_json::to_string_pretty(settings)?;
        tokio::fs::write(&self.config_path, json).await?;

        Ok(())
    }

    async fn create_backup(&self) -> Result<(), StorageError> {
        if self.config_path.exists() {
            tokio::fs::copy(&self.config_path, &self.backup_path).await?;
        }
        Ok(())
    }

    pub async fn restore_from_backup(&self) -> Result<AppSettings, StorageError> {
        if !self.backup_path.exists() {
            return Err(StorageError::BackupNotFound);
        }

        let content = tokio::fs::read_to_string(&self.backup_path).await?;
        let settings: AppSettings = serde_json::from_str(&content)?;
        Ok(settings)
    }

    pub async fn export_settings(&self, path: &Path) -> Result<(), StorageError> {
        let settings = self.load_settings().await?;
        let json = serde_json::to_string_pretty(&settings)?;
        tokio::fs::write(path, json).await?;
        Ok(())
    }

    pub async fn import_settings(&self, path: &Path) -> Result<AppSettings, StorageError> {
        let content = tokio::fs::read_to_string(path).await?;
        let settings: AppSettings = serde_json::from_str(&content)?;
        Ok(settings)
    }
}

fn get_config_directory() -> Result<PathBuf, StorageError> {
    let mut path = dirs::config_dir().ok_or(StorageError::ConfigDirNotFound)?;
    path.push("nearclip");
    Ok(path)
}
```

### 5. Android平台实现
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/settings/SettingsManager.kt
class SettingsManagerImpl(
    private val context: Context,
    private val rustBridge: RustNativeBridge
) : SettingsManager {

    private val sharedPrefs = context.getSharedPreferences("nearclip_settings", Context.MODE_PRIVATE)
    private val gson = Gson()

    override suspend fun loadSettings(): AppSettings {
        // 尝试从SharedPreferences加载
        val settingsJson = sharedPrefs.getString("app_settings", null)

        return if (settingsJson != null) {
            try {
                gson.fromJson(settingsJson, AppSettings::class.java)
            } catch (e: Exception) {
                Log.e("SettingsManager", "Failed to load settings, using defaults", e)
                createDefaultSettings()
            }
        } else {
            createDefaultSettings()
        }
    }

    override suspend fun saveSettings(settings: AppSettings) {
        // 保存到SharedPreferences
        val settingsJson = gson.toJson(settings)
        sharedPrefs.edit()
            .putString("app_settings", settingsJson)
            .apply()

        // 调用Rust保存设置
        rustBridge.saveSettings(
            generalJson = gson.toJson(settings.general),
            syncJson = gson.toJson(settings.sync),
            privacyJson = gson.toJson(settings.privacy),
            notificationsJson = gson.toJson(settings.notifications),
            uiJson = gson.toJson(settings.ui),
            advancedJson = gson.toJson(settings.advanced)
        )

        // 通知系统设置更改
        notifySettingsChanged(settings)
    }

    override suspend fun updateSetting(updateBlock: (AppSettings) -> Unit): AppSettings {
        var settings = loadSettings()
        updateBlock(settings)
        saveSettings(settings)
        return settings
    }

    override suspend fun resetToDefaults(category: SettingsCategory?) {
        val defaultSettings = createDefaultSettings()
        val currentSettings = loadSettings()

        val newSettings = when (category) {
            SettingsCategory.GENERAL -> currentSettings.copy(general = defaultSettings.general)
            SettingsCategory.SYNC -> currentSettings.copy(sync = defaultSettings.sync)
            SettingsCategory.PRIVACY -> currentSettings.copy(privacy = defaultSettings.privacy)
            SettingsCategory.NOTIFICATIONS -> currentSettings.copy(notifications = defaultSettings.notifications)
            SettingsCategory.UI -> currentSettings.copy(ui = defaultSettings.ui)
            SettingsCategory.ADVANCED -> currentSettings.copy(advanced = defaultSettings.advanced)
            null -> defaultSettings
        }

        saveSettings(newSettings)
    }

    override suspend fun exportSettings(): String {
        val settings = loadSettings()
        return gson.toJson(settings)
    }

    override suspend fun importSettings(json: String) {
        try {
            val settings: AppSettings = gson.fromJson(json, AppSettings::class.java)
            saveSettings(settings)
        } catch (e: Exception) {
            throw SettingsImportException("Failed to import settings: ${e.message}", e)
        }
    }

    private fun createDefaultSettings(): AppSettings {
        return AppSettings(
            general = GeneralSettings(
                autoStart = true,
                language = Locale.getDefault().language,
                theme = if (isDarkThemeEnabled()) Theme.DARK else Theme.LIGHT,
                checkUpdates = true,
                telemetryEnabled = false
            ),
            sync = SyncSettings(
                autoSync = true,
                syncContentTypes = listOf(ContentType.TEXT, ContentType.IMAGE),
                maxFileSize = 10 * 1024 * 1024, // 10MB
                compressionLevel = 6,
                syncOverWifiOnly = false,
                deviceTrustLevel = TrustLevel.TRUSTED
            ),
            privacy = PrivacySettings(
                contentFiltering = true,
                sensitiveKeywords = listOf("password", "token", "secret", "key"),
                historyRetentionDays = 30,
                encryptHistory = true,
                auditLogging = false,
                autoCleanupSensitive = true
            ),
            notifications = NotificationSettings(
                enabled = true,
                showContentPreview = true,
                soundEnabled = true,
                vibrationEnabled = true,
                doNotDisturb = DoNotDisturbSettings(
                    enabled = false,
                    startTime = "22:00",
                    endTime = "08:00"
                ),
                notificationTypes = NotificationTypes(
                    newContent = true,
                    transferComplete = true,
                    errors = true,
                    deviceConnected = false
                )
            ),
            ui = UISettings(
                theme = if (isDarkThemeEnabled()) Theme.DARK else Theme.LIGHT,
                fontSize = FontSize.MEDIUM,
                showStatusBar = true,
                compactMode = false,
                customShortcuts = mutableMapOf()
            ),
            advanced = AdvancedSettings(
                debugMode = false,
                logLevel = LogLevel.INFO,
                performanceMonitoring = false,
                experimentalFeatures = mutableMapOf(),
                networkTimeout = 30,
                maxConcurrentTransfers = 3
            )
        )
    }

    private fun isDarkThemeEnabled(): Boolean {
        return when (context.resources.configuration.uiMode and Configuration.UI_MODE_NIGHT_MASK) {
            Configuration.UI_MODE_NIGHT_YES -> true
            else -> false
        }
    }

    private fun notifySettingsChanged(settings: AppSettings) {
        // 发送广播通知其他组件设置已更改
        val intent = Intent(ACTION_SETTINGS_CHANGED)
        context.sendBroadcast(intent)

        // 更新LiveData
        (context as? LifecycleOwner)?.lifecycleScope?.launch {
            // 更新UI相关的设置
            when (settings.ui.theme) {
                Theme.DARK -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_YES)
                Theme.LIGHT -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_NO)
                Theme.SYSTEM -> AppCompatDelegate.setDefaultNightMode(AppCompatDelegate.MODE_NIGHT_FOLLOW_SYSTEM)
            }
        }
    }
}
```

### 6. macOS平台实现
```swift
// src/platform/mac/NearClip/Settings/SettingsManager.swift
class SettingsManagerImpl: SettingsManager {
    private let userDefaults = UserDefaults.standard
    private let rustBridge: RustNativeBridge
    private let encoder = JSONEncoder()
    private let decoder = JSONDecoder()

    init(rustBridge: RustNativeBridge) {
        self.rustBridge = rustBridge
        setupEncoder()
    }

    func loadSettings() async throws -> AppSettings {
        // 尝试从UserDefaults加载
        if let data = userDefaults.data(forKey: "app_settings"),
           let settings = try? decoder.decode(AppSettings.self, from: data) {
            return settings
        }

        // 如果没有保存的设置，返回默认设置
        return createDefaultSettings()
    }

    func saveSettings(_ settings: AppSettings) async throws {
        // 保存到UserDefaults
        let data = try encoder.encode(settings)
        userDefaults.set(data, forKey: "app_settings")

        // 调用Rust保存设置
        let generalJson = try JSONEncoder().encode(settings.general)
        let syncJson = try JSONEncoder().encode(settings.sync)
        let privacyJson = try JSONEncoder().encode(settings.privacy)
        let notificationsJson = try JSONEncoder().encode(settings.notifications)
        let uiJson = try JSONEncoder().encode(settings.ui)
        let advancedJson = try JSONEncoder().encode(settings.advanced)

        try await rustBridge.saveSettings(
            generalJson: String(data: generalJson, encoding: .utf8) ?? "",
            syncJson: String(data: syncJson, encoding: .utf8) ?? "",
            privacyJson: String(data: privacyJson, encoding: .utf8) ?? "",
            notificationsJson: String(data: notificationsJson, encoding: .utf8) ?? "",
            uiJson: String(data: uiJson, encoding: .utf8) ?? "",
            advancedJson: String(data: advancedJson, encoding: .utf8) ?? ""
        )

        // 通知设置更改
        await notifySettingsChanged(settings)
    }

    func updateSetting<T>(_ updateBlock: @escaping (inout AppSettings) -> T) async throws -> T {
        var settings = try await loadSettings()
        let result = updateBlock(&settings)
        try await saveSettings(settings)
        return result
    }

    func resetToDefaults(category: SettingsCategory?) async throws {
        let defaultSettings = createDefaultSettings()
        let currentSettings = try await loadSettings()

        let newSettings: AppSettings
        switch category {
        case .general:
            newSettings = currentSettings.with(general: defaultSettings.general)
        case .sync:
            newSettings = currentSettings.with(sync: defaultSettings.sync)
        case .privacy:
            newSettings = currentSettings.with(privacy: defaultSettings.privacy)
        case .notifications:
            newSettings = currentSettings.with(notifications: defaultSettings.notifications)
        case .ui:
            newSettings = currentSettings.with(ui: defaultSettings.ui)
        case .advanced:
            newSettings = currentSettings.with(advanced: defaultSettings.advanced)
        case .none:
            newSettings = defaultSettings
        }

        try await saveSettings(newSettings)
    }

    func exportSettings() async throws -> String {
        let settings = try await loadSettings()
        let data = try encoder.encode(settings)
        return String(data: data, encoding: .utf8) ?? "{}"
    }

    func importSettings(_ json: String) async throws {
        guard let data = json.data(using: .utf8) else {
            throw SettingsError.invalidJson
        }

        let settings = try decoder.decode(AppSettings.self, from: data)
        try await saveSettings(settings)
    }

    private func setupEncoder() {
        encoder.dateEncodingStrategy = .iso8601
        encoder.outputFormatting = .prettyPrinted
    }

    private func createDefaultSettings() -> AppSettings {
        let appearance = NSApp.effectiveAppearance
        let isDark = appearance.bestMatch(from: [.darkAqua, .aqua]) == .darkAqua

        return AppSettings(
            general: GeneralSettings(
                autoStart: true,
                language: Locale.current.languageCode ?? "en",
                theme: isDark ? .dark : .light,
                checkUpdates: true,
                telemetryEnabled: false
            ),
            sync: SyncSettings(
                autoSync: true,
                syncContentTypes: [.text, .image],
                maxFileSize: 10 * 1024 * 1024, // 10MB
                compressionLevel: 6,
                syncOverWifiOnly: false,
                deviceTrustLevel: .trusted
            ),
            privacy: PrivacySettings(
                contentFiltering: true,
                sensitiveKeywords: ["password", "token", "secret", "key"],
                historyRetentionDays: 30,
                encryptHistory: true,
                auditLogging: false,
                autoCleanupSensitive: true
            ),
            notifications: NotificationSettings(
                enabled: true,
                showContentPreview: true,
                soundEnabled: true,
                vibrationEnabled: false, // Not applicable on macOS
                doNotDisturb: DoNotDisturbSettings(
                    enabled: false,
                    startTime: "22:00",
                    endTime: "08:00"
                ),
                notificationTypes: NotificationTypes(
                    newContent: true,
                    transferComplete: true,
                    errors: true,
                    deviceConnected: false
                )
            ),
            ui: UISettings(
                theme: isDark ? .dark : .light,
                fontSize: .medium,
                showStatusBar: true,
                minimizeToTray: true,
                compactMode: false,
                customShortcuts: [:]
            ),
            advanced: AdvancedSettings(
                debugMode: false,
                logLevel: .info,
                performanceMonitoring: false,
                experimentalFeatures: [:],
                networkTimeout: 30,
                maxConcurrentTransfers: 3
            )
        )
    }

    private func notifySettingsChanged(_ settings: AppSettings) async {
        await MainActor.run {
            // 发布通知
            NotificationCenter.default.post(
                name: .settingsChanged,
                object: SettingsChangedNotification(settings: settings)
            )

            // 应用UI设置
            applyUISettings(settings.ui)
        }
    }

    private func applyUISettings(_ uiSettings: UISettings) {
        // 应用主题设置
        switch uiSettings.theme {
        case .light:
            NSApp.appearance = NSAppearance(named: .aqua)
        case .dark:
            NSApp.appearance = NSAppearance(named: .darkAqua)
        case .system:
            NSApp.appearance = nil
        }

        // 应用其他UI设置
        // ...
    }
}

// Helper extension for updating specific settings
extension AppSettings {
    func with(general: GeneralSettings) -> AppSettings {
        var copy = self
        copy.general = general
        return copy
    }

    func with(sync: SyncSettings) -> AppSettings {
        var copy = self
        copy.sync = sync
        return copy
    }

    func with(privacy: PrivacySettings) -> AppSettings {
        var copy = self
        copy.privacy = privacy
        return copy
    }

    func with(notifications: NotificationSettings) -> AppSettings {
        var copy = self
        copy.notifications = notifications
        return copy
    }

    func with(ui: UISettings) -> AppSettings {
        var copy = self
        copy.ui = ui
        return copy
    }

    func with(advanced: AdvancedSettings) -> AppSettings {
        var copy = self
        copy.advanced = advanced
        return copy
    }
}
```

## 测试用例

### 单元测试
```rust
// src/shared/rust/src/settings/tests.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_settings_loading() {
        let manager = SettingsManager::new().await.unwrap();
        let settings = manager.load_settings().await.unwrap();

        assert!(settings.general.auto_start);
        assert_eq!(settings.sync.compression_level, 6);
        assert!(settings.privacy.content_filtering);
    }

    #[tokio::test]
    async fn test_settings_saving() {
        let mut manager = SettingsManager::new().await.unwrap();
        let mut settings = manager.load_settings().await.unwrap();

        // 修改设置
        settings.sync.compression_level = 9;
        settings.privacy.history_retention_days = 60;

        // 保存设置
        manager.save_settings(settings.clone()).await.unwrap();

        // 重新加载验证
        let loaded_settings = manager.load_settings().await.unwrap();
        assert_eq!(loaded_settings.sync.compression_level, 9);
        assert_eq!(loaded_settings.privacy.history_retention_days, 60);
    }

    #[tokio::test]
    async fn test_settings_validation() {
        let validator = SettingsValidator::new();
        let mut settings = create_test_settings();

        // 测试有效设置
        assert!(validator.validate(&settings).await.is_ok());

        // 测试无效设置
        settings.sync.max_file_size = 0;
        assert!(validator.validate(&settings).await.is_err());

        // 测试自动修复
        validator.validate_and_fix(&mut settings).await.unwrap();
        assert!(settings.sync.max_file_size > 0);
    }

    #[tokio::test]
    async fn test_settings_import_export() {
        let manager = SettingsManager::new().await.unwrap();
        let settings = create_test_settings();

        // 导出设置
        let json = manager.export_settings().await.unwrap();
        assert!(!json.is_empty());

        // 重新导入设置
        let mut new_manager = SettingsManager::new().await.unwrap();
        new_manager.import_settings(&json).await.unwrap();

        // 验证导入的设置
        let imported_settings = new_manager.load_settings().await.unwrap();
        assert_eq!(imported_settings.sync.compression_level, settings.sync.compression_level);
    }
}
```

### 集成测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/settings/SettingsIntegrationTest.kt
@RunWith(AndroidJUnit4::class)
class SettingsIntegrationTest {

    @Test
    fun testEndToEndSettingsFlow() {
        val context = InstrumentationRegistry.getInstrumentation().targetContext
        val rustBridge = mockRustBridge()
        val settingsManager = SettingsManagerImpl(context, rustBridge)

        // 加载默认设置
        runBlocking {
            val defaultSettings = settingsManager.loadSettings()
            assertThat(defaultSettings.general.autoStart).isTrue()

            // 更新设置
            val updatedSettings = settingsManager.updateSetting { settings ->
                settings.sync.autoSync = false
                settings.privacy.historyRetentionDays = 90
                settings
            }

            assertThat(updatedSettings.sync.autoSync).isFalse()
            assertThat(updatedSettings.privacy.historyRetentionDays).isEqualTo(90)

            // 重置特定类别
            settingsManager.resetToDefaults(SettingsCategory.SYNC)
            val resetSettings = settingsManager.loadSettings()
            assertThat(resetSettings.sync.autoSync).isTrue() // 回到默认值
        }
    }
}
```

### UI测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/settings/SettingsUITest.kt
@RunWith(AndroidJUnit4::class)
@LargeTest
class SettingsUITest {

    @get:Rule
    val activityRule = ActivityScenarioRule(SettingsActivity::class.java)

    @Test
    fun testSettingsUIInteraction() {
        // 测试设置项点击
        onView(withText("同步设置")).perform(click())
        onView(withId(R.id.auto_sync_switch)).check(matches(isDisplayed()))

        // 测试开关切换
        onView(withId(R.id.auto_sync_switch)).perform(click())
        onView(withId(R.id.auto_sync_switch)).check(matches(isNotChecked()))

        // 测试设置保存
        pressBack()
        onView(withText("设置已保存")).check(matches(isDisplayed()))
    }

    @Test
    fun testSettingsSearch() {
        // 测试搜索功能
        onView(withId(R.id.search_view)).perform(typeText("同步"))
        onView(withText("同步设置")).check(matches(isDisplayed()))
        onView(withText("常规设置")).check(matches(not(isDisplayed())))
    }
}
```

## 部署要求

### 环境配置
- Android: API 24+ (Android 7.0+)
- macOS: 10.15+ (Catalina+)
- Rust: 1.70+
- 存储: 最少10MB用于设置存储

### 依赖项
```toml
# Cargo.toml
[dependencies]
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
dirs = "5.0"
thiserror = "1.0"
async-trait = "0.1"
```

```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.preference:preference-ktx:1.2.0"
    implementation "androidx.lifecycle:lifecycle-livedata-ktx:2.7.0"
    implementation "com.google.code.gson:gson:2.10.1"
}
```

## 验收测试计划

### 功能测试
1. **设置加载**: 测试设置的加载和默认值应用
2. **设置保存**: 验证设置更改的保存和持久化
3. **设置验证**: 测试设置验证和自动修复功能
4. **导入导出**: 验证设置的导入导出功能

### UI测试
1. **设置界面**: 测试设置界面的显示和交互
2. **设置搜索**: 验证设置搜索功能的准确性
3. **设置分类**: 测试设置分类的清晰性和易用性
4. **实时预览**: 验证设置更改的实时预览效果

### 性能测试
1. **加载性能**: 测试设置的加载速度
2. **保存性能**: 验证设置保存的响应时间
3. **内存使用**: 监控设置功能的内存占用
4. **存储效率**: 测试设置存储的空间效率

### 安全测试
1. **数据保护**: 验证敏感设置的保护机制
2. **访问控制**: 测试设置的访问权限控制
3. **备份恢复**: 验证设置备份和恢复的安全性
4. **导入安全**: 测试设置导入的安全性验证

## 风险与缓解

### 技术风险
- **设置丢失**: 设置文件损坏或丢失
  - 缓解: 自动备份，云同步，恢复机制
- **设置冲突**: 多设备间设置同步冲突
  - 缓解: 冲突解决策略，时间戳优先，用户选择
- **性能影响**: 复杂设置可能影响应用性能
  - 缓解: 延迟加载，缓存机制，异步处理

### 用户体验风险
- **设置复杂**: 过多的设置选项让用户困惑
  - 缓解: 分类组织，默认设置，智能推荐
- **设置发现**: 用户难以找到需要的设置
  - 缓解: 搜索功能，设置向导，上下文帮助
- **设置重置**: 意外重置设置影响用户体验
  - 缓解: 确认对话框，备份恢复，分步重置

### 安全风险
- **敏感信息**: 设置中可能包含敏感信息
  - 缓解: 加密存储，访问控制，审计日志
- **恶意修改**: 恶意软件可能篡改设置
  - 缓解: 完整性校验，数字签名，安全启动
- **隐私泄露**: 设置可能泄露用户隐私
  - 缓解: 数据最小化，匿名化，用户控制

## 完成标准
- [ ] 所有设置类别功能完整可用
- [ ] 设置验证和自动修复正常工作
- [ ] 设置导入导出功能正确实现
- [ ] Android和macOS平台设置界面友好
- [ ] 设置更改能立即生效并持久化
- [ ] 所有单元测试和集成测试通过
- [ ] UI测试和性能测试通过
- [ ] 安全测试和用户体验测试通过
- [ ] 设置搜索和分类功能易用
- [ ] 错误处理和用户反馈机制完善