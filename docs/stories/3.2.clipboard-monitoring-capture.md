# 故事 3.2: 粘贴板监听与捕获

## 基本信息
- **故事编号**: 3.2
- **Epic**: Epic 3 - 跨设备粘贴板同步
- **故事名称**: 粘贴板监听与捕获
- **优先级**: 高
- **预计工期**: 5 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 系统能够自动监听和捕获本地粘贴板变化，
**以便** 我无需手动操作就能将粘贴板内容同步到其他设备。

## 验收标准

### AC 1: 跨平台粘贴板监听机制
- **描述**: 实现Android和macOS平台的粘贴板变化实时监听
- **平台覆盖**:
  - Android: 监听主粘贴板和次要粘贴板
  - macOS: 监听通用粘贴板和特定应用粘贴板
- **性能要求**: 监听延迟不超过100ms
- **资源控制**: CPU占用不超过5%，内存占用不超过50MB

### AC 2: 多类型内容支持
- **文本内容**: 支持纯文本、富文本(RTF)、HTML格式
- **文件处理**: 支持单个文件和文件列表的拖拽捕获
- **图片支持**: 支持PNG、JPEG、GIF、WebP等主流格式
- **特殊格式**: 支持URL、颜色、联系方式等系统特定格式
- **大小限制**: 单个内容不超过100MB，总传输队列不超过500MB

### AC 3: 智能内容过滤
- **隐私保护**: 自动过滤密码、密钥等敏感信息
- **垃圾过滤**: 过滤无意义的短文本和系统剪贴板垃圾
- **重复检测**: 避免重复传输相同内容
- **格式优先级**: 智能选择最佳传输格式
- **用户白名单**: 支持用户自定义过滤规则

### AC 4: 安全机制集成
- **加密处理**: 所有捕获内容在传输前进行AES-256-GCM加密
- **完整性校验**: 使用SHA-256校验内容完整性
- **访问控制**: 确保只有授权应用能访问粘贴板内容
- **临时存储**: 加密存储到临时目录，传输后自动清理
- **审计日志**: 记录所有粘贴板访问操作

### AC 5: 性能优化机制
- **延迟处理**: 避免频繁的小内容传输，支持智能延迟合并
- **压缩优化**: 对大文件进行智能压缩，减少传输时间
- **队列管理**: 实现高效的传输队列，支持优先级处理
- **网络适应**: 根据网络状况调整传输策略
- **缓存机制**: 智能缓存频繁访问的内容

## 技术实现要点

### 1. Rust核心监听引擎
```rust
// src/shared/rust/src/clipboard/mod.rs
pub mod monitor;
pub mod capture;
pub mod filter;
pub mod queue;

pub use monitor::ClipboardMonitor;
pub use capture::ContentCapture;
pub use filter::ContentFilter;
pub use queue::TransferQueue;
```

### 2. 粘贴板监听器
```rust
// src/shared/rust/src/clipboard/monitor.rs
use std::sync::{Arc, Mutex};
use std::time::{Duration, Instant};
use tokio::sync::mpsc;

pub struct ClipboardMonitor {
    last_content: Arc<Mutex<Option<ClipboardContent>>>,
    filter: ContentFilter,
    sender: mpsc::UnboundedSender<ClipboardEvent>,
}

impl ClipboardMonitor {
    pub async fn start_monitoring(&self) -> Result<(), ClipboardError> {
        let mut interval = tokio::time::interval(Duration::from_millis(100));

        loop {
            interval.tick().await;
            if let Some(content) = self.check_clipboard_change().await? {
                if self.filter.should_process(&content) {
                    let event = ClipboardEvent::NewContent(content);
                    let _ = self.sender.send(event);
                }
            }
        }
    }

    async fn check_clipboard_change(&self) -> Result<Option<ClipboardContent>, ClipboardError> {
        // 平台特定的粘贴板检查逻辑
        #[cfg(target_os = "android")]
        return self.check_android_clipboard().await;

        #[cfg(target_os = "macos")]
        return self.check_macos_clipboard().await;
    }
}
```

### 3. 内容捕获引擎
```rust
// src/shared/rust/src/clipboard/capture.rs
pub struct ContentCapture {
    max_size: usize,
    supported_formats: Vec<ContentType>,
    compression_enabled: bool,
}

impl ContentCapture {
    pub async fn capture_content(&self, raw_data: &[u8]) -> Result<ClipboardContent, CaptureError> {
        // 1. 检测内容类型
        let content_type = self.detect_content_type(raw_data)?;

        // 2. 验证大小限制
        if raw_data.len() > self.max_size {
            return Err(CaptureError::SizeExceeded);
        }

        // 3. 处理特定格式
        let processed_data = self.process_content(raw_data, &content_type).await?;

        // 4. 生成元数据
        let metadata = self.generate_metadata(&processed_data, &content_type);

        Ok(ClipboardContent {
            id: generate_uuid(),
            content_type,
            data: processed_data,
            metadata,
            timestamp: Utc::now(),
        })
    }

    async fn process_content(&self, data: &[u8], content_type: &ContentType) -> Result<Vec<u8>, ProcessError> {
        match content_type {
            ContentType::Text => self.process_text(data).await,
            ContentType::Image => self.process_image(data).await,
            ContentType::Files => self.process_files(data).await,
            ContentType::RichText => self.process_rich_text(data).await,
        }
    }
}
```

### 4. 智能过滤器
```rust
// src/shared/rust/src/clipboard/filter.rs
pub struct ContentFilter {
    sensitive_patterns: Vec<Regex>,
    min_text_length: usize,
    blocked_formats: HashSet<ContentType>,
    custom_rules: Vec<FilterRule>,
}

impl ContentFilter {
    pub fn should_process(&self, content: &ClipboardContent) -> bool {
        // 1. 检查敏感内容
        if self.contains_sensitive_content(content) {
            log::warn!("Filtered sensitive content from clipboard");
            return false;
        }

        // 2. 检查内容质量
        if !self.meets_quality_requirements(content) {
            return false;
        }

        // 3. 检查重复内容
        if self.is_duplicate_content(content) {
            return false;
        }

        // 4. 应用自定义规则
        self.apply_custom_rules(content)
    }

    fn contains_sensitive_content(&self, content: &ClipboardContent) -> bool {
        if content.content_type != ContentType::Text {
            return false;
        }

        let text = String::from_utf8_lossy(&content.data);
        self.sensitive_patterns.iter().any(|pattern| pattern.is_match(&text))
    }

    fn meets_quality_requirements(&self, content: &ClipboardContent) -> bool {
        match content.content_type {
            ContentType::Text => {
                let text = String::from_utf8_lossy(&content.data);
                text.len() >= self.min_text_length && !self.is_garbage_text(&text)
            },
            ContentType::Image => self.is_valid_image(&content.data),
            ContentType::Files => self.is_valid_file_list(&content.data),
            _ => true,
        }
    }
}
```

### 5. Android平台实现
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/clipboard/ClipboardMonitor.kt
class ClipboardMonitorImpl(
    private val context: Context,
    private val rustBridge: RustNativeBridge
) : ClipboardMonitor {

    private val clipboardManager = context.getSystemService(Context.CLIPBOARD_SERVICE)
        as ClipboardManager

    private val primaryListener = PrimaryClipChangedListener {
        onClipboardChanged()
    }

    override fun startMonitoring() {
        clipboardManager.addPrimaryClipChangedListener(primaryListener)
    }

    private fun onClipboardChanged() {
        val clip = clipboardManager.primaryClip ?: return
        val item = clip.getItemAt(0)

        // 处理不同类型的内容
        when {
            item.text != null -> processTextContent(item.text.toString())
            item.uri != null -> processUriContent(item.uri)
            item.intent != null -> processIntentContent(item.intent)
        }
    }

    private fun processTextContent(text: String) {
        // 调用Rust处理
        val processedData = rustBridge.processTextContent(text.toByteArray())
        // 发送到传输队列
    }
}
```

### 6. macOS平台实现
```swift
// src/platform/mac/NearClip/Clipboard/ClipboardMonitor.swift
class ClipboardMonitorImpl: ClipboardMonitor {
    private let pasteboard = NSPasteboard.general
    private let rustBridge: RustNativeBridge
    private var timer: Timer?

    init(rustBridge: RustNativeBridge) {
        self.rustBridge = rustBridge
    }

    func startMonitoring() {
        timer = Timer.scheduledTimer(withTimeInterval: 0.1, repeats: true) { _ in
            self.checkForChanges()
        }
    }

    private func checkForChanges() {
        guard let currentChangeCount = pasteboard.changeCount else { return }

        if currentChangeCount != lastChangeCount {
            lastChangeCount = currentChangeCount
            processClipboardContent()
        }
    }

    private func processClipboardContent() {
        // 检查不同类型的内容
        if let string = pasteboard.string(forType: .string) {
            processTextContent(string)
        } else if let data = pasteboard.data(forType: .tiff) {
            processImageData(data)
        } else if let urls = pasteboard.readObjects(forClasses: [NSURL.self]) as? [URL] {
            processFileUrls(urls)
        }
    }

    private func processTextContent(_ text: String) {
        // 调用Rust处理
        let result = rustBridge.processTextContent(text.data(using: .utf8) ?? Data())
        // 发送到传输队列
    }
}
```

## 测试用例

### 单元测试
```rust
// src/shared/rust/src/clipboard/tests.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_clipboard_monitor_change_detection() {
        let monitor = ClipboardMonitor::new();
        let content = create_test_clipboard_content();

        // 模拟粘贴板变化
        monitor.simulate_clipboard_change(content).await;

        // 验证是否检测到变化
        assert!(monitor.has_pending_events().await);
    }

    #[tokio::test]
    async fn test_content_capture_text() {
        let capture = ContentCapture::default();
        let text_data = b"Hello, World!";

        let result = capture.capture_content(text_data).await.unwrap();

        assert_eq!(result.content_type, ContentType::Text);
        assert_eq!(String::from_utf8_lossy(&result.data), "Hello, World!");
    }

    #[tokio::test]
    async fn test_sensitive_content_filtering() {
        let filter = ContentFilter::with_default_sensitive_patterns();
        let sensitive_content = create_sensitive_clipboard_content();

        assert!(!filter.should_process(&sensitive_content));
    }
}
```

### 集成测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/clipboard/ClipboardIntegrationTest.kt
@RunWith(AndroidJUnit4::class)
class ClipboardIntegrationTest {

    @Test
    fun testClipboardToRustProcessing() {
        val monitor = ClipboardMonitorImpl(context, rustBridge)
        val testText = "Test clipboard content"

        // 设置测试内容到系统粘贴板
        setClipboardText(testText)

        // 验证Rust接收到处理请求
        verify(rustBridge, timeout(1000)).processTextContent(testText.toByteArray())
    }
}
```

### 性能测试
```rust
// src/shared/rust/src/clipboard/tests/performance.rs
#[tokio::test]
async fn test_monitoring_performance() {
    let monitor = ClipboardMonitor::new();
    let start_time = Instant::now();

    // 模拟1000次粘贴板变化
    for i in 0..1000 {
        let content = create_test_content(i);
        monitor.simulate_clipboard_change(content).await;
    }

    let elapsed = start_time.elapsed();
    assert!(elapsed < Duration::from_secs(5)); // 不应超过5秒
}
```

## 部署要求

### 环境配置
- Android: API 24+ (Android 7.0+)
- macOS: 10.15+ (Catalina+)
- Rust: 1.70+
- 内存: 最少64MB用于粘贴板缓存
- 权限: 剪贴板访问权限

### 依赖项
```toml
# Cargo.toml
[dependencies]
clipboard = "0.5"
regex = "1.10"
tokio = { version = "1.35", features = ["full"] }
image = "0.24"
serde = { version = "1.0", features = ["derive"] }
ring = "0.17"  # 加密支持
```

```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.core:core-ktx:1.12"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"
}
```

## 验收测试计划

### 功能测试
1. **基本监听**: 验证粘贴板变化的实时检测
2. **内容类型**: 测试各种格式内容的正确处理
3. **过滤机制**: 验证敏感和垃圾内容的过滤
4. **性能测试**: 确保监听延迟和资源占用符合要求

### 安全测试
1. **权限验证**: 确保只有授权访问粘贴板
2. **加密测试**: 验证内容传输前的加密处理
3. **隐私保护**: 测试敏感信息的过滤效果

### 兼容性测试
1. **平台兼容**: 测试Android和macOS不同版本
2. **应用兼容**: 测试与其他应用的粘贴板交互
3. **格式兼容**: 验证各种粘贴板格式的处理

## 风险与缓解

### 技术风险
- **平台差异**: 不同操作系统粘贴板机制不同
  - 缓解: 使用Rust统一抽象层，平台特定实现
- **性能影响**: 持续监听可能影响系统性能
  - 缓解: 智能监听间隔，资源使用监控
- **内容格式**: 复杂格式内容处理困难
  - 缓解: 优先支持主流格式，逐步扩展

### 安全风险
- **隐私泄露**: 意外捕获敏感信息
  - 缓解: 多层过滤机制，用户可配置规则
- **恶意利用**: 被恶意软件利用粘贴板访问
  - 缓解: 严格权限控制，安全审计日志

### 用户体验风险
- **电池消耗**: 持续监听影响设备电池
  - 缓解: 智能监听策略，系统优化
- **干扰用户**: 影响用户正常粘贴板使用
  - 缓解: 无侵入式监听，用户控制开关

## 完成标准
- [ ] Android平台粘贴板监听正常工作
- [ ] macOS平台粘贴板监听正常工作
- [ ] 支持主要内容类型（文本、图片、文件）
- [ ] 智能过滤机制正常工作
- [ ] 安全加密和完整性校验通过
- [ ] 性能指标达到要求
- [ ] 所有单元测试和集成测试通过
- [ ] 安全测试和兼容性测试通过
- [ ] 用户文档和开发者文档完整