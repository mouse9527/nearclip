# 故事 3.4: 内容接收与粘贴

## 基本信息
- **故事编号**: 3.4
- **Epic**: Epic 3 - 跨设备粘贴板同步
- **故事名称**: 内容接收与粘贴
- **优先级**: 高
- **预计工期**: 4 天
- **负责人**: 待分配
- **创建时间**: 2025-10-17
- **更新时间**: 2025-10-17

## 用户故事
**作为** NearClip 用户，
**我希望** 接收来自其他设备的粘贴板内容并能够一键粘贴到当前应用，
**以便** 我能够快速、方便地使用其他设备的内容，提升工作效率。

## 验收标准

### AC 1: 自动内容接收
- **实时接收**: 能够自动接收来自配对设备的粘贴板内容
- **后台处理**: 在后台静默处理接收的内容，不干扰用户操作
- **队列管理**: 支持多个内容的接收队列，先进先出处理
- **存储管理**: 临时存储接收的内容，支持历史记录查看
- **状态同步**: 实时更新接收状态，显示内容处理进度

### AC 2: 智能内容处理
- **格式转换**: 自动转换内容格式以适配当前平台
- **数据验证**: 验证接收内容的完整性和有效性
- **解密处理**: 自动解密接收的加密内容
- **解压缩**: 自动解压缩压缩的内容
- **格式适配**: 智能选择最适合当前应用的内容格式

### AC 3: 一键粘贴功能
- **快速粘贴**: 提供快捷键或手势快速粘贴最新接收的内容
- **应用检测**: 自动检测当前活动应用，智能选择粘贴内容
- **格式优化**: 根据当前应用优化粘贴内容格式
- **粘贴预览**: 提供粘贴内容预览功能，确认后再粘贴
- **历史粘贴**: 支持从历史记录中选择内容进行粘贴

### AC 4: 用户通知与确认
- **接收通知**: 接收到新内容时显示非侵入式通知
- **内容预览**: 通知中包含内容摘要和基本信息
- **快速操作**: 通知中提供快速粘贴和忽略选项
- **设置提醒**: 支持用户自定义通知偏好和提醒方式
- **静默模式**: 支持专注模式，临时禁用通知

### AC 5: 安全与隐私保护
- **来源验证**: 验证接收内容的来源设备授权状态
- **内容扫描**: 扫描接收内容的安全性，检测潜在威胁
- **用户确认**: 敏感内容需要用户确认才能粘贴
- **访问控制**: 限制特定应用访问粘贴板内容
- **审计记录**: 记录所有接收和粘贴操作的详细日志

## 技术实现要点

### 1. Rust接收引擎
```rust
// src/shared/rust/src/receiver/mod.rs
pub mod listener;
pub mod processor;
pub mod manager;
pub mod security;
pub mod storage;

pub use listener::ContentListener;
pub use processor::ContentProcessor;
pub use manager::ReceiverManager;
pub use security::SecurityValidator;
pub use storage::ContentStorage;
```

### 2. 内容监听器
```rust
// src/shared/rust/src/receiver/listener.rs
pub struct ContentListener {
    protocol: TransferProtocol,
    encryption_engine: EncryptionEngine,
    processor: ContentProcessor,
    storage: ContentStorage,
    active_sessions: Arc<Mutex<HashMap<SessionId, ActiveSession>>>,
}

impl ContentListener {
    pub async fn start_listening(&self) -> Result<(), ListenerError> {
        // 开始监听传入的传输
        self.protocol.start_incoming_listener().await?;

        loop {
            match self.protocol.wait_for_incoming_transfer().await {
                Ok(incoming_transfer) => {
                    if let Err(e) = self.handle_incoming_transfer(incoming_transfer).await {
                        log::error!("Failed to handle incoming transfer: {}", e);
                    }
                },
                Err(e) => {
                    log::error!("Error waiting for incoming transfer: {}", e);
                    tokio::time::sleep(Duration::from_secs(1)).await;
                }
            }
        }
    }

    async fn handle_incoming_transfer(&self, incoming: IncomingTransfer) -> Result<(), ListenerError> {
        // 1. 验证发送方设备
        self.validate_sender_device(&incoming.source_device).await?;

        // 2. 创建接收会话
        let session_id = SessionId::new();
        let session = ActiveSession::new(session_id, incoming.clone());
        self.active_sessions.lock().unwrap().insert(session_id, session);

        // 3. 开始接收数据
        let received_data = self.receive_transfer_data(incoming, session_id).await?;

        // 4. 处理接收的内容
        let processed_content = self.processor.process_content(received_data).await?;

        // 5. 存储内容
        self.storage.store_content(processed_content.clone()).await?;

        // 6. 发送完成确认
        self.send_completion_confirmation(&incoming.source_device, session_id).await?;

        // 7. 通知用户界面
        self.notify_content_received(processed_content).await?;

        // 8. 清理会话
        self.active_sessions.lock().unwrap().remove(&session_id);

        Ok(())
    }

    async fn receive_transfer_data(&self, incoming: IncomingTransfer, session_id: SessionId) -> Result<ReceivedData, ListenerError> {
        let mut received_chunks = HashMap::new();
        let mut total_size = 0;

        loop {
            let packet = self.protocol.wait_for_packet(&incoming.source_device, Some(session_id)).await?;

            match packet {
                Packet::DataChunk { chunk_index, data, .. } => {
                    received_chunks.insert(chunk_index, data);
                    total_size += data.len();

                    // 发送确认
                    self.send_chunk_ack(&incoming.source_device, session_id, chunk_index).await?;
                },
                Packet::TransferComplete { .. } => {
                    break;
                },
                _ => return Err(ListenerError::UnexpectedPacket),
            }
        }

        // 重组数据
        let mut reassembled_data = Vec::with_capacity(total_size);
        for i in 0..received_chunks.len() {
            if let Some(chunk) = received_chunks.get(&(i as u32)) {
                reassembled_data.extend_from_slice(chunk);
            } else {
                return Err(ListenerError::MissingChunk(i as u32));
            }
        }

        Ok(ReceivedData {
            data: reassembled_data,
            metadata: incoming.metadata,
            received_at: Utc::now(),
        })
    }
}
```

### 3. 内容处理器
```rust
// src/shared/rust/src/receiver/processor.rs
pub struct ContentProcessor {
    encryption_engine: EncryptionEngine,
    compression_engine: CompressionEngine,
    format_converter: FormatConverter,
    security_validator: SecurityValidator,
}

impl ContentProcessor {
    pub async fn process_content(&self, received_data: ReceivedData) -> Result<ProcessedContent, ProcessorError> {
        // 1. 安全验证
        self.security_validator.validate(&received_data).await?;

        // 2. 解密内容
        let decrypted_data = self.encryption_engine
            .decrypt_content(&received_data.metadata.source_device, &received_data.data)?;

        // 3. 解压缩内容
        let decompressed_data = if received_data.metadata.compressed {
            self.compression_engine.decompress(&decrypted_data)?
        } else {
            decrypted_data
        };

        // 4. 格式转换
        let converted_content = self.format_converter.convert_to_platform_format(
            decompressed_data,
            &received_data.metadata.content_type
        ).await?;

        // 5. 生成处理元数据
        let processing_metadata = ProcessingMetadata {
            received_at: received_data.received_at,
            processed_at: Utc::now(),
            source_device: received_data.metadata.source_device,
            original_format: received_data.metadata.content_type,
            converted_format: converted_content.content_type,
            size: converted_content.data.len(),
            security_level: self.security_validator.get_security_level(),
        };

        Ok(ProcessedContent {
            id: generate_uuid(),
            content: converted_content,
            metadata: processing_metadata,
        })
    }
}
```

### 4. 接收管理器
```rust
// src/shared/rust/src/receiver/manager.rs
pub struct ReceiverManager {
    content_storage: ContentStorage,
    notification_manager: NotificationManager,
    paste_manager: PasteManager,
    settings: ReceiverSettings,
}

impl ReceiverManager {
    pub async fn handle_new_content(&self, content: ProcessedContent) -> Result<(), ManagerError> {
        // 1. 检查用户设置
        if !self.should_receive_content(&content) {
            return Ok(());
        }

        // 2. 添加到接收历史
        self.content_storage.add_to_history(content.clone()).await?;

        // 3. 准备粘贴板
        self.prepare_clipboard_content(&content).await?;

        // 4. 发送通知
        if self.settings.enable_notifications {
            self.send_content_notification(&content).await?;
        }

        // 5. 更新状态
        self.update_receiver_status(content.id).await?;

        Ok(())
    }

    async fn prepare_clipboard_content(&self, content: &ProcessedContent) -> Result<(), ManagerError> {
        // 准备不同格式的粘贴板内容
        let clipboard_items = self.generate_clipboard_items(&content.content).await?;

        // 设置到系统粘贴板
        self.set_system_clipboard(clipboard_items).await?;

        // 记录粘贴板状态
        self.content_storage.update_clipboard_status(content.id, ClipboardStatus::Ready).await?;

        Ok(())
    }

    pub async fn paste_content(&self, content_id: Option<String>) -> Result<PasteResult, ManagerError> {
        let content_to_paste = match content_id {
            Some(id) => self.content_storage.get_content(&id).await?,
            None => self.content_storage.get_latest_content().await?,
        };

        if let Some(content) = content_to_paste {
            // 1. 验证粘贴权限
            self.validate_paste_permission(&content).await?;

            // 2. 执行粘贴操作
            let paste_result = self.paste_manager.execute_paste(&content).await?;

            // 3. 记录粘贴操作
            self.content_storage.record_paste_operation(content.id, &paste_result).await?;

            // 4. 更新统计信息
            self.update_paste_statistics(&paste_result).await?;

            Ok(paste_result)
        } else {
            Err(ManagerError::NoContentAvailable)
        }
    }

    async fn generate_clipboard_items(&self, content: &ConvertedContent) -> Result<Vec<ClipboardItem>, ManagerError> {
        let mut items = Vec::new();

        match content.content_type {
            ContentType::Text => {
                // 添加纯文本格式
                items.push(ClipboardItem {
                    format: ClipboardFormat::Text,
                    data: content.data.clone(),
                });

                // 如果是富文本，添加HTML格式
                if let Some(html_data) = self.convert_to_html(&content.data) {
                    items.push(ClipboardItem {
                        format: ClipboardFormat::Html,
                        data: html_data,
                    });
                }
            },
            ContentType::Image => {
                // 添加原始图片格式
                items.push(ClipboardItem {
                    format: ClipboardFormat::Image,
                    data: content.data.clone(),
                });

                // 生成缩略图
                if let Some(thumbnail) = self.generate_thumbnail(&content.data) {
                    items.push(ClipboardItem {
                        format: ClipboardFormat::Thumbnail,
                        data: thumbnail,
                    });
                }
            },
            ContentType::Files => {
                // 处理文件列表
                let file_items = self.process_file_content(&content.data).await?;
                items.extend(file_items);
            },
            _ => {
                // 其他格式直接添加
                items.push(ClipboardItem {
                    format: ClipboardFormat::Raw,
                    data: content.data.clone(),
                });
            }
        }

        Ok(items)
    }
}
```

### 5. 安全验证器
```rust
// src/shared/rust/src/receiver/security.rs
pub struct SecurityValidator {
    trusted_devices: HashSet<DeviceId>,
    content_scanner: ContentScanner,
    threat_detector: ThreatDetector,
}

impl SecurityValidator {
    pub async fn validate(&self, received_data: &ReceivedData) -> Result<SecurityLevel, SecurityError> {
        // 1. 验证设备授权
        if !self.trusted_devices.contains(&received_data.metadata.source_device) {
            return Err(SecurityError::UnauthorizedDevice);
        }

        // 2. 验证时间戳（防重放攻击）
        self.validate_timestamp(&received_data.metadata.timestamp)?;

        // 3. 内容安全扫描
        let scan_result = self.content_scanner.scan(&received_data.data).await?;
        if scan_result.threat_level > ThreatLevel::Low {
            return Err(SecurityError::ThreatDetected(scan_result.threat_level));
        }

        // 4. 完整性验证
        self.verify_content_integrity(received_data)?;

        // 5. 确定安全等级
        let security_level = self.determine_security_level(&scan_result);

        Ok(security_level)
    }

    fn validate_timestamp(&self, timestamp: &DateTime<Utc>) -> Result<(), SecurityError> {
        let now = Utc::now();
        let time_diff = now.signed_duration_since(*timestamp);

        // 拒绝超过5分钟的内容
        if time_diff.num_minutes() > 5 {
            return Err(SecurityError::ExpiredContent);
        }

        // 拒绝未来的时间戳
        if time_diff.num_seconds() < -60 {
            return Err(SecurityError::FutureTimestamp);
        }

        Ok(())
    }

    fn verify_content_integrity(&self, received_data: &ReceivedData) -> Result<(), SecurityError> {
        let expected_checksum = &received_data.metadata.checksum;
        let actual_checksum = calculate_checksum(&received_data.data);

        if expected_checksum != &actual_checksum {
            return Err(SecurityError::ChecksumMismatch);
        }

        Ok(())
    }
}
```

### 6. Android平台实现
```kotlin
// src/platform/android/app/src/main/java/com/nearclip/receiver/ContentReceiver.kt
class ContentReceiverImpl(
    private val context: Context,
    private val rustBridge: RustNativeBridge
) : ContentReceiver {

    private val clipboardManager = context.getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
    private val notificationManager = NotificationManagerCompat.from(context)

    override suspend fun handleReceivedContent(content: ProcessedContent) {
        // 1. 准备粘贴板数据
        val clipData = createClipData(content)

        // 2. 设置到系统粘贴板
        clipboardManager.setPrimaryClip(clipData)

        // 3. 发送通知
        showContentNotification(content)

        // 4. 更新UI状态
        updateReceiverState(content)
    }

    private fun createClipData(content: ProcessedContent): ClipData {
        return when (content.content.type) {
            ContentType.TEXT -> {
                val item = ClipData.Item(content.content.data.toString(Charsets.UTF_8))
                ClipData.newPlainText("NearClip", item)
            }
            ContentType.IMAGE -> {
                val uri = saveImageToCache(content.content.data)
                val item = ClipData.Item(uri)
                ClipData.newUri(context.contentResolver, "NearClip", uri)
            }
            else -> {
                val item = ClipData.Item(content.content.data.toString(Charsets.UTF_8))
                ClipData.newPlainText("NearClip", item)
            }
        }
    }

    private fun showContentNotification(content: ProcessedContent) {
        val notification = NotificationCompat.Builder(context, CHANNEL_ID)
            .setSmallIcon(R.drawable.ic_nearclip)
            .setContentTitle("收到新内容")
            .setContentText(formatContentSummary(content))
            .setPriority(NotificationCompat.PRIORITY_DEFAULT)
            .setAutoCancel(true)
            .addAction(
                R.drawable.ic_paste,
                "立即粘贴",
                createPendingIntent(content.id)
            )
            .build()

        notificationManager.notify(NOTIFICATION_ID, notification)
    }

    suspend fun pasteContent(contentId: String): Boolean {
        return try {
            // 调用Rust执行粘贴
            val result = rustBridge.pasteContent(contentId)
            result
        } catch (e: Exception) {
            Log.e("ContentReceiver", "Paste failed", e)
            false
        }
    }
}
```

### 7. macOS平台实现
```swift
// src/platform/mac/NearClip/Receiver/ContentReceiver.swift
class ContentReceiverImpl: ContentReceiver {
    private let pasteboard = NSPasteboard.general
    private let notificationCenter = NotificationCenter.default
    private let userNotificationCenter = UNUserNotificationCenter.current()

    func handleReceivedContent(_ content: ProcessedContent) async throws {
        // 1. 准备粘贴板数据
        let pasteboardItems = createPasteboardItems(content)

        // 2. 清空并设置粘贴板
        pasteboard.clearContents()
        pasteboard.writeObjects(pasteboardItems)

        // 3. 发送通知
        await showContentNotification(content)

        // 4. 更新UI状态
        await MainActor.run {
            NotificationCenter.default.post(
                name: .contentReceived,
                object: ContentReceivedEvent(content: content)
            )
        }
    }

    private func createPasteboardItems(_ content: ProcessedContent) -> [NSPasteboardWriting] {
        switch content.content.type {
        case .text:
            let text = String(data: content.content.data, encoding: .utf8) ?? ""
            return [text as NSString]
        case .image:
            if let image = NSImage(data: content.content.data) {
                return [image]
            }
            return []
        case .files:
            let urls = createFileUrls(from: content.content.data)
            return urls
        default:
            let data = content.content.data as NSData
            return [data]
        }
    }

    private func showContentNotification(_ content: ProcessedContent) async {
        let content = UNMutableNotificationContent()
        content.title = "收到新内容"
        content.body = formatContentSummary(content)
        content.sound = .default

        // 添加粘贴动作
        let pasteAction = UNNotificationAction(
            identifier: "PASTE_ACTION",
            title: "立即粘贴",
            options: []
        )
        let category = UNNotificationCategory(
            identifier: "CONTENT_RECEIVED",
            actions: [pasteAction],
            intentIdentifiers: [],
            options: []
        )
        UNUserNotificationCenter.current().setNotificationCategories([category])
        content.categoryIdentifier = "CONTENT_RECEIVED"

        let request = UNNotificationRequest(
            identifier: content.id,
            content: content,
            trigger: nil
        )

        try? await UNUserNotificationCenter.current().add(request)
    }

    func pasteContent(contentId: String) async throws -> Bool {
        return try await rustBridge.pasteContent(contentId)
    }
}
```

## 测试用例

### 单元测试
```rust
// src/shared/rust/src/receiver/tests.rs
#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_content_processing() {
        let processor = ContentProcessor::new().await;
        let received_data = create_test_received_data();

        let result = processor.process_content(received_data).await.unwrap();

        assert!(!result.content.data.is_empty());
        assert!(result.metadata.processed_at > result.metadata.received_at);
    }

    #[tokio::test]
    async fn test_security_validation() {
        let validator = SecurityValidator::with_trusted_devices(vec![create_test_device_id()]);
        let valid_data = create_valid_received_data();
        let invalid_data = create_tampered_received_data();

        // 有效数据应该通过验证
        assert!(validator.validate(&valid_data).await.is_ok());

        // 被篡改的数据应该被拒绝
        assert!(validator.validate(&invalid_data).await.is_err());
    }

    #[tokio::test]
    async fn test_clipboard_preparation() {
        let manager = ReceiverManager::new().await;
        let content = create_test_processed_content();

        let result = manager.prepare_clipboard_content(&content).await;

        assert!(result.is_ok());
    }
}
```

### 集成测试
```kotlin
// src/platform/android/app/src/test/java/com/nearclip/receiver/ReceiverIntegrationTest.kt
@RunWith(AndroidJUnit4::class)
class ReceiverIntegrationTest {

    @Test
    fun testEndToEndReception() {
        val content = createTestProcessedContent()

        // 处理接收的内容
        runBlocking {
            contentReceiver.handleReceivedContent(content)
        }

        // 验证粘贴板内容
        val clipboard = clipboardManager.primaryClip
        assertThat(clipboard).isNotNull()
        assertThat(clipboard.getItemAt(0).text).isEqualTo(content.content.data.toString())
    }
}
```

### 性能测试
```rust
// src/shared/rust/src/receiver/tests/performance.rs
#[tokio::test]
async fn test_reception_performance() {
    let receiver = ContentListener::new().await;
    let content_sizes = vec![1_000, 10_000, 100_000, 1_000_000]; // 1KB到1MB

    for size in content_sizes {
        let test_data = create_test_received_data(size);
        let start_time = Instant::now();

        let result = receiver.handle_incoming_transfer(test_data).await;
        let elapsed = start_time.elapsed();

        assert!(result.is_ok());
        let throughput = size as f64 / elapsed.as_secs_f64();
        println!("Size: {} bytes, Processing time: {:?}", size, elapsed);

        // 确保处理时间在合理范围内
        assert!(elapsed < Duration::from_secs(5));
    }
}
```

## 部署要求

### 环境配置
- Android: API 24+ (Android 7.0+)
- macOS: 10.15+ (Catalina+)
- Rust: 1.70+
- 权限: 粘贴板访问权限、通知权限
- 内存: 最少64MB用于接收缓存

### 依赖项
```toml
# Cargo.toml
[dependencies]
tokio = { version = "1.35", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
ring = "0.17"  # 加密支持
flate2 = "1.0" # 压缩支持
chrono = { version = "0.4", features = ["serde"] }
```

```kotlin
// Android build.gradle
dependencies {
    implementation "androidx.core:core-ktx:1.12"
    implementation "androidx.work:work-runtime-ktx:2.8.1"
    implementation "org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3"
}
```

## 验收测试计划

### 功能测试
1. **内容接收**: 测试各种类型内容的接收功能
2. **数据处理**: 验证解密、解压缩和格式转换
3. **粘贴板操作**: 测试粘贴板内容的设置和获取
4. **通知功能**: 验证接收通知的正确显示

### 安全测试
1. **设备验证**: 测试未授权设备的内容拒绝
2. **内容扫描**: 验证恶意内容的检测和过滤
3. **时间戳验证**: 测试重放攻击防护
4. **完整性校验**: 验证内容完整性检查

### 用户体验测试
1. **通知体验**: 测试通知的非侵入性和易用性
2. **粘贴体验**: 验证一键粘贴的流畅性
3. **历史管理**: 测试内容历史记录的查看和使用
4. **设置配置**: 验证用户设置的正确应用

### 兼容性测试
1. **平台兼容**: 测试Android和macOS的粘贴板机制
2. **应用兼容**: 测试不同应用的粘贴行为
3. **格式兼容**: 验证各种内容格式的跨平台兼容性

## 风险与缓解

### 技术风险
- **粘贴板冲突**: 与其他应用操作粘贴板时可能产生冲突
  - 缓解: 智能检测粘贴板状态，延迟设置机制
- **格式丢失**: 内容格式在转换过程中可能丢失
  - 缓解: 多格式备份，渐进式格式降级
- **性能影响**: 频繁的粘贴板操作可能影响系统性能
  - 缓解: 批量处理，智能缓存，后台优化

### 安全风险
- **恶意内容**: 接收到恶意软件或病毒
  - 缓解: 内容安全扫描，威胁检测，沙盒执行
- **隐私泄露**: 敏感内容意外泄露给其他应用
  - 缓解: 访问控制，权限管理，临时隔离
- **权限滥用**: 应用滥用粘贴板访问权限
  - 缓解: 最小权限原则，权限审计，用户控制

### 用户体验风险
- **通知骚扰**: 频繁的通知可能干扰用户
  - 缓解: 智能通知频率控制，用户自定义设置
- **粘贴失败**: 粘贴操作可能失败或不如预期
  - 缓解: 错误提示，重试机制，用户反馈
- **内容过载**: 接收过多内容导致管理困难
  - 缓解: 智能过滤，自动清理，历史管理

## 完成标准
- [ ] 自动内容接收功能正常工作
- [ ] 内容解密和解压缩正确处理
- [ ] 一键粘贴功能流畅可用
- [ ] 用户通知系统友好且有效
- [ ] 安全验证机制可靠运行
- [ ] 所有单元测试和集成测试通过
- [ ] 安全测试和用户体验测试通过
- [ ] Android和macOS平台功能完整
- [ ] 错误处理和用户反馈机制完善