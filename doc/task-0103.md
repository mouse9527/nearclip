# Task 0103: 实现设备列表管理

## 任务描述

实现统一的设备列表管理，用户看到的只是设备，不关心底层传输方式。

## 正交性分析

- **统一抽象**: 设备统一表示，隐藏传输细节
- **状态管理**: 统一的设备状态管理
- **生命周期**: 设备发现和连接生命周期
- **多协议聚合**: 聚合不同协议发现的相同设备

## 技术实现

### 核心组件
```rust
// rust-core/discovery/device_manager.rs
pub struct DeviceManager {
    devices: RwLock<HashMap<String, UnifiedDevice>>,
    discovery_manager: HybridDiscovery,
    transport_manager: TransportManager,
    config: DeviceManagerConfig,
}

pub struct UnifiedDevice {
    pub device_id: String,
    pub name: String,
    pub status: DeviceStatus,
    pub capabilities: DeviceCapabilities,
    pub discovery_methods: Vec<DiscoveryMethod>, // 支持的发现方式
    pub preferred_transport: Option<TransportType>, // 当前首选传输
    pub last_seen: SystemTime,
    pub connection_info: UnifiedConnectionInfo,
}

pub struct UnifiedConnectionInfo {
    pub active_transport: Option<TransportType>,
    pub available_transports: Vec<TransportType>,
    pub quality_scores: HashMap<TransportType, f32>,
    pub last_switch_time: Option<SystemTime>,
    pub switch_count: u32,
}

#[derive(Debug)]
pub enum DiscoveryMethod {
    Mdns { service_name: String },
    Ble { service_uuid: String },
    Both { mdns_service: String, ble_uuid: String },
}

pub enum DeviceStatus {
    Discovered,        // 已发现但未连接
    Connecting,        // 正在连接
    Connected,         // 已连接
    Reconnecting,      // 正在重连
    Offline,          // 离线
    Error(String),    // 错误状态
}
```

### 接口设计
```rust
impl DeviceManager {
    pub fn new(config: DeviceManagerConfig) -> Self;
    
    // 统一的设备管理接口，用户层面不关心传输方式
    pub async fn start_discovery(&mut self) -> Result<(), DeviceError>;
    pub async fn stop_discovery(&mut self) -> Result<(), DeviceError>;
    
    // 设备操作接口，自动选择最佳传输方式
    pub async fn connect_device(&mut self, device_id: &str) -> Result<(), DeviceError>;
    pub async fn disconnect_device(&mut self, device_id: &str) -> Result<(), DeviceError>;
    pub async fn send_to_device(&mut self, device_id: &str, data: &[u8]) -> Result<(), DeviceError>;
    
    // 设备查询接口
    pub fn get_device(&self, device_id: &str) -> Option<UnifiedDevice>;
    pub fn get_connected_devices(&self) -> Vec<UnifiedDevice>;
    pub fn get_available_devices(&self) -> Vec<UnifiedDevice>;
    
    // 设备发现聚合 - 处理不同协议发现的相同设备
    pub fn add_discovered_device(&mut self, discovery_method: DiscoveryMethod, device_info: DeviceInfo) -> bool;
    pub fn merge_device_discoveries(&mut self, device_id: &str, new_discovery: DiscoveryMethod) -> bool;
    
    // 传输自动切换接口
    pub async fn suggest_transport_switch(&self, device_id: &str) -> Option<TransportType>;
    pub async fn force_transport_switch(&mut self, device_id: &str, transport_type: TransportType) -> Result<(), DeviceError>;
    
    // 设备状态管理
    pub fn update_device_transport_status(&mut self, device_id: &str, transport_type: TransportType, status: TransportStatus);
    pub fn get_device_quality_scores(&self, device_id: &str) -> HashMap<TransportType, f32>;
}
```

### 设备聚合逻辑
```rust
impl DeviceManager {
    fn merge_device_discoveries(&mut self, device_id: &str, new_discovery: DiscoveryMethod) -> bool {
        if let Some(device) = self.devices.get_mut(device_id) {
            // 检查是否已经有这个发现方式
            if !device.discovery_methods.contains(&new_discovery) {
                device.discovery_methods.push(new_discovery);
                
                // 更新可用传输方式
                match new_discovery {
                    DiscoveryMethod::Mdns { .. } => {
                        if !device.connection_info.available_transports.contains(&TransportType::Wifi) {
                            device.connection_info.available_transports.push(TransportType::Wifi);
                        }
                    }
                    DiscoveryMethod::Ble { .. } => {
                        if !device.connection_info.available_transports.contains(&TransportType::Ble) {
                            device.connection_info.available_transports.push(TransportType::Ble);
                        }
                    }
                    DiscoveryMethod::Both { .. } => {
                        // 同时支持WiFi和BLE
                        for transport in [TransportType::Wifi, TransportType::Ble] {
                            if !device.connection_info.available_transports.contains(&transport) {
                                device.connection_info.available_transports.push(transport);
                            }
                        }
                    }
                }
                
                info!("Device {} now supports discovery methods: {:?}", device_id, device.discovery_methods);
                return true;
            }
        }
        false
    }
    
    fn generate_device_id(&self, device_info: &DeviceInfo, discovery_method: &DiscoveryMethod) -> String {
        // 尝试在不同发现方式中识别相同的设备
        match discovery_method {
            DiscoveryMethod::Mdns { service_name } => {
                // mDNS设备可能通过设备名称或服务名称识别
                format!("mdns_{}", device_info.name.to_lowercase().replace(" ", "_"))
            }
            DiscoveryMethod::Ble { service_uuid } => {
                // BLE设备通过MAC地址或UUID识别
                if let Some(mac) = device_info.metadata.get("mac_address") {
                    format!("ble_{}", mac.replace(":", ""))
                } else {
                    format!("ble_{}", service_uuid.replace("-", ""))
                }
            }
            DiscoveryMethod::Both { mdns_service, .. } => {
                // 混合设备优先使用mDNS标识
                format!("hybrid_{}", mdns_service)
            }
        }
    }
}
```

### 自动传输选择示例
```rust
impl DeviceManager {
    pub async fn send_to_device(&mut self, device_id: &str, data: &[u8]) -> Result<(), DeviceError> {
        let device = self.devices.get(device_id)
            .ok_or(DeviceError::DeviceNotFound)?;
        
        // 如果设备未连接，先连接
        if !matches!(device.status, DeviceStatus::Connected) {
            self.connect_device(device_id).await?;
        }
        
        // 获取当前活跃的传输方式
        let current_transport = device.connection_info.active_transport
            .ok_or(DeviceError::NotConnected)?;
        
        // 获取传输实例
        let transport = self.transport_manager.get_transport(device_id, current_transport)
            .await?;
        
        // 发送数据
        transport.send_data(data).await
            .map_err(|e| DeviceError::TransportError(e))?;
        
        Ok(())
    }
    
    pub async fn optimize_device_transports(&mut self, device_id: &str) -> Result<(), DeviceError> {
        let device = self.devices.get_mut(device_id)
            .ok_or(DeviceError::DeviceNotFound)?;
        
        // 获取当前上下文
        let context = self.context_monitor.get_current_context().await?;
        
        // 评估最佳传输方式
        let suggested_transport = self.transport_selector
            .select_best_transport(&device.connection_info.available_transports, &context)
            .await?;
        
        // 如果建议的传输方式与当前不同，且收益足够大，则切换
        if suggested_transport.selected_transport != device.connection_info.active_transport 
           && suggested_transport.confidence_score > 0.8 {
            
            info!("Switching device {} from {:?} to {:?} (confidence: {:.2})", 
                  device_id, 
                  device.connection_info.active_transport, 
                  suggested_transport.selected_transport,
                  suggested_transport.confidence_score);
            
            self.transport_manager.switch_transport(
                device_id, 
                suggested_transport.selected_transport
            ).await?;
            
            // 更新设备状态
            device.connection_info.active_transport = Some(suggested_transport.selected_transport);
            device.connection_info.last_switch_time = Some(SystemTime::now());
            device.connection_info.switch_count += 1;
        }
        
        Ok(())
    }
}
```

## 验收标准

- [ ] **统一设备抽象**: 用户看到的只是设备，不区分传输方式
- [ ] **自动传输选择**: 连接后根据网络环境自动选择最佳传输方式
- [ ] **多协议聚合**: 同一个设备通过不同协议发现时能够正确合并
- [ ] **无缝切换**: 网络环境变化时传输方式自动切换，用户无感知
- [ ] **状态同步**: 设备状态在不同传输方式间保持同步
- [ ] **性能优化**: 传输切换对性能影响最小化
- [ ] **错误恢复**: 传输切换失败时自动回退或重试