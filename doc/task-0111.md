# Task 0111: 实现BLE设备发现

## 任务描述

实现BLE设备发现功能，作为mDNS发现的有力补充。

## 正交性分析

- **蓝牙扫描**: 专注于BLE设备扫描
- **设备识别**: 应用特定设备识别
- **信号处理**: RSSI和信号质量
- **电源管理**: 扫描功耗优化

## 技术实现

### 核心组件
```rust
// rust-core/discovery/ble_discovery.rs
pub struct BleDiscoveryManager {
    ble_adapter: Box<dyn BleAdapter>,
    device_cache: BleDeviceCache,
    scan_config: BleScanConfig,
    discovery_callback: Option<Box<dyn Fn(BleDeviceInfo) + Send + Sync>>,
    is_scanning: bool,
    scan_task: Option<JoinHandle<()>>,
}

pub struct BleDeviceInfo {
    pub device_id: String,
    pub device_name: Option<String>,
    pub mac_address: String,
    pub rssi: i32,
    pub manufacturer_data: Option<Vec<u8>>,
    pub service_uuids: Vec<String>,
    pub service_data: HashMap<String, Vec<u8>>,
    pub last_seen: SystemTime,
    pub is_connectable: bool,
    pub scan_record: ScanRecord,
}

pub struct BleScanConfig {
    pub scan_mode: ScanMode,
    pub scan_duration: Duration,
    pub scan_interval: Duration,
    pub scan_window: Duration,
    pub filter_duplicates: bool,
    pub service_uuids: Vec<String>, // 只扫描特定服务
    pub manufacturer_id: Option<u16>, // 只扫描特定制造商
    pub power_level: ScanPowerLevel,
}

pub enum ScanMode {
    LowPower,    // 低功耗扫描
    Balanced,    // 平衡模式
    LowLatency,  // 低延迟扫描
    Active,      // 主动扫描
}

#[derive(Debug, Clone)]
pub struct ScanRecord {
    pub flags: u8,
    pub manufacturer_data: HashMap<u16, Vec<u8>>,
    pub service_uuids: Vec<Uuid>,
    pub service_data: HashMap<Uuid, Vec<u8>>,
    pub local_name: Option<String>,
    pub tx_power_level: Option<i8>,
}
```

### BLE发现实现
```rust
impl BleDiscoveryManager {
    pub async fn start_discovery(&mut self) -> Result<(), BleDiscoveryError> {
        if self.is_scanning {
            return Ok(());
        }
        
        info!("Starting BLE device discovery");
        
        // 设置扫描过滤器
        let scan_filter = self.create_scan_filter();
        
        // 开始扫描
        self.ble_adapter.start_scan(&scan_filter).await?;
        self.is_scanning = true;
        
        // 启动设备处理任务
        self.scan_task = Some(tokio::spawn(async move {
            self.process_discovered_devices().await;
        }));
        
        // 设置扫描超时
        if self.scan_config.scan_duration > Duration::ZERO {
            let duration = self.scan_config.scan_duration;
            tokio::spawn(async move {
                tokio::time::sleep(duration).await;
                if let Err(e) = self.stop_discovery().await {
                    error!("Failed to stop discovery scan: {}", e);
                }
            });
        }
        
        Ok(())
    }
    
    pub async fn stop_discovery(&mut self) -> Result<(), BleDiscoveryError> {
        if !self.is_scanning {
            return Ok(());
        }
        
        info!("Stopping BLE device discovery");
        
        // 停止扫描
        self.ble_adapter.stop_scan().await?;
        self.is_scanning = false;
        
        // 停止处理任务
        if let Some(task) = self.scan_task.take() {
            task.abort();
        }
        
        Ok(())
    }
    
    async fn process_discovered_devices(&self) {
        let mut device_stream = self.ble_adapter.get_device_stream();
        
        while let Some(device_event) = device_stream.next().await {
            match device_event {
                BleDeviceEvent::Discovered(device) => {
                    if let Some(our_device) = self.process_discovered_device(device).await {
                        if let Some(callback) = &self.discovery_callback {
                            callback(our_device);
                        }
                    }
                }
                BleDeviceEvent::Updated(device) => {
                    self.update_device_info(device).await;
                }
                BleDeviceEvent::Lost(device_address) => {
                    self.remove_device(device_address).await;
                }
            }
        }
    }
    
    async fn process_discovered_device(&self, raw_device: RawBleDevice) -> Option<BleDeviceInfo> {
        // 过滤非目标设备
        if !self.is_target_device(&raw_device) {
            return None;
        }
        
        // 解析扫描记录
        let scan_record = self.parse_scan_record(&raw_device.scan_record)?;
        
        // 创建设备信息
        let device_info = BleDeviceInfo {
            device_id: self.generate_device_id(&raw_device),
            device_name: raw_device.name.clone(),
            mac_address: raw_device.address.clone(),
            rssi: raw_device.rssi,
            manufacturer_data: scan_record.manufacturer_data
                .values()
                .next()
                .cloned(),
            service_uuids: scan_record.service_uuids
                .iter()
                .map(|u| u.to_string())
                .collect(),
            service_data: scan_record.service_data
                .iter()
                .map(|(k, v)| (k.to_string(), v.clone()))
                .collect(),
            last_seen: SystemTime::now(),
            is_connectable: raw_device.is_connectable,
            scan_record,
        };
        
        // 缓存设备
        self.device_cache.add_device(device_info.clone()).await;
        
        Some(device_info)
    }
    
    fn is_target_device(&self, device: &RawBleDevice) -> bool {
        // 检查服务UUID
        if !self.scan_config.service_uuids.is_empty() {
            let scan_record = self.parse_scan_record(&device.scan_record).unwrap_or_default();
            let has_target_service = scan_record.service_uuids
                .iter()
                .any(|uuid| self.scan_config.service_uuids.contains(&uuid.to_string()));
            
            if !has_target_service {
                return false;
            }
        }
        
        // 检查制造商ID
        if let Some(target_manufacturer) = self.scan_config.manufacturer_id {
            let scan_record = self.parse_scan_record(&device.scan_record).unwrap_or_default();
            let has_target_manufacturer = scan_record.manufacturer_data.contains_key(&target_manufacturer);
            
            if !has_target_manufacturer {
                return false;
            }
        }
        
        true
    }
    
    fn parse_scan_record(&self, scan_data: &[u8]) -> Option<ScanRecord> {
        let mut record = ScanRecord::default();
        let mut offset = 0;
        
        while offset + 1 < scan_data.len() {
            let length = scan_data[offset] as usize;
            if length == 0 {
                break;
            }
            
            if offset + length >= scan_data.len() {
                break;
            }
            
            let data_type = scan_data[offset + 1];
            let data = &scan_data[offset + 2..offset + length];
            
            match data_type {
                0x01 => { // Flags
                    if !data.is_empty() {
                        record.flags = data[0];
                    }
                }
                0x02 | 0x03 => { // Incomplete/Complete List of 16-bit Service Class UUIDs
                    record.service_uuids.extend(Self::parse_uuids_16(data));
                }
                0x08 | 0x09 => { // Local Name
                    record.local_name = Some(String::from_utf8_lossy(data).to_string());
                }
                0x0A => { // TX Power Level
                    if !data.is_empty() {
                        record.tx_power_level = Some(data[0] as i8);
                    }
                }
                0xFF => { // Manufacturer Specific Data
                    if data.len() >= 2 {
                        let manufacturer_id = u16::from_le_bytes([data[0], data[1]]);
                        let manufacturer_data = data[2..].to_vec();
                        record.manufacturer_data.insert(manufacturer_id, manufacturer_data);
                    }
                }
                0x16 | 0x20 => { // Service Data
                    if data.len() >= 2 {
                        let uuid = Uuid::from_u16(u16::from_le_bytes([data[0], data[1]]));
                        let service_data = data[2..].to_vec();
                        record.service_data.insert(uuid, service_data);
                    }
                }
                _ => {
                    // 忽略其他类型
                }
            }
            
            offset += length;
        }
        
        Some(record)
    }
    
    fn parse_uuids_16(data: &[u8]) -> Vec<Uuid> {
        data.chunks(2)
            .filter_map(|chunk| {
                if chunk.len() == 2 {
                    Some(Uuid::from_u16(u16::from_le_bytes([chunk[0], chunk[1]])))
                } else {
                    None
                }
            })
            .collect()
    }
    
    fn generate_device_id(&self, device: &RawBleDevice) -> String {
        // 使用MAC地址作为设备ID
        format!("ble_{}", device.address.replace(':', "").to_lowercase())
    }
}
```

### 信号处理和优化
```rust
impl BleDiscoveryManager {
    async fn update_device_info(&self, updated_device: RawBleDevice) {
        let device_id = self.generate_device_id(&updated_device);
        
        if let Some(mut device_info) = self.device_cache.get_device(&device_id).await {
            // 更新RSSI
            device_info.rssi = updated_device.rssi;
            device_info.last_seen = SystemTime::now();
            
            // 重新解析扫描记录
            if let Some(new_record) = self.parse_scan_record(&updated_device.scan_record) {
                device_info.scan_record = new_record;
            }
            
            self.device_cache.update_device(device_info).await;
        }
    }
    
    async fn remove_device(&self, device_address: String) {
        let device_id = format!("ble_{}", device_address.replace(':', "").to_lowercase());
        self.device_cache.remove_device(&device_id).await;
    }
    
    fn create_scan_filter(&self) -> BleScanFilter {
        BleScanFilter {
            scan_mode: self.scan_config.scan_mode.clone(),
            service_uuids: self.scan_config.service_uuids.clone(),
            manufacturer_id: self.scan_config.manufacturer_id,
            active_scan: matches!(self.scan_config.scan_mode, ScanMode::Active),
            filter_duplicates: self.scan_config.filter_duplicates,
        }
    }
    
    pub fn get_discovered_devices(&self) -> Vec<BleDeviceInfo> {
        // 从缓存获取发现的设备
        // 这里需要异步操作，所以签名需要调整
        Vec::new()
    }
    
    pub fn set_discovery_callback<F>(&mut self, callback: F) 
    where F: Fn(BleDeviceInfo) + Send + Sync + 'static {
        self.discovery_callback = Some(Box::new(callback));
    }
}
```

### 功耗优化
```rust
impl BleDiscoveryManager {
    pub async fn enable_adaptive_scanning(&mut self) {
        // 根据设备数量和信号质量动态调整扫描参数
        let device_count = self.device_cache.get_device_count().await;
        
        let new_config = if device_count == 0 {
            // 没有设备时使用低功耗扫描
            BleScanConfig {
                scan_mode: ScanMode::LowPower,
                scan_duration: Duration::from_secs(30),
                scan_interval: Duration::from_millis(5000),
                scan_window: Duration::from_millis(500),
                ..self.scan_config.clone()
            }
        } else if device_count < 3 {
            // 少量设备时使用平衡扫描
            BleScanConfig {
                scan_mode: ScanMode::Balanced,
                scan_duration: Duration::from_secs(60),
                scan_interval: Duration::from_millis(2000),
                scan_window: Duration::from_millis(1000),
                ..self.scan_config.clone()
            }
        } else {
            // 多设备时使用主动扫描
            BleScanConfig {
                scan_mode: ScanMode::Active,
                scan_duration: Duration::from_secs(120),
                scan_interval: Duration::from_millis(1000),
                scan_window: Duration::from_millis(1500),
                ..self.scan_config.clone()
            }
        };
        
        self.scan_config = new_config;
        
        // 重启扫描以应用新配置
        if self.is_scanning {
            self.stop_discovery().await?;
            self.start_discovery().await?;
        }
    }
    
    pub async fn enable_background_scanning(&mut self) {
        // 后台扫描配置，极低功耗
        self.scan_config = BleScanConfig {
            scan_mode: ScanMode::LowPower,
            scan_duration: Duration::from_secs(5),
            scan_interval: Duration::from_secs(30),
            scan_window: Duration::from_millis(100),
            ..self.scan_config.clone()
        };
    }
}
```

## 验收标准

- [ ] BLE设备发现准确
- [ ] 设备信息解析完整
- [ ] RSSI信号处理正确
- [ ] 功耗优化有效
- [ ] 设备缓存管理
- [ ] 过滤器工作正常
- [ ] 扫描配置灵活