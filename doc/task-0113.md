# Task 0113: 实现上下文感知监控

## 任务描述

实现上下文感知监控系统，为智能传输选择提供环境信息。

## 正交性分析

- **环境感知**: 环境信息收集
- **网络监控**: 网络状态监控
- **设备状态**: 设备状态追踪
- **用户偏好**: 用户偏好学习

## 技术实现

### 核心组件
```rust
// rust-core/context/context_monitor.rs
pub struct ContextMonitor {
    network_monitor: NetworkMonitor,
    ble_monitor: BleMonitor,
    device_monitor: DeviceMonitor,
    user_preference_manager: UserPreferenceManager,
    environment_sensor: EnvironmentSensor,
    context_cache: ContextCache,
    config: MonitorConfig,
    subscribers: Vec<Box<dyn ContextSubscriber>>,
}

pub struct ContextInfo {
    pub timestamp: SystemTime,
    pub network_context: NetworkContext,
    pub ble_context: BleContext,
    pub device_context: DeviceContext,
    pub user_context: UserContext,
    pub environment_context: EnvironmentContext,
    pub location_context: LocationContext,
}

pub struct NetworkContext {
    pub wifi_available: bool,
    pub wifi_quality: NetworkQuality,
    pub wifi_networks: Vec<WifiNetwork>,
    pub cellular_available: bool,
    pub cellular_quality: CellularQuality,
    pub internet_connectivity: bool,
    pub network_type: NetworkType,
    pub bandwidth_estimate: BandwidthEstimate,
    pub latency_estimate: Duration,
}

pub struct BleContext {
    pub ble_available: bool,
    pub adapter_state: BleAdapterState,
    pub scanning_active: bool,
    pub nearby_devices: Vec<BleDeviceInfo>,
    pub connection_count: u32,
    pub signal_quality: BleSignalQuality,
    pub power_consumption: PowerLevel,
}

pub struct DeviceContext {
    pub device_type: DeviceType,
    pub power_state: PowerState,
    pub battery_level: Option<u8>,
    pub thermal_state: ThermalState,
    pub memory_usage: MemoryUsage,
    pub cpu_usage: f32,
    pub storage_available: u64,
}

#[derive(Debug, Clone)]
pub enum NetworkQuality {
    Excellent,
    Good,
    Fair,
    Poor,
    Unknown,
}
```

### 监控实现
```rust
impl ContextMonitor {
    pub async fn start_monitoring(&mut self) -> Result<(), MonitorError> {
        info!("Starting context monitoring");
        
        // 启动各个监控器
        self.network_monitor.start_monitoring().await?;
        self.ble_monitor.start_monitoring().await?;
        self.device_monitor.start_monitoring().await?;
        
        // 启动环境监控
        self.start_environment_monitoring().await;
        
        // 启动上下文更新循环
        self.start_context_update_loop().await;
        
        Ok(())
    }
    
    pub async fn get_current_context(&self) -> Result<ContextInfo, MonitorError> {
        // 从缓存获取最新上下文信息
        self.context_cache.get_latest_context()
            .ok_or(MonitorError::NoContextAvailable)
    }
    
    pub async fn subscribe_to_context_changes(&mut self, subscriber: Box<dyn ContextSubscriber>) {
        self.subscribers.push(subscriber);
    }
    
    async fn start_context_update_loop(&self) {
        let monitor = self.clone();
        
        tokio::spawn(async move {
            let mut interval = interval(Duration::from_secs(5));
            
            loop {
                interval.tick().await;
                
                if let Err(e) = monitor.update_and_notify_context().await {
                    error!("Failed to update context: {}", e);
                }
            }
        });
    }
    
    async fn update_and_notify_context(&self) -> Result<(), MonitorError> {
        // 收集各个方面的上下文信息
        let network_context = self.network_monitor.get_context().await?;
        let ble_context = self.ble_monitor.get_context().await?;
        let device_context = self.device_monitor.get_context().await?;
        let user_context = self.user_preference_manager.get_context().await?;
        let environment_context = self.environment_sensor.get_context().await?;
        let location_context = self.get_location_context().await?;
        
        // 构建完整上下文
        let context_info = ContextInfo {
            timestamp: SystemTime::now(),
            network_context,
            ble_context,
            device_context,
            user_context,
            environment_context,
            location_context,
        };
        
        // 缓存上下文
        self.context_cache.store_context(context_info.clone()).await;
        
        // 通知订阅者
        self.notify_subscribers(&context_info).await;
        
        Ok(())
    }
    
    async fn notify_subscribers(&self, context: &ContextInfo) {
        for subscriber in &self.subscribers {
            if let Err(e) = subscriber.on_context_changed(context).await {
                error!("Failed to notify context subscriber: {}", e);
            }
        }
    }
}
```

### 网络监控
```rust
pub struct NetworkMonitor {
    wifi_scanner: Box<dyn WifiScanner>,
    cellular_monitor: Box<dyn CellularMonitor>,
    connectivity_checker: ConnectivityChecker,
    bandwidth_estimator: BandwidthEstimator,
    current_context: Option<NetworkContext>,
}

impl NetworkMonitor {
    pub async fn start_monitoring(&mut self) -> Result<(), MonitorError> {
        // 启动WiFi扫描
        self.start_wifi_scanning().await;
        
        // 启动蜂窝网络监控
        self.start_cellular_monitoring().await;
        
        // 启动连接性检查
        self.start_connectivity_checking().await;
        
        // 启动带宽估算
        self.start_bandwidth_estimation().await;
        
        Ok(())
    }
    
    async fn start_wifi_scanning(&self) {
        let mut interval = interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            if let Ok(networks) = self.wifi_scanner.scan_networks().await {
                let wifi_available = !networks.is_empty();
                let best_network = networks.iter()
                    .max_by_key(|n| n.signal_strength);
                
                let wifi_quality = match best_network {
                    Some(network) => Self::calculate_wifi_quality(network.signal_strength),
                    None => NetworkQuality::Unknown,
                };
                
                // 更新上下文
                if let Some(mut context) = self.current_context {
                    context.wifi_available = wifi_available;
                    context.wifi_quality = wifi_quality;
                    context.wifi_networks = networks;
                }
            }
        }
    }
    
    fn calculate_wifi_quality(signal_strength: i32) -> NetworkQuality {
        match signal_strength {
            s if s >= -50 => NetworkQuality::Excellent,
            s if s >= -60 => NetworkQuality::Good,
            s if s >= -70 => NetworkQuality::Fair,
            s if s >= -80 => NetworkQuality::Poor,
            _ => NetworkQuality::Unknown,
        }
    }
    
    async fn start_connectivity_checking(&self) {
        let mut interval = interval(Duration::from_secs(30));
        
        loop {
            interval.tick().await;
            
            let has_connectivity = self.connectivity_checker.check_connectivity().await.unwrap_or(false);
            
            if let Some(mut context) = self.current_context {
                context.internet_connectivity = has_connectivity;
            }
        }
    }
    
    async fn start_bandwidth_estimation(&self) {
        let mut interval = interval(Duration::from_secs(60));
        
        loop {
            interval.tick().await;
            
            if let Ok(estimate) = self.bandwidth_estimator.estimate_bandwidth().await {
                if let Some(mut context) = self.current_context {
                    context.bandwidth_estimate = estimate;
                }
            }
        }
    }
}
```

### BLE监控
```rust
pub struct BleMonitor {
    ble_adapter: Box<dyn BleAdapter>,
    signal_analyzer: BleSignalAnalyzer,
    power_monitor: BlePowerMonitor,
    current_context: Option<BleContext>,
}

impl BleMonitor {
    pub async fn start_monitoring(&mut self) -> Result<(), MonitorError> {
        // 监控适配器状态
        self.monitor_adapter_state().await;
        
        // 监控信号质量
        self.monitor_signal_quality().await;
        
        // 监控功耗
        self.monitor_power_consumption().await;
        
        Ok(())
    }
    
    async fn monitor_adapter_state(&self) {
        let mut interval = interval(Duration::from_secs(5));
        
        loop {
            interval.tick().await;
            
            if let Ok(state) = self.ble_adapter.get_state().await {
                if let Some(mut context) = self.current_context {
                    context.ble_available = state.is_enabled;
                    context.adapter_state = state;
                }
            }
        }
    }
    
    async fn monitor_signal_quality(&self) {
        let mut interval = interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            if let Ok(nearby_devices) = self.ble_adapter.get_connected_devices().await {
                let signal_quality = self.signal_analyzer.analyze_signal_quality(&nearby_devices).await;
                
                if let Some(mut context) = self.current_context {
                    context.nearby_devices = nearby_devices;
                    context.signal_quality = signal_quality;
                    context.connection_count = nearby_devices.len() as u32;
                }
            }
        }
    }
    
    async fn monitor_power_consumption(&self) {
        let mut interval = interval(Duration::from_secs(15));
        
        loop {
            interval.tick().await;
            
            if let Ok(power_level) = self.power_monitor.get_power_consumption().await {
                if let Some(mut context) = self.current_context {
                    context.power_consumption = power_level;
                }
            }
        }
    }
}
```

### 智能上下文分析
```rust
impl ContextMonitor {
    pub async fn analyze_context_trends(&self) -> ContextAnalysis {
        let recent_contexts = self.context_cache.get_recent_contexts(Duration::from_secs(300)).await; // 5分钟
        
        ContextAnalysis {
            network_stability: self.analyze_network_stability(&recent_contexts),
            ble_environment: self.analyze_ble_environment(&recent_contexts),
            power_trends: self.analyze_power_trends(&recent_contexts),
            usage_patterns: self.analyze_usage_patterns(&recent_contexts),
            location_patterns: self.analyze_location_patterns(&recent_contexts),
            recommendations: self.generate_recommendations(&recent_contexts),
        }
    }
    
    fn analyze_network_stability(&self, contexts: &[ContextInfo]) -> NetworkStability {
        if contexts.len() < 2 {
            return NetworkStability::Unknown;
        }
        
        let wifi_changes = contexts.windows(2)
            .filter(|window| window[0].network_context.wifi_quality != window[1].network_context.wifi_quality)
            .count();
        
        let connectivity_changes = contexts.windows(2)
            .filter(|window| window[0].network_context.internet_connectivity != window[1].network_context.internet_connectivity)
            .count();
        
        let stability_score = 1.0 - (wifi_changes + connectivity_changes) as f32 / contexts.len() as f32;
        
        match stability_score {
            s if s >= 0.9 => NetworkStability::VeryStable,
            s if s >= 0.7 => NetworkStability::Stable,
            s if s >= 0.5 => NetworkStability::Moderate,
            _ => NetworkStability::Unstable,
        }
    }
    
    fn generate_recommendations(&self, contexts: &[ContextInfo]) -> Vec<ContextRecommendation> {
        let mut recommendations = Vec::new();
        
        // 分析网络环境
        let poor_wifi_count = contexts.iter()
            .filter(|c| matches!(c.network_context.wifi_quality, NetworkQuality::Poor | NetworkQuality::Unknown))
            .count();
        
        if poor_wifi_count > contexts.len() / 2 {
            recommendations.push(ContextRecommendation {
                recommendation_type: RecommendationType::PreferBle,
                confidence: 0.8,
                reason: "WiFi signal consistently poor, prefer BLE for better reliability".to_string(),
            });
        }
        
        // 分析电池状态
        let low_battery_count = contexts.iter()
            .filter(|c| {
                if let Some(level) = c.device_context.battery_level {
                    level < 20
                } else {
                    false
                }
            })
            .count();
        
        if low_battery_count > contexts.len() / 3 {
            recommendations.push(ContextRecommendation {
                recommendation_type: RecommendationType::EnablePowerSaving,
                confidence: 0.7,
                reason: "Battery level frequently low, enable power saving mode".to_string(),
            });
        }
        
        recommendations
    }
}
```

### 事件和订阅
```rust
#[async_trait]
pub trait ContextSubscriber: Send + Sync {
    async fn on_context_changed(&self, context: &ContextInfo) -> Result<(), MonitorError>;
}

pub struct ContextEvent {
    pub event_type: ContextEventType,
    pub context: ContextInfo,
    pub previous_context: Option<ContextInfo>,
    pub timestamp: SystemTime,
}

pub enum ContextEventType {
    NetworkChanged,
    BleEnvironmentChanged,
    DeviceStateChanged,
    LocationChanged,
    UserPreferenceChanged,
    QualityThresholdCrossed,
}
```

## 验收标准

- [ ] 上下文收集准确
- [ ] 监控实时性高
- [ ] 资源占用合理
- [ ] 趋势分析智能
- [ ] 推荐系统有效
- [ ] 事件通知及时
- [ ] 缓存管理高效