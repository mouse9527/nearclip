# Task 0109: 实现智能传输选择器

## 任务描述

实现智能传输选择器，根据上下文信息自动选择最佳传输方式。

## 正交性分析

- **决策引擎**: 传输选择算法
- **上下文感知**: 环境信息收集
- **评分系统**: 传输质量评估
- **策略管理**: 选择策略配置

## 技术实现

### 核心组件
```rust
// rust-core/transport/transport_selector.rs
pub struct TransportSelector {
    context_monitor: ContextMonitor,
    scoring_engine: ScoringEngine,
    selection_strategy: SelectionStrategy,
    selection_history: SelectionHistory,
    config: SelectorConfig,
}

pub struct ContextInfo {
    pub network_info: NetworkInfo,
    pub ble_info: BleInfo,
    pub device_info: DeviceInfo,
    pub user_preferences: UserPreferences,
    pub environment_context: EnvironmentContext,
    pub timestamp: SystemTime,
}

pub struct NetworkInfo {
    pub wifi_available: bool,
    pub wifi_quality: NetworkQuality,
    pub cellular_available: bool,
    pub internet_connectivity: bool,
    pub network_type: NetworkType,
}

pub struct BleInfo {
    pub ble_available: bool,
    pub nearby_devices: Vec<BleDeviceInfo>,
    pub adapter_state: AdapterState,
    pub power_state: PowerState,
}

#[derive(Debug, Clone)]
pub struct SelectionResult {
    pub selected_transport: TransportType,
    pub alternative: Option<TransportType>,
    pub confidence_score: f32,
    pub reasoning: Vec<String>,
    pub estimated_performance: PerformanceEstimate,
}

pub struct PerformanceEstimate {
    pub expected_throughput: f64, // bytes/sec
    pub expected_latency: Duration,
    pub reliability_score: f32,
    pub power_consumption: PowerLevel,
}
```

### 评分引擎
```rust
pub struct ScoringEngine {
    weights: ScoringWeights,
    rules: Vec<ScoringRule>,
}

pub struct ScoringWeights {
    pub throughput_weight: f32,
    pub latency_weight: f32,
    pub reliability_weight: f32,
    pub power_weight: f32,
    pub user_preference_weight: f32,
    pub context_weight: f32,
}

pub struct ScoringRule {
    pub condition: Box<dyn Fn(&ContextInfo) -> bool>,
    pub weight_adjustment: f32,
    pub description: String,
}

impl ScoringEngine {
    pub fn calculate_transport_score(&self, transport_type: TransportType, context: &ContextInfo) -> f32 {
        let base_score = self.get_base_score(transport_type, context);
        let context_score = self.calculate_context_score(transport_type, context);
        let user_preference_score = self.calculate_user_preference_score(transport_type, context);
        let rule_adjustments = self.apply_rules(transport_type, context);
        
        // 加权计算最终分数
        (base_score * self.weights.throughput_weight +
         context_score * self.weights.context_weight +
         user_preference_score * self.weights.user_preference_weight +
         rule_adjustments)
        .clamp(0.0, 1.0)
    }
    
    fn get_base_score(&self, transport_type: TransportType, context: &ContextInfo) -> f32 {
        match transport_type {
            TransportType::Wifi => {
                if !context.network_info.wifi_available {
                    return 0.0;
                }
                
                match context.network_info.wifi_quality {
                    NetworkQuality::Excellent => 0.95,
                    NetworkQuality::Good => 0.85,
                    NetworkQuality::Fair => 0.65,
                    NetworkQuality::Poor => 0.35,
                }
            }
            TransportType::Ble => {
                if !context.ble_info.ble_available {
                    return 0.0;
                }
                
                // 基于设备数量和信号质量
                let device_score = if context.ble_info.nearby_devices.len() > 3 {
                    0.9 // 多个设备，BLE更合适
                } else if context.ble_info.nearby_devices.len() > 0 {
                    0.7
                } else {
                    0.3
                };
                
                // 基于信号强度
                let avg_rssi = context.ble_info.nearby_devices
                    .iter()
                    .map(|d| d.rssi)
                    .sum::<i32>() as f32 / context.ble_info.nearby_devices.len() as f32;
                
                let rssi_score = match avg_rssi {
                    rssi if rssi > -60 => 0.9,
                    rssi if rssi > -80 => 0.7,
                    rssi if rssi > -90 => 0.4,
                    _ => 0.2,
                };
                
                (device_score + rssi_score) / 2.0
            }
            _ => 0.0,
        }
    }
    
    fn calculate_context_score(&self, transport_type: TransportType, context: &ContextInfo) -> f32 {
        match transport_type {
            TransportType::Wifi => {
                // 省电模式下降低WiFi优先级
                match context.device_info.power_state {
                    PowerState::BatterySaver => 0.6,
                    PowerState::Battery => 0.8,
                    PowerState::Charging => 1.0,
                }
            }
            TransportType::Ble => {
                // 移动设备上BLE优先级更高
                match context.device_info.power_state {
                    PowerState::BatterySaver => 1.2, // 最高优先级
                    PowerState::Battery => 1.1,
                    PowerState::Charging => 0.9,
                }
            }
            _ => 1.0,
        }
    }
    
    fn apply_rules(&self, transport_type: TransportType, context: &ContextInfo) -> f32 {
        let mut adjustment = 0.0;
        
        for rule in &self.rules {
            if (rule.condition)(context) {
                adjustment += rule.weight_adjustment;
                debug!("Applied rule '{}' for {:?}: adjustment={}", 
                       rule.description, transport_type, rule.weight_adjustment);
            }
        }
        
        adjustment.clamp(-0.5, 0.5)
    }
}
```

### 选择策略
```rust
pub enum SelectionStrategy {
    Greedy,        // 选择最高分数的传输
    Conservative,   // 选择最稳定的传输
    Adaptive,       // 自适应选择
    Hybrid,         // 混合策略
}

impl TransportSelector {
    pub async fn select_best_transport(&mut self, 
                                       available_transports: &[TransportType], 
                                       context: &ContextInfo) -> SelectionResult {
        
        // 计算每个传输方式的分数
        let mut scores: Vec<(TransportType, f32)> = available_transports
            .iter()
            .map(|&transport_type| {
                let score = self.scoring_engine.calculate_transport_score(transport_type, context);
                (transport_type, score)
            })
            .collect();
        
        // 按分数排序
        scores.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));
        
        if scores.is_empty() {
            return SelectionResult {
                selected_transport: TransportType::Wifi, // 默认
                alternative: None,
                confidence_score: 0.0,
                reasoning: vec!["No available transports".to_string()],
                estimated_performance: PerformanceEstimate::default(),
            };
        }
        
        let selected = &scores[0];
        let alternative = if scores.len() > 1 { Some(scores[1].0) } else { None };
        
        // 生成选择理由
        let reasoning = self.generate_reasoning(&scores, context);
        
        // 估算性能
        let estimated_performance = self.estimate_performance(selected.0, context);
        
        let result = SelectionResult {
            selected_transport: selected.0,
            alternative,
            confidence_score: selected.1,
            reasoning,
            estimated_performance,
        };
        
        // 记录选择历史
        self.selection_history.record_selection(&result, context);
        
        result
    }
    
    fn generate_reasoning(&self, scores: &[(TransportType, f32)], context: &ContextInfo) -> Vec<String> {
        let mut reasoning = Vec::new();
        
        for (transport_type, score) in scores.iter().take(3) {
            let reasons = self.explain_score(*transport_type, *score, context);
            reasoning.push(format!("{:?}: {:.2} - {}", transport_type, score, reasons.join(", ")));
        }
        
        reasoning
    }
    
    fn explain_score(&self, transport_type: TransportType, score: f32, context: &ContextInfo) -> Vec<String> {
        let mut reasons = Vec::new();
        
        match transport_type {
            TransportType::Wifi => {
                if !context.network_info.wifi_available {
                    reasons.push("WiFi not available".to_string());
                } else {
                    reasons.push(format!("WiFi quality: {:?}", context.network_info.wifi_quality));
                }
                
                if context.device_info.power_state == PowerState::BatterySaver {
                    reasons.push("Battery saver mode reduces WiFi priority".to_string());
                }
            }
            TransportType::Ble => {
                if !context.ble_info.ble_available {
                    reasons.push("BLE not available".to_string());
                } else {
                    reasons.push(format!("{} BLE devices nearby", context.ble_info.nearby_devices.len()));
                    
                    if !context.ble_info.nearby_devices.is_empty() {
                        let avg_rssi = context.ble_info.nearby_devices
                            .iter()
                            .map(|d| d.rssi)
                            .sum::<i32>() / context.ble_info.nearby_devices.len() as i32;
                        reasons.push(format!("Average RSSI: {} dBm", avg_rssi));
                    }
                }
            }
        }
        
        reasons
    }
    
    fn estimate_performance(&self, transport_type: TransportType, context: &ContextInfo) -> PerformanceEstimate {
        match transport_type {
            TransportType::Wifi => {
                let throughput = match context.network_info.wifi_quality {
                    NetworkQuality::Excellent => 50_000_000.0, // 50 MB/s
                    NetworkQuality::Good => 25_000_000.0,      // 25 MB/s
                    NetworkQuality::Fair => 10_000_000.0,      // 10 MB/s
                    NetworkQuality::Poor => 1_000_000.0,        // 1 MB/s
                };
                
                PerformanceEstimate {
                    expected_throughput: throughput,
                    expected_latency: Duration::from_millis(5),
                    reliability_score: 0.95,
                    power_consumption: PowerLevel::High,
                }
            }
            TransportType::Ble => {
                let throughput = if context.ble_info.nearby_devices.len() > 0 {
                    1_000_000.0 // 1 MB/s (BLE 5.0 theoretical max)
                } else {
                    0.0
                };
                
                PerformanceEstimate {
                    expected_throughput: throughput,
                    expected_latency: Duration::from_millis(50),
                    reliability_score: 0.8,
                    power_consumption: PowerLevel::Low,
                }
            }
        }
    }
}
```

## 验收标准

- [ ] 选择算法智能合理
- [ ] 上下文感知准确
- [ ] 评分系统完善
- [ ] 选择结果可解释
- [ ] 性能估算准确
- [ ] 策略可配置
- [ ] 历史记录完整