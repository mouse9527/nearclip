# Task 0112: 实现协议桥接机制

## 任务描述

实现WiFi和BLE之间的协议桥接，允许不同传输方式的设备通信。

## 正交性分析

- **协议转换**: 传输协议转换
- **地址映射**: 设备地址映射
- **数据路由**: 跨协议数据路由
- **安全桥接**: 安全的桥接连接

## 技术实现

### 核心组件
```rust
// rust-core/transport/protocol_bridge.rs
pub struct ProtocolBridge {
    wifi_transport: Option<Box<dyn Transport>>,
    ble_transport: Option<Box<dyn Transport>>,
    address_mapper: AddressMapper,
    data_router: DataRouter,
    security_manager: BridgeSecurityManager,
    bridge_config: BridgeConfig,
    active_bridges: HashMap<String, ActiveBridge>,
}

pub struct ActiveBridge {
    pub bridge_id: String,
    pub wifi_device_id: Option<String>,
    pub ble_device_id: Option<String>,
    pub status: BridgeStatus,
    pub created_at: SystemTime,
    pub last_activity: SystemTime,
    pub data_forwarded: u64,
    pub errors: u32,
}

pub struct AddressMapper {
    wifi_to_ble: HashMap<String, String>,
    ble_to_wifi: HashMap<String, String>,
    device_mappings: HashMap<String, DeviceMapping>,
}

pub struct DeviceMapping {
    pub wifi_address: String,
    pub ble_address: String,
    pub shared_secret: Option<Vec<u8>>,
    pub trust_level: TrustLevel,
    pub mapping_valid_until: SystemTime,
}

pub enum BridgeStatus {
    Initializing,
    Active,
    Degraded,
    Failed,
    Closed,
}
```

### 协议桥接流程
```rust
impl ProtocolBridge {
    pub async fn establish_bridge(&mut self,
                                wifi_device: &DeviceInfo,
                                ble_device: &BleDeviceInfo) -> Result<String, BridgeError> {
        
        let bridge_id = self.generate_bridge_id(wifi_device, ble_device);
        
        info!("Establishing bridge {} between WiFi device {} and BLE device {}",
              bridge_id, wifi_device.id, ble_device.device_id);
        
        // 1. 安全协商
        let shared_secret = self.security_manager.negotiate_shared_secret(wifi_device, ble_device).await?;
        
        // 2. 地址映射
        self.address_mapper.create_mapping(
            &wifi_device.id,
            &ble_device.device_id,
            shared_secret.clone(),
        ).await?;
        
        // 3. 建立连接
        let wifi_conn = self.connect_to_wifi_device(wifi_device).await?;
        let ble_conn = self.connect_to_ble_device(ble_device).await?;
        
        // 4. 创建活跃桥接
        let active_bridge = ActiveBridge {
            bridge_id: bridge_id.clone(),
            wifi_device_id: Some(wifi_device.id.clone()),
            ble_device_id: Some(ble_device.device_id.clone()),
            status: BridgeStatus::Active,
            created_at: SystemTime::now(),
            last_activity: SystemTime::now(),
            data_forwarded: 0,
            errors: 0,
        };
        
        self.active_bridges.insert(bridge_id.clone(), active_bridge);
        
        // 5. 启动数据转发任务
        self.start_data_forwarding_tasks(&bridge_id, wifi_conn, ble_conn).await;
        
        Ok(bridge_id)
    }
    
    async fn start_data_forwarding_tasks(&self,
                                         bridge_id: &str,
                                         mut wifi_transport: Box<dyn Transport>,
                                         mut ble_transport: Box<dyn Transport>) {
        let bridge_id = bridge_id.to_string();
        let address_mapper = self.address_mapper.clone();
        let data_router = self.data_router.clone();
        let security_manager = self.security_manager.clone();
        
        // WiFi -> BLE 数据转发
        let wifi_to_ble_task = tokio::spawn(async move {
            loop {
                match wifi_transport.receive_data().await {
                    Ok(data) => {
                        if let Err(e) = Self::forward_data_wifi_to_ble(
                            &bridge_id,
                            data,
                            &mut ble_transport,
                            &address_mapper,
                            &data_router,
                            &security_manager
                        ).await {
                            error!("Failed to forward data from WiFi to BLE: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("WiFi receive error: {}", e);
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                }
            }
        });
        
        // BLE -> WiFi 数据转发
        let ble_to_wifi_task = tokio::spawn(async move {
            loop {
                match ble_transport.receive_data().await {
                    Ok(data) => {
                        if let Err(e) = Self::forward_data_ble_to_wifi(
                            &bridge_id,
                            data,
                            &mut wifi_transport,
                            &address_mapper,
                            &data_router,
                            &security_manager
                        ).await {
                            error!("Failed to forward data from BLE to WiFi: {}", e);
                        }
                    }
                    Err(e) => {
                        warn!("BLE receive error: {}", e);
                        tokio::time::sleep(Duration::from_millis(100)).await;
                    }
                }
            }
        });
        
        // 监控任务状态
        tokio::spawn(async move {
            tokio::select! {
                _ = wifi_to_ble_task => {
                    error!("WiFi to BLE forwarding task ended");
                }
                _ = ble_to_wifi_task => {
                    error!("BLE to WiFi forwarding task ended");
                }
            }
        });
    }
    
    async fn forward_data_wifi_to_ble(bridge_id: &str,
                                      data: Vec<u8>,
                                      ble_transport: &mut dyn Transport,
                                      address_mapper: &AddressMapper,
                                      data_router: &DataRouter,
                                      security_manager: &BridgeSecurityManager) -> Result<(), BridgeError> {
        
        // 1. 解析数据包
        let packet = data_router.parse_packet(&data)?;
        
        // 2. 查找目标BLE地址
        let target_ble_address = address_mapper.wifi_to_ble(&packet.source_address)
            .ok_or(BridgeError::AddressMappingNotFound)?;
        
        // 3. 转换数据包格式
        let ble_packet = data_router.convert_to_ble_packet(packet, target_ble_address)?;
        
        // 4. 加密数据
        let encrypted_data = security_manager.encrypt_data(&ble_packet.serialize()?)?;
        
        // 5. 转发数据
        ble_transport.send_data(&encrypted_data).await?;
        
        // 6. 更新统计
        self.update_bridge_stats(bridge_id, encrypted_data.len()).await?;
        
        Ok(())
    }
    
    async fn forward_data_ble_to_wifi(bridge_id: &str,
                                      data: Vec<u8>,
                                      wifi_transport: &mut dyn Transport,
                                      address_mapper: &AddressMapper,
                                      data_router: &DataRouter,
                                      security_manager: &BridgeSecurityManager) -> Result<(), BridgeError> {
        
        // 1. 解密数据
        let decrypted_data = security_manager.decrypt_data(&data)?;
        
        // 2. 解析BLE数据包
        let ble_packet = data_router.parse_ble_packet(&decrypted_data)?;
        
        // 3. 查找目标WiFi地址
        let target_wifi_address = address_mapper.ble_to_wifi(&ble_packet.source_address)
            .ok_or(BridgeError::AddressMappingNotFound)?;
        
        // 4. 转换数据包格式
        let wifi_packet = data_router.convert_to_wifi_packet(ble_packet, target_wifi_address)?;
        
        // 5. 转发数据
        wifi_transport.send_data(&wifi_packet.serialize()?).await?;
        
        // 6. 更新统计
        self.update_bridge_stats(bridge_id, data.len()).await?;
        
        Ok(())
    }
}
```

### 地址映射器
```rust
impl AddressMapper {
    pub async fn create_mapping(&mut self,
                               wifi_address: &str,
                               ble_address: &str,
                               shared_secret: Option<Vec<u8>>) -> Result<(), MappingError> {
        
        let mapping = DeviceMapping {
            wifi_address: wifi_address.to_string(),
            ble_address: ble_address.to_string(),
            shared_secret,
            trust_level: TrustLevel::Verified,
            mapping_valid_until: SystemTime::now() + Duration::from_secs(3600), // 1小时有效期
        };
        
        self.wifi_to_ble.insert(wifi_address.to_string(), ble_address.to_string());
        self.ble_to_wifi.insert(ble_address.to_string(), wifi_address.to_string());
        self.device_mappings.insert(
            self.generate_mapping_key(wifi_address, ble_address),
            mapping
        );
        
        Ok(())
    }
    
    pub fn wifi_to_ble(&self, wifi_address: &str) -> Option<&String> {
        self.wifi_to_ble.get(wifi_address)
    }
    
    pub fn ble_to_wifi(&self, ble_address: &str) -> Option<&String> {
        self.ble_to_wifi.get(ble_address)
    }
    
    pub fn get_mapping(&self, wifi_address: &str, ble_address: &str) -> Option<&DeviceMapping> {
        self.device_mappings.get(&self.generate_mapping_key(wifi_address, ble_address))
    }
    
    pub fn cleanup_expired_mappings(&mut self) -> u32 {
        let now = SystemTime::now();
        let mut removed_count = 0;
        
        self.device_mappings.retain(|key, mapping| {
            if mapping.mapping_valid_until > now {
                true
            } else {
                self.wifi_to_ble.remove(&mapping.wifi_address);
                self.ble_to_wifi.remove(&mapping.ble_address);
                removed_count += 1;
                false
            }
        });
        
        removed_count
    }
    
    fn generate_mapping_key(&self, wifi_address: &str, ble_address: &str) -> String {
        format!("{}_{}", wifi_address, ble_address)
    }
}
```

### 数据路由器
```rust
pub struct DataRouter {
    packet_serializer: PacketSerializer,
    address_converter: AddressConverter,
    protocol_converter: ProtocolConverter,
}

impl DataRouter {
    pub fn parse_packet(&self, data: &[u8]) -> Result<NetworkPacket, RoutingError> {
        self.packet_serializer.deserialize(data)
    }
    
    pub fn parse_ble_packet(&self, data: &[u8]) -> Result<BlePacket, RoutingError> {
        // 解析BLE特定数据包格式
        BlePacket::deserialize(data)
    }
    
    pub fn convert_to_ble_packet(&self, packet: NetworkPacket, target_address: String) -> Result<BlePacket, RoutingError> {
        // 转换网络数据包为BLE数据包
        let ble_payload = self.protocol_converter.network_to_ble(packet.payload)?;
        
        Ok(BlePacket {
            header: BlePacketHeader {
                packet_type: BlePacketType::Data,
                source_address: packet.source_address,
                target_address,
                sequence_number: packet.sequence_number,
                flags: BlePacketFlags {
                    requires_ack: packet.flags.requires_ack,
                    ..Default::default()
                },
            },
            payload: ble_payload,
        })
    }
    
    pub fn convert_to_wifi_packet(&self, ble_packet: BlePacket, target_address: String) -> Result<NetworkPacket, RoutingError> {
        // 转换BLE数据包为网络数据包
        let network_payload = self.protocol_converter.ble_to_network(ble_packet.payload)?;
        
        Ok(NetworkPacket {
            source_address: ble_packet.header.source_address,
            target_address,
            payload: network_payload,
            sequence_number: ble_packet.header.sequence_number,
            flags: NetworkPacketFlags {
                requires_ack: ble_packet.header.flags.requires_ack,
                ..Default::default()
            },
        })
    }
}
```

### 安全管理器
```rust
pub struct BridgeSecurityManager {
    encryption_key: [u8; 32],
    session_keys: HashMap<String, SessionKey>,
    key_rotation_interval: Duration,
}

impl BridgeSecurityManager {
    pub async fn negotiate_shared_secret(&self,
                                       wifi_device: &DeviceInfo,
                                       ble_device: &BleDeviceInfo) -> Result<Vec<u8>, SecurityError> {
        // 实现密钥协商协议
        // 这里可以使用ECDH或类似的密钥交换协议
        
        // 生成临时密钥对
        let ephemeral_key = EcdhKeyExchange::generate_key_pair();
        
        // 交换公钥（需要通过现有连接）
        let wifi_public = ephemeral_key.get_public_key_bytes();
        let ble_public = self.exchange_public_keys(&wifi_device, &ble_device, wifi_public).await?;
        
        // 计算共享密钥
        ephemeral_key.compute_shared_secret(&ble_public)?;
        let shared_secret = ephemeral_key.get_shared_secret()
            .ok_or(SecurityError::KeyExchangeFailed)?;
        
        Ok(shared_secret.as_bytes().to_vec())
    }
    
    pub fn encrypt_data(&self, data: &[u8]) -> Result<Vec<u8>, SecurityError> {
        // 使用AES-256-GCM加密数据
        let cipher = Aes256Gcm::new(&self.encryption_key.into());
        let nonce = generate_random_nonce();
        
        cipher.encrypt(&nonce, data)
            .map_err(|e| SecurityError::EncryptionFailed(e.to_string()))
    }
    
    pub fn decrypt_data(&self, encrypted_data: &[u8]) -> Result<Vec<u8>, SecurityError> {
        // 使用AES-256-GCM解密数据
        let cipher = Aes256Gcm::new(&self.encryption_key.into());
        let nonce = extract_nonce(encrypted_data)?;
        
        cipher.decrypt(&nonce, encrypted_data)
            .map_err(|e| SecurityError::DecryptionFailed(e.to_string()))
    }
    
    async fn exchange_public_keys(&self,
                                 _wifi_device: &DeviceInfo,
                                 _ble_device: &BleDeviceInfo,
                                 wifi_public: [u8; 32]) -> Result<[u8; 32], SecurityError> {
        // 实现公钥交换逻辑
        // 这里需要通过现有的连接交换公钥
        Ok([0u8; 32]) // 示例返回
    }
}
```

## 验收标准

- [ ] 协议桥接稳定
- [ ] 数据转发可靠
- [ ] 地址映射准确
- [ ] 安全机制完善
- [ ] 性能影响最小
- [ ] 错误恢复机制
- [ ] 桥接状态监控