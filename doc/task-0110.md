# Task 0110: 实现传输自动切换机制

## 任务描述

实现传输自动切换机制，在网络环境变化时无缝切换传输方式。

## 正交性分析

- **切换决策**: 切换触发条件
- **状态迁移**: 连接状态管理
- **数据同步**: 传输中数据保护
- **用户体验**: 无感知切换

## 技术实现

### 核心组件
```rust
// rust-core/transport/transport_switcher.rs
pub struct TransportSwitcher {
    active_transports: HashMap<String, ActiveTransport>,
    switch_decision_engine: SwitchDecisionEngine,
    state_migration_handler: StateMigrationHandler,
    config: SwitchConfig,
    event_emitter: EventEmitter<SwitchEvent>,
}

pub struct ActiveTransport {
    pub device_id: String,
    pub transport: Box<dyn Transport>,
    pub transport_type: TransportType,
    pub state: TransportState,
    pub metrics: TransportMetrics,
    pub last_switch_time: SystemTime,
    pub switch_count: u32,
}

pub struct SwitchDecision {
    pub device_id: String,
    pub current_transport: TransportType,
    pub target_transport: TransportType,
    pub reason: SwitchReason,
    pub urgency: SwitchUrgency,
    pub estimated_benefit: f32,
}

pub enum SwitchReason {
    QualityDegraded { current_quality: f32, threshold: f32 },
    NetworkUnavailable { transport_type: TransportType },
    BetterAlternativeAvailable { alternative_quality: f32, current_quality: f32 },
    UserPreferenceChange,
    PowerStateChange,
    ContextChange,
}

pub enum SwitchUrgency {
    Immediate,    // 立即切换
    Graceful,     // 优雅切换，等待合适时机
    Deferred,     // 延迟切换
    Never,        // 不切换
}
```

### 切换决策引擎
```rust
pub struct SwitchDecisionEngine {
    switching_rules: Vec<SwitchingRule>,
    switching_cooldown: Duration,
    quality_thresholds: QualityThresholds,
    hysteresis_factor: f32,
}

impl SwitchDecisionEngine {
    pub fn evaluate_switch_needed(&self, 
                                 active_transport: &ActiveTransport, 
                                 context: &ContextInfo,
                                 available_alternatives: &[TransportType]) -> Option<SwitchDecision> {
        
        // 检查冷却时间
        if active_transport.last_switch_time.elapsed() < self.switching_cooldown {
            return None;
        }
        
        // 检查当前传输质量
        let current_quality = active_transport.transport.get_quality_score();
        
        // 质量下降检测
        if current_quality < self.quality_thresholds.minimum_acceptable {
            return Some(SwitchDecision {
                device_id: active_transport.device_id.clone(),
                current_transport: active_transport.transport_type,
                target_transport: self.find_best_alternative(available_alternatives, context)?,
                reason: SwitchReason::QualityDegraded {
                    current_quality,
                    threshold: self.quality_thresholds.minimum_acceptable,
                },
                urgency: SwitchUrgency::Immediate,
                estimated_benefit: self.quality_thresholds.minimum_acceptable - current_quality,
            });
        }
        
        // 寻找更好的替代方案
        if let Some(better_alternative) = self.find_better_alternative(
            active_transport.transport_type,
            current_quality,
            available_alternatives,
            context
        ) {
            return Some(SwitchDecision {
                device_id: active_transport.device_id.clone(),
                current_transport: active_transport.transport_type,
                target_transport: better_alternative.transport_type,
                reason: SwitchReason::BetterAlternativeAvailable {
                    alternative_quality: better_alternative.quality,
                    current_quality,
                },
                urgency: SwitchUrgency::Graceful,
                estimated_benefit: better_alternative.quality - current_quality,
            });
        }
        
        None
    }
    
    fn find_best_alternative(&self, alternatives: &[TransportType], context: &ContextInfo) -> Option<TransportType> {
        alternatives.iter()
            .filter(|&&t| t != TransportType::Wifi) // 排除当前传输
            .max_by_key(|&&t| {
                let score = self.estimate_transport_quality(t, context);
                (score * 1000.0) as i32
            })
            .copied()
    }
    
    fn find_better_alternative(&self,
                               current_transport: TransportType,
                               current_quality: f32,
                               alternatives: &[TransportType],
                               context: &ContextInfo) -> Option<BetterAlternative> {
        
        let threshold = current_quality * (1.0 + self.hysteresis_factor); // 迟滞效应
        
        alternatives.iter()
            .filter(|&&t| t != current_transport)
            .filter_map(|&transport_type| {
                let quality = self.estimate_transport_quality(transport_type, context);
                if quality > threshold {
                    Some(BetterAlternative {
                        transport_type,
                        quality,
                    })
                } else {
                    None
                }
            })
            .max_by(|a, b| a.quality.partial_cmp(&b.quality).unwrap_or(std::cmp::Ordering::Equal))
    }
    
    fn estimate_transport_quality(&self, transport_type: TransportType, context: &ContextInfo) -> f32 {
        // 简化的质量估算
        match transport_type {
            TransportType::Wifi => {
                if !context.network_info.wifi_available {
                    return 0.0;
                }
                match context.network_info.wifi_quality {
                    NetworkQuality::Excellent => 0.95,
                    NetworkQuality::Good => 0.85,
                    NetworkQuality::Fair => 0.65,
                    NetworkQuality::Poor => 0.35,
                }
            }
            TransportType::Ble => {
                if !context.ble_info.ble_available {
                    return 0.0;
                }
                if context.ble_info.nearby_devices.is_empty() {
                    return 0.0;
                }
                
                let avg_rssi = context.ble_info.nearby_devices
                    .iter()
                    .map(|d| d.rssi)
                    .sum::<i32>() as f32 / context.ble_info.nearby_devices.len() as f32;
                
                match avg_rssi {
                    rssi if rssi > -60 => 0.9,
                    rssi if rssi > -80 => 0.7,
                    rssi if rssi > -90 => 0.4,
                    _ => 0.2,
                }
            }
        }
    }
}
```

### 状态迁移处理器
```rust
pub struct StateMigrationHandler {
    session_manager: SessionManager,
    data_synchronizer: DataSynchronizer,
    connection_preserver: ConnectionPreserver,
}

impl StateMigrationHandler {
    pub async fn migrate_transport_state(&mut self,
                                       from_transport: &mut dyn Transport,
                                       to_transport: &mut dyn Transport,
                                       switch_decision: &SwitchDecision) -> Result<MigrationResult, MigrationError> {
        
        info!("Starting migration from {:?} to {:?} for device {}",
              switch_decision.current_transport,
              switch_decision.target_transport,
              switch_decision.device_id);
        
        // 1. 保存当前会话状态
        let session_state = self.session_manager.save_session_state(from_transport).await?;
        
        // 2. 同步待发送数据
        let pending_data = self.data_synchronizer.get_pending_data(&switch_decision.device_id).await?;
        
        // 3. 连接到新传输
        match to_transport.connect().await {
            Ok(_) => {
                info!("Successfully connected to new transport");
            }
            Err(e) => {
                error!("Failed to connect to new transport: {}", e);
                return Err(MigrationError::ConnectionFailed(e));
            }
        }
        
        // 4. 恢复会话状态
        self.session_manager.restore_session_state(to_transport, &session_state).await?;
        
        // 5. 重新发送待处理数据
        if !pending_data.is_empty() {
            info!("Resending {} pending packets", pending_data.len());
            for data in pending_data {
                if let Err(e) = to_transport.send_data(&data).await {
                    warn!("Failed to resend pending data: {}", e);
                    // 记录重试
                    self.data_synchronizer.record_retry(&switch_decision.device_id, data).await?;
                }
            }
        }
        
        // 6. 验证迁移成功
        if self.verify_migration_success(from_transport, to_transport).await? {
            Ok(MigrationResult {
                success: true,
                data_packets_migrated: pending_data.len() as u32,
                migration_time: SystemTime::now(),
                session_restored: true,
            })
        } else {
            Err(MigrationError::VerificationFailed)
        }
    }
    
    async fn verify_migration_success(&self,
                                      old_transport: &dyn Transport,
                                      new_transport: &dyn Transport) -> Result<bool, MigrationError> {
        // 发送验证数据包
        let verification_data = b"VERIFICATION_PACKET";
        new_transport.send_data(verification_data).await?;
        
        // 等待确认
        tokio::time::timeout(Duration::from_secs(5), async {
            // 这里需要实现具体的验证逻辑
            Ok(true)
        }).await
        .map_err(|_| MigrationError::Timeout)?
    }
}
```

### 切换管理器实现
```rust
impl TransportSwitcher {
    pub async fn monitor_and_switch(&mut self) {
        let mut interval = interval(Duration::from_secs(10));
        
        loop {
            interval.tick().await;
            
            let context = self.context_monitor.get_context().await.unwrap();
            
            // 检查所有活跃传输
            let mut switches_to_perform = Vec::new();
            
            for (device_id, active_transport) in self.active_transports.iter_mut() {
                let available_alternatives = self.get_available_transports(device_id, &context).await;
                
                if let Some(switch_decision) = self.switch_decision_engine
                    .evaluate_switch_needed(active_transport, &context, &available_alternatives) {
                    
                    info!("Switch decision for device {}: {:?}", device_id, switch_decision);
                    switches_to_perform.push(switch_decision);
                }
            }
            
            // 执行切换
            for switch_decision in switches_to_perform {
                if let Err(e) = self.perform_switch(&switch_decision).await {
                    error!("Failed to perform switch for device {}: {}", 
                           switch_decision.device_id, e);
                }
            }
        }
    }
    
    async fn perform_switch(&mut self, switch_decision: &SwitchDecision) -> Result<(), SwitchError> {
        let device_id = &switch_decision.device_id;
        
        // 获取当前和目标传输
        let current_transport = self.active_transports.get_mut(device_id)
            .ok_or(SwitchError::DeviceNotFound)?;
        
        let target_transport = self.create_target_transport(
            switch_decision.target_transport,
            device_id
        ).await?;
        
        // 根据紧急程度处理切换
        match switch_decision.urgency {
            SwitchUrgency::Immediate => {
                self.immediate_switch(current_transport, target_transport, switch_decision).await?;
            }
            SwitchUrgency::Graceful => {
                self.graceful_switch(current_transport, target_transport, switch_decision).await?;
            }
            SwitchUrgency::Deferred => {
                self.deferred_switch(current_transport, target_transport, switch_decision).await?;
            }
            SwitchUrgency::Never => {
                return Ok(());
            }
        }
        
        // 更新活跃传输
        self.update_active_transport(device_id, target_transport).await?;
        
        // 发送切换事件
        self.event_emitter.emit(SwitchEvent::Completed {
            device_id: device_id.clone(),
            from_transport: switch_decision.current_transport,
            to_transport: switch_decision.target_transport,
            timestamp: SystemTime::now(),
        });
        
        Ok(())
    }
    
    async fn immediate_switch(&self,
                               current_transport: &mut ActiveTransport,
                               target_transport: Box<dyn Transport>,
                               switch_decision: &SwitchDecision) -> Result<(), SwitchError> {
        
        info!("Performing immediate switch for device {}", switch_decision.device_id);
        
        // 强制断开当前连接
        let _ = current_transport.transport.disconnect().await;
        
        // 立即连接新传输
        target_transport.connect().await
            .map_err(|e| SwitchError::ConnectionFailed(e))?;
        
        Ok(())
    }
    
    async fn graceful_switch(&self,
                            current_transport: &mut ActiveTransport,
                            target_transport: Box<dyn Transport>,
                            switch_decision: &SwitchDecision) -> Result<(), SwitchError> {
        
        info!("Performing graceful switch for device {}", switch_decision.device_id);
        
        // 等待合适的切换时机（无活动传输时）
        self.wait_for_safe_switching_opportunity(current_transport).await?;
        
        // 执行状态迁移
        self.state_migration_handler.migrate_transport_state(
            current_transport.transport.as_mut(),
            target_transport.as_ref(),
            switch_decision
        ).await?;
        
        Ok(())
    }
    
    async fn wait_for_safe_switching_opportunity(&self, transport: &ActiveTransport) -> Result<(), SwitchError> {
        let mut timeout = Duration::from_secs(30);
        let interval = Duration::from_millis(100);
        
        while timeout > Duration::ZERO {
            // 检查是否有活动传输
            if transport.metrics.bytes_sent == transport.metrics.bytes_received {
                return Ok(()); // 安全切换时机
            }
            
            tokio::time::sleep(interval).await;
            timeout -= interval;
        }
        
        Err(SwitchError::Timeout("Waited too long for safe switching opportunity".to_string()))
    }
}
```

## 验收标准

- [ ] 切换决策准确
- [ ] 状态迁移可靠
- [ ] 切换过程无缝
- [ ] 数据不丢失
- [ ] 性能影响最小
- [ ] 错误恢复完善
- [ ] 切换记录完整