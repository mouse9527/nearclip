# Task 0108: 实现BLE传输适配器

## 任务描述

实现基于BLE的传输适配器，提供低功耗蓝牙通信功能。

## 正交性分析

- **蓝牙通信**: 专注于BLE协议通信
- **低功耗优化**: 功耗和性能平衡
- **分包传输**: BLE MTU限制处理
- **连接管理**: BLE连接生命周期

## 技术实现

### 核心组件
```rust
// rust-core/transport/ble_transport.rs
pub struct BleTransport {
    peripheral: Option<Box<dyn BlePeripheral>>,
    characteristic: Option<BleCharacteristic>,
    connection_info: BleConnectionInfo,
    config: BleTransportConfig,
    metrics: BleTransportMetrics,
    state: TransportState,
    event_handler: Option<Box<dyn TransportEventHandler>>,
    packet_builder: BlePacketBuilder,
}

pub struct BleConnectionInfo {
    pub device_address: String,
    pub device_name: Option<String>,
    pub rssi: i32,
    pub service_uuid: String,
    pub characteristic_uuid: String,
    pub mtu_size: usize,
    pub connection_interval: Option<Duration>,
}

pub struct BleTransportConfig {
    pub base_config: TransportConfig,
    pub ble_config: BleConfig,
}

pub struct BleConfig {
    pub scan_timeout: Duration,
    pub connection_timeout: Duration,
    pub service_discovery_timeout: Duration,
    pub enable_encryption: bool,
    pub preferred_mtu: usize,
    pub write_without_response: bool,
    pub max_concurrent_writes: usize,
}

pub struct BlePacketBuilder {
    mtu_size: usize,
    sequence_number: u32,
    compression_enabled: bool,
}
```

### BLE数据包结构
```rust
#[derive(Debug, Clone)]
pub struct BlePacket {
    pub header: BlePacketHeader,
    pub payload: Vec<u8>,
    pub checksum: u16,
}

#[derive(Debug, Clone)]
pub struct BlePacketHeader {
    pub magic_number: u16,
    pub packet_type: BlePacketType,
    pub sequence_number: u32,
    pub total_packets: u16,
    pub current_packet: u16,
    pub flags: BlePacketFlags,
    pub payload_length: u16,
}

#[derive(Debug, Clone)]
pub enum BlePacketType {
    Data,
    Ack,
    Nack,
    Heartbeat,
    Control,
}

pub struct BlePacketFlags {
    pub compressed: bool,
    pub encrypted: bool,
    pub last_packet: bool,
    pub requires_ack: bool,
}
```

### 实现Transport trait
```rust
impl Transport for BleTransport {
    async fn connect(&mut self) -> Result<(), TransportError> {
        // 连接到BLE外设
        let peripheral = self.connect_to_peripheral().await?;
        
        // 发现服务
        let service = self.discover_service(&peripheral).await?;
        
        // 获取特征值
        let characteristic = self.discover_characteristic(&service).await?;
        
        // 协商MTU
        let negotiated_mtu = self.negotiate_mtu(&peripheral).await?;
        self.connection_info.mtu_size = negotiated_mtu;
        self.packet_builder = BlePacketBuilder::new(negotiated_mtu);
        
        self.peripheral = Some(peripheral);
        self.characteristic = Some(characteristic);
        self.state = TransportState::Connected;
        
        // 启动监控任务
        self.start_monitoring_tasks().await;
        
        Ok(())
    }
    
    async fn send_data(&mut self, data: &[u8]) -> Result<(), TransportError> {
        let peripheral = self.peripheral.as_ref()
            .ok_or(TransportError::NotConnected)?;
        let characteristic = self.characteristic.as_ref()
            .ok_or(TransportError::NotConnected)?;
        
        // 构建BLE数据包
        let packets = self.packet_builder.build_packets(data)?;
        
        for packet in packets {
            // 序列化数据包
            let packet_data = self.serialize_packet(&packet)?;
            
            // BLE MTU限制，可能需要进一步分包
            for chunk in packet_data.chunks(self.connection_info.mtu_size - 3) {
                match characteristic.write_value(chunk).await {
                    Ok(_) => {
                        self.metrics.bytes_sent += chunk.len() as u64;
                        self.metrics.packets_sent += 1;
                    }
                    Err(e) => {
                        self.metrics.error_count += 1;
                        return Err(TransportError::SendFailed(e.to_string()));
                    }
                }
            }
            
            // 如果需要确认，等待ACK
            if packet.header.flags.requires_ack {
                self.wait_for_ack(packet.header.sequence_number).await?;
            }
        }
        
        Ok(())
    }
    
    fn get_quality_score(&self) -> f32 {
        if !self.is_connected() {
            return 0.0;
        }
        
        let mut score = 1.0;
        
        // 基于RSSI信号强度
        score *= match self.connection_info.rssi {
            rssi if rssi > -60 => 0.9,    // 优秀
            rssi if rssi > -80 => 0.7,    // 良好
            rssi if rssi > -90 => 0.4,    // 一般
            _ => 0.1,                     // 差
        };
        
        // 基于MTU大小（越大效率越高）
        score *= match self.connection_info.mtu_size {
            mtu if mtu >= 512 => 1.0,
            mtu if mtu >= 256 => 0.9,
            mtu if mtu >= 128 => 0.7,
            _ => 0.5,
        } as f32 / 1000.0 * self.connection_info.mtu_size as f32;
        
        // 基于连接稳定性
        score *= match self.connection_info.connection_interval {
            Some(interval) => {
                if interval < Duration::from_millis(30) {
                    0.9 // 高频连接，稳定性较好
                } else if interval < Duration::from_millis(100) {
                    0.8
                } else {
                    0.6 // 低频连接，可能不稳定
                }
            }
            None => 0.5,
        };
        
        // 基于错误率
        let error_rate = self.metrics.error_count as f32 / (self.metrics.packets_sent + 1) as f32;
        score *= (1.0 - error_rate).max(0.1);
        
        score
    }
    
    fn get_connection_info(&self) -> ConnectionInfo {
        ConnectionInfo {
            transport_type: TransportType::Ble,
            remote_address: self.connection_info.device_address.clone(),
            connection_time: self.metrics.connection_start_time,
            last_activity: self.metrics.last_activity,
            metadata: {
                let mut meta = HashMap::new();
                meta.insert("rssi".to_string(), self.connection_info.rssi.to_string());
                meta.insert("mtu_size".to_string(), self.connection_info.mtu_size.to_string());
                meta.insert("service_uuid".to_string(), self.connection_info.service_uuid.clone());
                if let Some(name) = &self.connection_info.device_name {
                    meta.insert("device_name".to_string(), name.clone());
                }
                meta
            },
        }
    }
}
```

### BLE特定功能
```rust
impl BleTransport {
    async fn connect_to_peripheral(&self) -> Result<Box<dyn BlePeripheral>, TransportError> {
        // 扫描并连接到指定的BLE设备
        // 这里会调用具体的BLE平台API
        Ok(Box::new(MockBlePeripheral::new()))
    }
    
    async fn discover_service(&self, peripheral: &dyn BlePeripheral) -> Result<BleService, TransportError> {
        // 发现服务
        Ok(BleService::new())
    }
    
    async fn discover_characteristic(&self, service: &BleService) -> Result<BleCharacteristic, TransportError> {
        // 发现特征值
        Ok(BleCharacteristic::new())
    }
    
    async fn negotiate_mtu(&self, peripheral: &dyn BlePeripheral) -> Result<usize, TransportError> {
        // 协商MTU大小
        Ok(self.config.ble_config.preferred_mtu.min(512))
    }
    
    async fn start_monitoring_tasks(&self) {
        // 启动RSSI监控、连接状态监控等任务
    }
    
    async fn wait_for_ack(&self, sequence_number: u32) -> Result<(), TransportError> {
        // 等待数据包确认
        tokio::time::timeout(
            Duration::from_secs(5),
            async {
                // 实现ACK等待逻辑
                Ok(())
            }
        ).await
        .map_err(|_| TransportError::Timeout("ACK timeout".to_string()))?
    }
}
```

### 功耗优化
```rust
impl BleTransport {
    pub async fn enable_low_power_mode(&mut self) -> Result<(), TransportError> {
        if let Some(peripheral) = &self.peripheral {
            // 设置连接间隔，降低功耗
            peripheral.set_connection_parameters(
                Duration::from_millis(100), // 最小间隔
                Duration::from_millis(500), // 最大间隔
                0,                         // 从机延迟
                Duration::from_millis(500), // 超时
            ).await?;
        }
        Ok(())
    }
    
    pub async fn enable_high_performance_mode(&mut self) -> Result<(), TransportError> {
        if let Some(peripheral) = &self.peripheral {
            // 设置高性能连接参数
            peripheral.set_connection_parameters(
                Duration::from_millis(15),  // 最小间隔
                Duration::from_millis(30),  // 最大间隔
                0,                         // 从机延迟
                Duration::from_millis(100), // 超时
            ).await?;
        }
        Ok(())
    }
}
```

## 验收标准

- [ ] BLE连接稳定
- [ ] 低功耗优化
- [ ] 数据包传输可靠
- [ ] MTU协商合理
- [ ] 功耗模式可配置
- [ ] 错误处理完善
- [ ] RSSI监控准确