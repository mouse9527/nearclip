# Task 0107: 实现WiFi传输适配器

## 任务描述

实现基于WiFi的传输适配器，提供TCP/IP网络通信功能。

## 正交性分析

- **网络通信**: 专注于TCP/IP通信
- **连接管理**: WiFi连接生命周期
- **性能优化**: 网络性能调优
- **错误恢复**: 网络错误处理

## 技术实现

### 核心组件
```rust
// rust-core/transport/wifi_transport.rs
pub struct WifiTransport {
    socket: Option<TcpStream>,
    connection_info: WifiConnectionInfo,
    config: WifiTransportConfig,
    metrics: WifiTransportMetrics,
    state: TransportState,
    event_handler: Option<Box<dyn TransportEventHandler>>,
}

pub struct WifiConnectionInfo {
    pub remote_ip: String,
    pub remote_port: u16,
    pub local_ip: String,
    pub local_port: u16,
    pub signal_strength: Option<i32>,
    pub network_type: NetworkType,
}

pub struct WifiTransportConfig {
    pub base_config: TransportConfig,
    pub socket_config: SocketConfig,
    pub network_config: NetworkConfig,
}

pub struct SocketConfig {
    pub tcp_no_delay: bool,
    pub keep_alive: bool,
    pub send_buffer_size: usize,
    pub receive_buffer_size: usize,
    pub ttl: u32,
}

#[derive(Debug)]
pub enum NetworkType {
    Wifi { ssid: String, signal_strength: i32 },
    Ethernet,
    MobileHotspot { ssid: String },
    Unknown,
}
```

### 实现Transport trait
```rust
impl Transport for WifiTransport {
    async fn connect(&mut self) -> Result<(), TransportError> {
        let addr = format!("{}:{}", self.connection_info.remote_ip, self.connection_info.remote_port);
        let socket_addr = addr.parse()
            .map_err(|e| TransportError::InvalidAddress(e.to_string()))?;
        
        // 创建TCP连接
        let mut socket = TcpStream::connect(socket_addr).await
            .map_err(|e| TransportError::ConnectionFailed(e.to_string()))?;
        
        // 配置socket选项
        self.configure_socket(&mut socket).await?;
        
        // 设置超时
        socket.set_read_timeout(Some(self.config.base_config.read_timeout))
            .map_err(|e| TransportError::ConfigurationError(e.to_string()))?;
        
        socket.set_write_timeout(Some(self.config.base_config.write_timeout))
            .map_err(|e| TransportError::ConfigurationError(e.to_string()))?;
        
        self.socket = Some(socket);
        self.state = TransportState::Connected;
        
        // 发送连接事件
        if let Some(handler) = &self.event_handler {
            handler.on_transport_event(TransportEvent::Connected {
                transport_type: TransportType::Wifi,
                connection_info: self.get_connection_info(),
            });
        }
        
        Ok(())
    }
    
    async fn send_data(&mut self, data: &[u8]) -> Result<(), TransportError> {
        let socket = self.socket.as_mut()
            .ok_or(TransportError::NotConnected)?;
        
        let start_time = SystemTime::now();
        
        // 分包发送大数据
        for chunk in data.chunks(self.config.base_config.max_packet_size) {
            socket.write_all(chunk).await
                .map_err(|e| TransportError::SendFailed(e.to_string()))?;
        }
        
        // 更新指标
        let duration = start_time.elapsed().unwrap_or_default();
        self.metrics.bytes_sent += data.len() as u64;
        self.metrics.packets_sent += 1;
        self.metrics.update_average_latency(duration);
        
        // 发送发送事件
        if let Some(handler) = &self.event_handler {
            handler.on_transport_event(TransportEvent::DataSent {
                size: data.len(),
                duration,
            });
        }
        
        Ok(())
    }
    
    fn get_quality_score(&self) -> f32 {
        if !self.is_connected() {
            return 0.0;
        }
        
        let mut score = 1.0;
        
        // 基于信号强度
        if let Some(signal) = self.connection_info.signal_strength {
            score *= match signal {
                s if s > -50 => 1.0,      // 优秀
                s if s > -70 => 0.8,      // 良好
                s if s > -80 => 0.5,      // 一般
                _ => 0.2,                 // 差
            };
        }
        
        // 基于延迟
        score *= match self.metrics.average_latency {
            d if d < Duration::from_millis(10) => 1.0,
            d if d < Duration::from_millis(50) => 0.9,
            d if d < Duration::from_millis(100) => 0.7,
            d if d < Duration::from_millis(200) => 0.5,
            _ => 0.3,
        };
        
        // 基于错误率
        let error_rate = self.metrics.error_count as f32 / (self.metrics.packets_sent + 1) as f32;
        score *= (1.0 - error_rate).max(0.1);
        
        score
    }
    
    fn get_connection_info(&self) -> ConnectionInfo {
        ConnectionInfo {
            transport_type: TransportType::Wifi,
            remote_address: format!("{}:{}", self.connection_info.remote_ip, self.connection_info.remote_port),
            connection_time: self.metrics.connection_start_time,
            last_activity: self.metrics.last_activity,
            metadata: {
                let mut meta = HashMap::new();
                meta.insert("signal_strength".to_string(), 
                    self.connection_info.signal_strength.unwrap_or(0).to_string());
                meta.insert("network_type".to_string(), 
                    format!("{:?}", self.connection_info.network_type));
                meta.insert("local_ip".to_string(), 
                    self.connection_info.local_ip.clone());
                meta
            },
        }
    }
}
```

### 网络质量监控
```rust
impl WifiTransport {
    async fn monitor_network_quality(&mut self) {
        let mut interval = interval(Duration::from_secs(5));
        
        loop {
            interval.tick().await;
            
            if let Some(socket) = &self.socket {
                // 检测延迟
                let start_time = SystemTime::now();
                match socket.peek(&mut [0u8; 1]).await {
                    Ok(_) => {
                        let latency = start_time.elapsed().unwrap_or_default();
                        self.metrics.update_average_latency(latency);
                        
                        // 检测信号强度变化
                        if let Ok(new_signal) = self.detect_signal_strength().await {
                            if new_signal != self.connection_info.signal_strength {
                                let old_score = self.get_quality_score();
                                self.connection_info.signal_strength = Some(new_signal);
                                let new_score = self.get_quality_score();
                                
                                if let Some(handler) = &self.event_handler {
                                    handler.on_transport_event(TransportEvent::QualityChanged {
                                        old_score,
                                        new_score,
                                    });
                                }
                            }
                        }
                    }
                    Err(e) => {
                        self.metrics.error_count += 1;
                        
                        if let Some(handler) = &self.event_handler {
                            handler.on_transport_event(TransportEvent::Error {
                                error: TransportError::NetworkError(e.to_string()),
                                context: "Network quality monitoring".to_string(),
                            });
                        }
                    }
                }
            }
        }
    }
    
    async fn detect_signal_strength(&self) -> Result<i32, TransportError> {
        // 实现信号强度检测
        // 这里可能需要调用平台特定的API
        Ok(-65) // 示例值
    }
}
```

## 验收标准

- [ ] WiFi连接稳定可靠
- [ ] 数据传输性能优化
- [ ] 网络质量监控完善
- [ ] 错误恢复机制
- [ ] 配置灵活
- [ ] 事件通知及时
- [ ] 资源使用合理